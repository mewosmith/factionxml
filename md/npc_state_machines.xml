<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="NPC_State_Machines.xsl" type="text/xsl" ?>
<mdscript name="NPC_State_Machines" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>
    <!--TODO @Owen DockArea > WalkableModule-->

    <!--DEBUG-->
    <cue name="NPCWalkTest" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled/>
        <check_value value="player.room.parent.isclass.walkablemodule"/>
      </conditions>
      <actions>
        <set_value name="$DockArea" exact="player.room.parent"/>
        <find_station name="$Stations" space="player.sector" multiple="true"/>
        <do_all exact="$Stations.count" counter="$i">
          <find_object_component groupname="$NPCs" class="class.npc" entitytype="entitytype.crowd" object="$Stations.{$i}" multiple="true"/>
          <destroy_group group="$NPCs"/>
        </do_all>

      </actions>
      <cues>
        <cue name="NPCWalkTest_Delay">
          <delay exact="2s"/>
          <actions>
            <find_npc_slot name="$DockAreaSlots" object="$DockArea" multiple="true"/>
            <create_cue_actor cue="this" name="$NPC">
              <select race="race.argon"/>
            </create_cue_actor>
            <set_value name="$NPC.$DebugDockAreaMovement" exact="true"/>
            <set_entity_traits entity="$NPC" missionactor="true"/>
            <set_entity_type entity="$NPC" type="entitytype.crowd"/>
            <add_actor_to_room actor="$NPC" slot="$DockAreaSlots.random" />
          </actions>
        </cue>
      </cues>
    </cue>

    <cue name="Base" namespace="this" instantiate="true" version="3">
      <conditions>
        <event_npc_created/>
        <check_value value="event.param.exists and not event.param.cluster.ispresentation"/>
        <!--HACK @Owen event_npc_created should not fire for NPCs created as a result of loading a savegame-->
        <check_value value="not event.param.$StateMachine?"/>
      </conditions>
      <actions>
        <set_value name="$NPC" exact="event.param"/>
        <!--<assert value="not $NPC.$StateMachine?" text="'NPC already has a state machine [Owen]'" break="always"/>-->
        <set_value name="$NPC.$StateMachine" exact="this"/>
        <set_value name="$ActiveStates" exact="[]"/>
        <set_value name="$QueuedTransitionRequests" exact="[]"/>
        <set_value name="$DebugChance" exact="0"/>
        <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' created with INIT state'" chance="$DebugChance" />
      </actions>
      <patch sinceversion="2" state="complete">
        <!--This is a convenient cue to patch NPC with incorrect conversation handlers without having to find them in the galaxy-->
        <do_if value="$NPC.controlpost == controlpost.shiptrader and not $NPC.customhandler">
          <debug_text text="'Ship trader ' + $NPC + ' ' + $NPC.knownname + 'of faction ' + $NPC.owner.id + ' had no custom handler. Restarting shiptrader conversation handler'" filter="savegame"/>
          <signal_cue_instantly cue="md.NPC_Shiptrader.Base" param="$NPC"/>
        </do_if>
      </patch>
      <patch sinceversion="3" state="complete">
        <remove_value name="$AncestorCues"/>
      </patch>
      <cues>
        <cue name="NPC_Killed">
          <conditions>
            <check_any>
              <event_object_destroyed object="$NPC"/>
              <event_object_changed_attention object="$NPC" attention="attention.unknown" comment="Disconnected. New state machine will be started if re-connected."/>
              <check_all>
                <!--Some entities are disconnected before the kill event is dispatched e.g. mass traffic pilots. Checking if they were removed with a kill method catches this case.-->
                <event_control_entity_removed object="$NPC"/>
                <check_value value="event.param2"/>
              </check_all>
              <!--Disabled due to exceeding the max number of listeners. Replaced with hack below-->
              <!--<check_all>
                <event_game_loaded/>
                <check_value value="not $NPC.exists"/>
              </check_all>-->
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' - Stopping state machine due to ' + event.name" chance="$DebugChance"/>
            <remove_value name="$NPC.$StateMachine"/>
            <cancel_cue cue="Base"/>
          </actions>
        </cue>

        <!--HACK-->
        <cue name="NPC_Check_Lost" checkinterval="5s">
          <conditions>
            <check_value value="not $NPC.exists"/>
          </conditions>
          <actions>
            <assert value="$NPC.exists" text="'NPC no longer exists but case was not caught by NPC_Killed: ' + $NPC + ' type: ' + $NPC.type + ' role: ' + $NPC.role + ' post ' + $NPC.controlpost + ' - Aborting state machine. [Owen]'"/>
            <cancel_cue cue="Base"/>
          </actions>
        </cue>

        <!--
        ########################
        USECASE RESERVATIONS
        ########################-->

        <library name="Validate_Usecase_Reservation">
          <actions>
            <do_if value="$UsecaseCue? and not $UsecaseCue.exists">
              <assert value="$UsecaseCue.exists" text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' referenced a usecase which no longer exists. Should have been cleaned up earlier. [Owen]'"/>
              <remove_value name="$UsecaseCue"/>
            </do_if>
          </actions>
        </library>

        <!--
        NPC signalled to check if this NPC can be requested by a usecase.
        
        event.param = 'can_be_reserved_by_usecase'
        event.param2 = $ResultCue (result saved to $CanReserve)
        -->
        <cue name="Can_Be_Requested_By_Usecase" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'can_be_reserved_by_usecase'"/>
          </conditions>
          <actions>
            <debug_text text="'Checking if ' + $NPC + ' ' + $NPC.knownname + ' can be requsted for a usecase'" chance="$DebugChance"/>

            <set_value name="event.param2.$CanRequest" exact="false"/>

            <include_actions ref="Validate_Usecase_Reservation"/>

            <do_if value="$ActiveStates.count and 
                   not @$NPC.$state_machine_critical and
                   $QueuedTransitionRequests.count == 0 and 
                   not @Handle_ChangeState.$QueuedTransition and 
                   not $UsecaseCue? and
                   $NPC != player.conversationactor and
                   (not $NPC.controlled or not $NPC.controlled.order or $NPC.controlled.order.canplayercancel)">

              <signal_cue_instantly cue="$ActiveStates.{$ActiveStates.count}" param="'check_can_allow_npc_usecase_reservation'" check="false"/>

              <set_value name="event.param2.$CanRequest" exact="@$ActiveStates.{$ActiveStates.count}.$AllowUsecaseReservation == true" comment="== true just so we don't set the result to 'null' in some cases"/>
            </do_if>
          </actions>
        </cue>

        <!--
        Check if the NPC's current state is listening for a transition request of a certain ID
        
        event.param = 'can_have_transition'
        event.param2 = $ResultCue (result saved to $CanTransition)
        event.param3 = list to define a transition to request and its parameters:
          e.g. ['npc_move_to', $paramtable]
        -->
        <cue name="Can_Have_Transition" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'can_have_transition'"/>
          </conditions>
          <actions>
            <debug_text text="'Checking if ' + $NPC + ' ' + $NPC.knownname + ' can be signalled to transition to ' + event.param3.{1} + ' with params: ' + @event.param3.{2} + ' and ' + @event.param3.{3}" chance="$DebugChance"/>

            <set_value name="$CanHaveTransition_Result" exact="null"/>
            <signal_objects object="$NPC" param="event.param3.{1}" param2="@event.param3.{2}" param3="@event.param3.{3}"/>
            <set_value name="event.param2.$CanTransition" exact="$CanHaveTransition_Result == true" comment="== true just so we don't set the result to 'null' in some cases"/>

            <debug_text text="if $CanHaveTransition_Result then (event.param3.{1} + ' can be signalled') else (event.param3.{1} + ' can not be signalled')" chance="$DebugChance"/>
            <remove_value name="$CanHaveTransition_Result"/>
          </actions>
        </cue>

        <!--
        Reserve a NPC for a usecase
        
        event.param = 'reserve_for_usecase'
        event.param2 = Usecase related cue, to be stored for reference (potentially could also be signalled by the NPC if needed)
        -->
        <cue name="Reserve_For_Usecase" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'reserve_for_usecase'"/>
          </conditions>
          <actions>
            <debug_text text="'Attempting to reserve NPC ' + $NPC + ' ' + $NPC.knownname + ' for usecase of cue ' + event.param2" chance="$DebugChance"/>

            <include_actions ref="Validate_Usecase_Reservation"/>

            <do_if value="event.param2.exists and not @$UsecaseCue">
              <assert value="$ActiveStates.count and 
                   not @$NPC.$state_machine_critical and
                   $QueuedTransitionRequests.count == 0 and 
                   not @Handle_ChangeState.$QueuedTransition and 
                   $NPC != player.conversationactor and
                   (not $NPC.controlled or not $NPC.controlled.order or $NPC.controlled.order.canplayercancel)" text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' has been reserved for usecase ' + event.param2 + ' while being in a potentially busy state [Owen]'"/>

              <set_value name="$UsecaseCue" exact="event.param2"/>
            </do_if>
          </actions>
        </cue>

        <!--
        Release a usecase reservation of a NPC
        
        event.param = 'release_usecase_reservation'
        -->
        <cue name="Release_Usecase_Reservation" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'release_usecase_reservation'"/>
          </conditions>
          <actions>
            <do_if value="$UseCase?">
              <debug_text text="'Releasing usecase reservation for NPC: ' + $NPC + ' ' + $NPC.knownname + ' of usecase ' + $UsecaseCue" chance="$DebugChance"/>
              <remove_value name="$UsecaseCue"/>
            </do_if>
            <do_else>
              <debug_text text="'Attempting to release usecase reservation for NPC: ' + $NPC + ' ' + $NPC.knownname + ' but they were not reserved.'" filter="error"/>
            </do_else>
          </actions>
        </cue>

        <cue name="Meet_Greet_Request" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_value value="event.param == 'meetandgreet'"/>
          </conditions>
          <actions>
            <set_value name="$MetNPC" exact="event.param2"/>
            <!--<debug_text text="'MeetandGreet Request: ' + $NPC.knownname + ' and ' + $MetNPC.knownname" chance="$DebugChance"/>-->
            <signal_cue_instantly cue="md.NPC_UseCases.UseCase" param="table[ $name = '$MeetAndGreet', $actors = table[ $Actor1 = $NPC, $Actor2 = $MetNPC ] ]" />
          </actions>
        </cue>

        <!--cue name="DebugConv">
          <conditions>
            <event_conversation_started actor="$NPC"/>
          </conditions>
          <actions>
            <set_value name="$DebugChance" exact="100"/>
          </actions>
        </cue-->

        <!--State Management-->

        <!--The requested state changes or queued transitions are processed as soon as the NPC is not in a critical movement state e.g. halfway climbing a ladder-->

        <!--event.param = 
            - (On state request) State cue to request a state change to
            - (On signal from ChangeState_Dispatch) Nothing, as $RequestedCue should already be set
        This cue is instantiated so that the state machine is always listening for signals.
        When a signal comes, it will prepare the variables used by Handle_ChangeState to actually change the state-->
        <cue name="ChangeState" instantiate="true">
          <conditions>
            <event_cue_signalled/>
            <set_value name="$QueuedTransition" exact="null"/>
            <!--Only process request if it is a different state the the one currently being processed and that it is not a regular request from a critical state while another request is still waiting-->
            <check_value value="event.param and (not @Handle_ChangeState.$Cue or event.param != @Handle_ChangeState.$Cue)"/>
            <set_value name="$RequestedCue" exact="event.param"/>
            <remove_value name="$ParamTable"/>
            <set_value name="$IsTransitionRelatedStateChange" exact="@$DispatchTransitionStateChange"/>
            <debug_text text="$RequestedCue + ' state requested for NPC ' + $NPC" debugchance="$DebugChance"/>
            <check_value value="false" comment="Optimisation. We don't actually need the cue to instantiate."/>
          </conditions>
        </cue>

        <!--
        Internal use. Do not signal from states directly. Use QueueTransitionRequest library to add a new transition request.
        event.param = transition id string
        This cue is instantiated so that the state machine is always listening for signals.-->
        <cue name="RequestQueuedTransition" instantiate="true">
          <conditions>
            <event_cue_signalled/>
            <!--Only process request if there is no $RequestedCue already set-->
            <check_value value="not @$RequestedCue and event.param"/>
            <set_value name="$QueuedTransition" exact="event.param"/>
            <debug_text text="'queued state change to ' + $QueuedTransition + ' requested for NPC ' + $NPC" debugchance="$DebugChance"/>
            <check_value value="false" comment="Optimisation. We don't actually need the cue to instantiate."/>
          </conditions>
        </cue>

        <cue name="Handle_ChangeState">
          <conditions>
            <check_any>
              <check_all>
                <event_cue_signalled cue="ChangeState"/>
                <check_value value="$RequestedCue.exists"/>
              </check_all>
              <check_all>
                <event_cue_signalled cue="RequestQueuedTransition"/>
                <check_value value="$QueuedTransition"/>
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <!--This cue deals with both state changes and queued transitions.
            While this cue is running, any new state request will have it abandon the processing of the state change or transition it was going to process.
            If a state change was going to happen, any requested transition is ignored. The transitions only get processed if the state machine is in a lull.-->

            <do_if value="$RequestedCue">
              <assert value="typeof $RequestedCue == datatype.cue" text="'Requested state change cue was not of type cue: ' + $RequestedCue + ' [Owen]'"/>
              <do_if value="typeof $RequestedCue == datatype.cue">
                <set_value name="this.$Cue" exact="$RequestedCue"/>
                <debug_text text="'Regular state change is set to be processed for ' + $RequestedCue" chance="$DebugChance"/>
                <assert value="not $QueuedTransition" text="'There was a transition request ' + $QueuedTransition + ' alongside a state change request to ' + $RequestedCue + ' which should not happen. [Owen]'"/>
              </do_if>
              <do_else>
                <set_value name="$RequestedCue" exact="null"/>
                <reset_cue cue="Handle_ChangeState"/>
              </do_else>
            </do_if>
            <do_elseif value="$QueuedTransition">
              <debug_text text="'Queued transition is set to be processed for ' + $QueuedTransition" chance="$DebugChance"/>
              <set_value name="this.$QueuedTransition" exact="$QueuedTransition"/>
            </do_elseif>
            <do_else>
              <reset_cue cue="Handle_ChangeState"/>
            </do_else>

            <do_if value="not $NPC.isclass.npc">
              <assert value="$NPC.isclass.npc" text="'NPC is no longer valid. This should have been caught by NPC_Killed. Destructing state machine. [Owen]'"/>
              <cancel_cue cue="Base"/>
            </do_if>
            <do_elseif value="not $NPC.exists">
              <assert value="$NPC.exists" text="'NPC no longer exists but case was not caught by NPC_Killed: ' + $NPC + ' type: ' + $NPC.type + ' role: ' + $NPC.role + ' post ' + $NPC.controlpost + ' - Destructing state machine. [Owen]'"/>
              <cancel_cue cue="Base"/>
            </do_elseif>
          </actions>
          <cues>
            <!--Wait until the NPC is ready for a state change e.g. not in the middle of a critical animation such as climbing a ladder
            Also, if a queued transition, do not perform if $NPC.controlled has an order in a critical section-->
            <cue name="ChangeState_NPC_Ready" checkinterval="1ms">
              <conditions>
                <check_value value="not @$NPC.$state_machine_critical and $NPC != player.conversationactor and (not @parent.$QueuedTransition or not $NPC.controlled or not $NPC.controlled.order or $NPC.controlled.order.canplayercancel)"/>
              </conditions>
            </cue>

            <cue name="ChangeState_Shutdown">
              <conditions>
                <event_cue_completed cue="ChangeState_NPC_Ready"/>
                <check_value value="@parent.$Cue"/>
              </conditions>
              <actions>
                <debug_text text="player.age + ' Can attempt to shutdown states as NPC is not in a critical movement. Condition trigger was: ' + event.object" chance="$DebugChance"/>
                <!--Check that the RequestedCue is still the one set to be processed by this cue-->
                <set_value name="this.$Cue" exact="null"/>
                <do_if value="$RequestedCue.exists and parent.$Cue.exists and $RequestedCue == parent.$Cue">
                  <set_value name="this.$Cue" exact="parent.$Cue"/>

                  <!--Shut down current states to prepare for state change-->
                  <set_value name="$Parent" exact="this.$Cue.parent"/>

                  <do_all chance="$DebugChance">
                    <debug_text text="player.age + ' Shutting down active cues in preparation for activating activating state cue ' + this.$Cue + ' for ' + $NPC + ' ' + $NPC.knownname"/>
                    <debug_text text="'Has ' + $ActiveStates.count + ' Previously active states:'"/>
                    <do_all exact="$ActiveStates.count" counter="$i">
                      <debug_text text="$ActiveStates.{$i}"/>
                    </do_all>
                  </do_all>

                  <set_value name="$AncestorCues" exact="[]"/>
                  <do_while value="$Parent and $Parent.staticbase != Base.staticbase">
                    <append_to_list name="$AncestorCues" exact="$Parent"/>
                    <set_value name="$Parent" exact="$Parent.parent"/>
                  </do_while>
                  <remove_value name="$Parent"/>

                  <do_all chance="$DebugChance">
                    <debug_text text="'Has ' + $AncestorCues.count + ' Ancestor states:'"/>
                    <do_all exact="$AncestorCues.count" counter="$i" reverse="true">
                      <debug_text text="$AncestorCues.{$i}"/>
                    </do_all>
                  </do_all>

                  <do_all exact="$ActiveStates.count" counter="$i" reverse="true">
                    <do_if value="$ActiveStates.{$i} == this.$Cue">
                      <debug_text text="'Reset state ' + this.$Cue" chance="$DebugChance"/>
                      <signal_cue_instantly cue="this.$Cue" param="'exit'"/>
                      <reset_cue cue="this.$Cue"/>
                    </do_if>
                    <do_elseif value="not $AncestorCues.indexof.{$ActiveStates.{$i}}">
                      <debug_text text="'Exiting state ' + $ActiveStates.{$i}" chance="$DebugChance"/>
                      <signal_cue_instantly cue="$ActiveStates.{$i}" param="'exit'"/>
                      <reset_cue cue="$ActiveStates.{$i}"/>
                    </do_elseif>
                  </do_all>

                  <clear_list list="$ActiveStates"/>
                  <do_all exact="$AncestorCues.count" counter="$i" reverse="true">
                    <append_to_list name="$ActiveStates" exact="$AncestorCues.{$i}"/>
                  </do_all>
                  <remove_value name="$AncestorCues"/>

                  <do_all chance="$DebugChance">
                    <debug_text text="'Has ' + $ActiveStates.count + ' Active states:'"/>
                    <do_all exact="$ActiveStates.count" counter="$i">
                      <debug_text text="$ActiveStates.{$i}"/>
                    </do_all>
                  </do_all>
                </do_if>
                <do_else>
                  <debug_text text="player.age + ' Aborting shutdown of active cues for state cue ' + parent.$Cue + ' for ' + $NPC + ' ' + $NPC.knownname + ' - a different state (' + $RequestedCue + ') was requested before the shutdown happened.'" chance="$DebugChance"/>

                  <reset_cue cue="Handle_ChangeState"/>
                  <!--This is simply to trigger Handle_ChangeState again-->
                  <signal_cue cue="ChangeState"/>
                </do_else>
              </actions>
              <cues>
                <cue name="ChangeState_Dispatch">
                  <delay exact="1ms"/>
                  <actions>
                    <!--Check that the RequestedCue is still the one set to be processed by this cue-->
                    <set_value name="this.$Cue" exact="null"/>
                    <do_if value="$RequestedCue.exists and parent.$Cue.exists and $RequestedCue == parent.$Cue">
                      <debug_text text="player.age + ' Dispatched trigger for activating state cue ' + $RequestedCue + ' for ' + $NPC + ' ' + $NPC.knownname + ' - Is transition request: ' + if @$IsTransitionRelatedStateChange then true else false" chance="$DebugChance"/>
                      <assert value="$RequestedCue.state == cuestate.waiting" text="'NPC state cue ' + $RequestedCue + ' is not waiting to be signalled. State machine may stall. [Owen]'" break="1"/>
                      <do_if value="@$IsTransitionRelatedStateChange">
                        <assert value="$QueuedTransitionRequests.count" text="'Processing a transition related state change to ' + $RequestedCue + ', although the request list is empty. [Owen]'"/>
                        <do_if value="$QueuedTransitionRequests.count">
                          <!--ASSUMPTION CITY!
                          We are assuming that the the state we are changing to is related to the first entry in the queued transition list. It always should be, but pretty much impossible to verify.
                          Remove the first entry as it is now processed (we hope)-->
                          <remove_value name="$QueuedTransitionRequests.{1}"/>
                        </do_if>
                      </do_if>
                      <signal_cue cue="$RequestedCue"/>
                      <do_if value="ChangeState.$ParamTable?">
                        <set_value name="$RequestedCue.$ParamTable" exact="ChangeState.$ParamTable"/>
                      </do_if>
                      <set_value name="$RequestedCue" exact="null"/>
                    </do_if>
                    <do_else>
                      <debug_text text="player.age + ' Aborting dispatch trigger for activating state cue ' + parent.$Cue + ' for ' + $NPC + ' ' + $NPC.knownname + ' - another state (' + $RequestedCue + ') was requested before the dispatch happened.'" chance="$DebugChance"/>
                    </do_else>

                    <reset_cue cue="Handle_ChangeState"/>
                    <remove_value name="$IsTransitionRelatedStateChange"/>
                    <!--This is to trigger Handle_ChangeState again-->
                    <do_if value="$RequestedCue.exists">
                      <signal_cue cue="ChangeState"/>
                    </do_if>
                    <do_elseif value="$QueuedTransition">
                      <signal_cue cue="RequestQueuedTransition"/>
                    </do_elseif>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="ChangeState_Dispatch_Transition">
              <conditions>
                <event_cue_completed cue="ChangeState_NPC_Ready"/>
                <check_value value="@parent.$QueuedTransition"/>
              </conditions>
              <actions>
                <do_if value="not $RequestedCue and parent.$QueuedTransition == $QueuedTransition">
                  <debug_text text="'Queued transition request for ' + $QueuedTransition + '. NPC : ' + $NPC + ' ' + $NPC.knownname" chance="$DebugChance"/>

                  <do_if value="$QueuedTransitionRequests.count">
                    <do_if value="$QueuedTransitionRequests.{1} == $QueuedTransition">
                      <set_value name="$QueuedTransition" exact="null"/>

                      <set_value name="$DispatchTransitionStateChange" exact="true"/>
                      <signal_objects object="$NPC" param="$QueuedTransitionRequests.{1}.{1}" param2="$QueuedTransitionRequests.{1}.{2}"/>
                      <remove_value name="$DispatchTransitionStateChange"/>
                      <do_if value="$RequestedCue">
                        <!--We don't remove the transition request here as we can't be sure if something else will jump in with a state request before it is processed-->
                      </do_if>
                      <do_else>
                        <debug_text text="'Transition request did not result in a state change request. Removing transition request and queueing the next one (if there is one).'" chance="$DebugChance"/>
                        <remove_value name="$QueuedTransitionRequests.{1}"/>
                        <do_if value="$QueuedTransitionRequests.{1}?">
                          <set_value name="$QueuedTransition" exact="$QueuedTransitionRequests.{1}"/>
                        </do_if>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'A queued state request for ' + parent.$QueuedTransition + ' was set to be processed but it did not match the first entry in the queue [Owen]'" filter="error"/>
                      <set_value name="$QueuedTransition" exact="null"/>
                      <do_if value="$QueuedTransitionRequests.count">
                        <signal_cue_instantly cue="QueuedStateChangeTrigger"/>
                      </do_if>
                    </do_else>
                  </do_if>
                  <do_else>
                    <debug_text text="'A queued state request for ' + parent.$QueuedTransition + ' was set to be processed but the queue itself is empty [Owen]'" filter="error"/>
                    <set_value name="$QueuedTransition" exact="null"/>
                  </do_else>
                </do_if>

                <reset_cue cue="Handle_ChangeState"/>
                <!--This is to trigger Handle_ChangeState again-->
                <do_if value="$RequestedCue.exists">
                  <signal_cue cue="ChangeState"/>
                </do_if>
                <do_elseif value="$QueuedTransition">
                  <signal_cue cue="RequestQueuedTransition"/>
                </do_elseif>
              </actions>
            </cue>
          </cues>
        </cue>

        <!--Queued state change requests will only fire when the state machine is in a phase where nothing else is requesting a regular state change
        Instanced so it can be signalled at any time, but the most recently instanced is the only one which can request the state change
        This cue is signalled when a state has been entered and is designed to perform the subcue actions if that activated state did not trigger a new state change, meaning the state machine is idle-->
        <cue name="QueuedStateChangeTrigger" instantiate="true">
          <conditions>
            <event_cue_signalled/>
          </conditions>
          <actions>
            <set_value name="static.$LatestInstance" exact="this"/>
          </actions>
          <cues>
            <cue name="QueuedStateChangeTrigger_Wait">
              <delay exact="1ms"/>
              <actions>
                <do_if value="parent.static.$LatestInstance == parent and $QueuedTransitionRequests.count">
                  <do_all chance="$DebugChance">
                    <debug_text text="player.age + ' Attempting to process the queue of transition requests for ' + $NPC.knownname + ' ' + $NPC"/>
                    <do_all exact="$QueuedTransitionRequests.count" counter="$i">
                      <debug_text text="$QueuedTransitionRequests.{$i}"/>
                    </do_all>
                  </do_all>
                  <signal_cue_instantly cue="RequestQueuedTransition" param="$QueuedTransitionRequests.{1}"/>
                </do_if>
                <do_else>
                  <cancel_cue cue="parent"/>
                </do_else>
              </actions>
            </cue>
          </cues>
        </cue>

        <library name="QueueTransitionRequest">
          <actions>
            <do_if value="$CanHaveTransition_Result?">
              <!--if $CanHaveTransition_Result exists it means that this request is just a test to see if this transition was possible. Set $CanHaveTransition_Result to true but don't actually queue-->
              <set_value name="$CanHaveTransition_Result" exact="true"/>
            </do_if>
            <do_else>
              <append_to_list name="$QueuedTransitionRequests" exact="[staticbase, [@event.param, @event.param2, @event.param3]]"/>
              <debug_text text="player.age + ' Queueing transition request ' + staticbase + ' with params : ' + @event.param + ' , ' + @event.param2 + ', ' + @event.param3 + ' - currently has ' + $QueuedTransitionRequests.count + ' requests'" chance="$DebugChance"/>
              <signal_cue_instantly cue="QueuedStateChangeTrigger"/>
            </do_else>
          </actions>
        </library>

        <cue name="ENTER_base">
          <actions>
            <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
          </actions>
        </cue>

        <!--base transitions-->
        <cue name="TRANSITION_reinit" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_state_reinit'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <!--debugging-->
        <cue name="Change_Debugging" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_set_debugging'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'npc_set_debugging '+ event.param2"/>
            <do_if value="event.param2">
              <set_value name="$DebugChance" exact="100"/>
            </do_if>
            <do_else>
              <set_value name="$DebugChance" exact="0"/>
            </do_else>
          </actions>
        </cue>
        
        <cue name="TRANSITION_move_to" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_move_to'" comment="event.param2 = table[
                           $slot = Target slot
                           OR
                           $context = Context component to walk to without a slot (requires $offset and $room),
                           AND
                           $room = Room component related to the floor position at $offset in $context space (NPC will be connected to this room at the end of the movement)
                           
                           $offset = Additional offset to $slot or $context (for which it is required),
                           $rotation = End rotation at the end position, relative to the $slot or $context (optional), 
                           $movementspeed = Movement speed (optional),
                           $destinationtags = List of floor tags at the destination position (optional)]"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_move_to"/>
              <!--TODO @Owen if slot, check if is free-->
              <set_value name="ChangeState.$ParamTable" exact="event.param2.{2}"/>
            </do_if>
            <do_else>
              <do_if value="typeof event.param2 == datatype.table and (@event.param2.$slot or @event.param2.$context)">
                <include_actions ref="QueueTransitionRequest"/>
              </do_if>
              <do_else>
                <debug_text text="'Invalid call. No valid table or slot/context provided. ' + event.param2" filter="error"/>
              </do_else>
            </do_else>
          </actions>
        </cue>

        <!--TODO @Owen refactor state machines to allow outside state change requests-->

        <!--TODO @Owen find out who's despawning temporary NPCs on dock areas-->
        <cue name="TRANSITION_despawn" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_despawn'" comment="event.param2 = table[$slot = Target slot (optional), $movementspeed = Movement speed (optional), $disconnect = bool (optional)]"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
              <set_value name="ChangeState.$ParamTable" exact="event.param2.{2}"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <cue name="TRANSITION_pickup_test" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_pickup_test'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_pickup"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <cue name="TRANSITION_vendomat_test" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_vendomat_test'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_vendomat"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <cue name="TRANSITION_airmarshal_test" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_airmarshal_test' and event.param2 == 'init'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <cue name="TRANSITION_welder_test" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc_welder_test' and event.param2 == 'init'"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <!-- set_value name="$DebugChance" exact="100"/ -->
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_welder"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <!--states-->
        <cue name="STATE_init">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_init">
              <actions>
                <debug_text text="player.age + ' *** Initializing state machine for NPC %1 type %2 role %3 controlpost %4'.[$NPC.name, $NPC.type, $NPC.role, $NPC.controlpost]" chance="$DebugChance" />

                <do_if value="not $NPC.object.isoperational">
                  <signal_cue_instantly cue="ChangeState" param="STATE_not_operational"/>
                </do_if>
                <!--TODO @Owen better init states-->
                <do_elseif value="@$NPC.$Stay">
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_elseif>
                <!--<do_elseif value="@$NPC.$DebugDockAreaMovement">
                  <signal_cue_instantly cue="ChangeState" param="STATE_dockarea_movement_test"/>
                </do_elseif>-->
                <do_elseif value="$NPC.controlpost == controlpost.aipilot">
                  <!--AI Pilot Control Entities (pilots/commanders)-->
                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot"/>
                </do_elseif>
                <do_elseif value="$NPC.controlpost == controlpost.manager">
                  <signal_cue_instantly cue="ChangeState" param="STATE_manager"/>
                </do_elseif>
                <do_elseif value="$NPC.controlpost == controlpost.shiptrader">
                  <signal_cue_instantly cue="ChangeState" param="STATE_shiptrader"/>
                </do_elseif>
                <do_elseif value="$NPC.type == entitytype.trader or $NPC.type == entitytype.shadyguy">
                  <signal_cue_instantly cue="ChangeState" param="STATE_trader"/>
                </do_elseif>
                <do_elseif value="$NPC.role == entityrole.service">
                  <do_if value="$NPC.$airmarshal_dockingbay?">
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal"/>
                  </do_if>
                  <do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_worker"/>
                  </do_else>
                </do_elseif>
                <do_elseif value="$NPC.role == entityrole.marine">
                  <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard"/>
                </do_elseif>
                <do_elseif value="$NPC.type == entitytype.officer">
                  <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                </do_elseif>
                <do_elseif value="$NPC.type == entitytype.factionrepresentative">
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_elseif>
                <do_elseif value="$NPC.role == entityrole.prisoner">
                  <signal_cue_instantly cue="ChangeState" param="STATE_prisoner" />
                </do_elseif>
                <do_elseif value="$NPC.ismissionactor">
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_elseif>
                <do_elseif value="$NPC.isavatar">
                  <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                </do_elseif>
                <do_else>
                  <assert value="false" text="'Unknown NPC state case: ' + $NPC + ' type: ' + $NPC.type + ' role: ' + $NPC.role + ' post ' + $NPC.controlpost + ' [Owen]'"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_init" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_not_operational">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
            <set_entity_traits entity="$NPC" hidden="true"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="EXIT_not_operational" ref="EXIT_Empty"/>

            <!--transitions-->
            <cue name="TRANSITION_not_operational_now_operational" instantiate="true">
              <conditions>
                <check_any>
                  <event_object_changed_state object="$NPC.object" state="componentstate.operational"/>
                  <event_object_signalled object="$NPC" param="staticbase"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <set_entity_traits entity="$NPC" hidden="false"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>

            <cue name="TRANSITION_not_operational_changed_room" instantiate="true">
              <conditions>
                <check_any>
                  <event_object_changed_room object="$NPC"/>
                  <event_object_signalled object="$NPC" param="staticbase"/>
                </check_any>
              </conditions>
              <actions>
                <!--reinitialise from new room-->
                <do_if value="@$DispatchTransitionStateChange">
                  <set_entity_traits entity="$NPC" hidden="false"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_move_to">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_move_to">
              <actions>
                <do_if value="STATE_move_to.$ParamTable?">
                  <set_value name="this.$destinationslot" exact="@STATE_move_to.$ParamTable.$slot"/>
                  <set_value name="this.$destinationcontext" exact="@STATE_move_to.$ParamTable.$context"/>
                  <set_value name="this.$destinationoffset" exact="@STATE_move_to.$ParamTable.$offset"/>
                  <set_value name="this.$destinationcontextroom" exact="@STATE_move_to.$ParamTable.$room"/>
                  <set_value name="this.$destinationrotation" exact="@STATE_move_to.$ParamTable.$rotation"/>
                  <set_value name="this.$destinationtags" exact="@STATE_move_to.$ParamTable.$destinationtags"/>

                  <do_if value="this.$destinationslot or (this.$destinationcontext and this.$destinationcontextroom)">
                    <include_actions ref="GetNextTargetPoint"/>
                    <do_if value="this.$pathtable">
                      <set_value name="$pathtable" exact="this.$pathtable"/>
                      <do_if value="$ParamTable.$movementspeed?">
                        <set_value name="$pathtable.$speed" exact="$ParamTable.$movementspeed"/>
                      </do_if>
                      <do_else>
                        <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                      </do_else>
                      <do_if value="this.$destinationslot and this.$destinationslot.tags.indexof.{tag.npc}">
                        <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                      </do_if>
                      <do_else>
                        <clear_actor_roomslot actor="$NPC"/>
                      </do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_move_to_moving"/>
                    </do_if>
                    <do_else>
                      <include_actions ref="MoveFailedHandling"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                    </do_else>
                  </do_if>
                </do_if>
                <do_else>
                  <debug_text text="player.age + ' ParamTable ' + @STATE_move_to.$ParamTable + ' Was not valid.'" filter="error"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_move_to" ref="EXIT_Empty"/>

            <!--Sub-states-->

            <cue name="STATE_move_to_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_move_to_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_move_to_moving_finished"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="EXIT_move_to_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_move_to_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_stay"/>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_despawn">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
            <!--TODO @Owen #HACK Have some time to allow nav helpers to generate in cases such as a NPC leaving a S sized ship where the doors and ladders are animating-->
            <set_value name="$FailTimeout" exact="player.age + 10s"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_despawn">
              <actions>
                <signal_cue_instantly cue="ChangeState" param="STATE_despawn_find"/>
              </actions>
            </cue>

            <cue name="EXIT_despawn" ref="EXIT_Empty"/>

            <!--Sub-states-->
            <cue name="STATE_despawn_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_despawn_find">
                  <actions>
                    <set_value name="STATE_despawn.$Disconnect" exact="@STATE_despawn.$ParamTable.$disconnect"/>
                    <set_value name="this.$fallbacktolocal" exact="false"/>
                    <do_if value="STATE_despawn.$ParamTable? and @STATE_despawn.$ParamTable.$slot">
                      <set_value name="this.$destinationslot" exact="STATE_despawn.$ParamTable.$slot"/>
                    </do_if>
                    <do_else>
                      <!--Find a despawn slot on the assigned object-->
                      <set_value name="this.$destinationslot" exact="null"/>
                      <do_if value="$NPC.controlpost">
                        <set_value name="this.$slotcontext" exact="$NPC.assignedcontrolled"/>
                      </do_if>
                      <do_elseif value="$NPC.role">
                        <set_value name="this.$slotcontext" exact="@$NPC.$role_object"/>
                      </do_elseif>
                      <do_else>
                        <set_value name="this.$slotcontext" exact="@$NPC.room"/>
                      </do_else>

                      <!--If there's no space between the NPCs current position and the $slotcontext, attempt to find a despawn point on the slotcontext first. Otherwise fallback to the NPCs current object.-->
                      <do_if value="this.$slotcontext and ($NPC.hascontext.{this.$slotcontext} or not @$NPC.commoncontext.{this.$slotcontext}.isclass.space)">
                        <do_if value="not $NPC.hascontext.{this.$slotcontext}">
                          <find_npc_waypoint name="this.$destinationslot" object="this.$slotcontext" tags="[tag.npctransport, tag.npc_location_exit]"/>
                        </do_if>
                        <do_if value="not this.$destinationslot">
                          <find_npc_waypoint name="this.$destinationslot" object="this.$slotcontext" tags="tag.npctransport"/>
                        </do_if>
                        <set_value name="this.$fallbacktolocal" exact="true"/>
                      </do_if>
                    </do_else>

                    <do_if value="not this.$destinationslot">
                      <include_actions ref="FindLocalDespawnLocation"/>
                    </do_if>

                    <do_if value="this.$destinationslot">
                      <include_actions ref="GetNextTargetPoint"/>
                      <do_if value="not this.$pathtable and this.$fallbacktolocal">
                        <!--If no path found to the best despawn slot. Try a local despawn slot.-->
                        <debug_text text="'Unable to find path to despawn on destination object. Attempting on current local object.'" chance="$DebugChance"/>
                        <include_actions ref="FindLocalDespawnLocation"/>
                        <do_if value="this.$destinationslot">
                          <include_actions ref="GetNextTargetPoint"/>
                        </do_if>
                      </do_if>

                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="STATE_despawn.$ParamTable? and @STATE_despawn.$ParamTable.$movementspeed">
                          <set_value name="$pathtable.$speed" exact="STATE_despawn.$ParamTable.$movementspeed"/>
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <do_if value="this.$destinationslot.tags.indexof.{tag.npc}">
                          <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                        </do_if>
                        <do_else>
                          <clear_actor_roomslot actor="$NPC"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_despawn_moving"/>
                      </do_if>
                      <do_elseif value="player.age lt $FailTimeout">
                        <debug_text text="'Unable to find path to despawn location. Attempts will continue for another ' + ($FailTimeout - player.age)" chance="$DebugChance"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_despawn_wait"/>
                      </do_elseif>
                      <do_else>
                        <include_actions ref="MoveFailedHandling"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_despawn_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="player.age + ' Unable to find room slot with tag ' + tag.npctransport + ' - NPC will disappear instantly.'" filter="error"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_despawn_finished"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_despawn_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_despawn_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_despawn_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_despawn_moving_finished"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="EXIT_despawn_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_despawn_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_despawn_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_despawn_wait">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_despawn_wait">
                  <delay exact="1s"/>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_despawn_find"/>
                  </actions>
                </cue>

                <cue name="EXIT_despawn_wait" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_despawn_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_despawn_finished" checkinterval="1ms">
                  <conditions>
                    <!--Only kill NPC if there are no queued requests-->
                    <check_value value="$QueuedTransitionRequests.count == 0 and not $RequestedCue"/>
                  </conditions>
                  <actions>
                    <do_if value="@STATE_despawn.$Disconnect">
                      <debug_text text="'Despawn finished ' + $NPC + ' ' + $NPC.knownname + ' disconnecting NPC.'" chance="$DebugChance"/>
                      <remove_actor_from_room actor="$NPC"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'Despawn finished ' + $NPC + ' ' + $NPC.knownname + ' destroying NPC.'" chance="$DebugChance"/>
                      <destroy_object object="$NPC"/>
                    </do_else>
                    <cancel_cue cue="Base"/>
                  </actions>
                </cue>

                <cue name="EXIT_despawn_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_idle">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_idle">
              <actions>
                <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay"/>
              </actions>
            </cue>

            <cue name="EXIT_idle">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <do_if value="$staytime?">
                  <remove_value name="$staytime"/>
                </do_if>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_idle_stay">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_idle_stay">
                  <actions>
                    <do_if value="$NPC.attention lt attention.nearby">
                      <!--distant case-->
                      <set_value name="$staytime" min="5min" max="6min"/>
                    </do_if>
                    <do_else>
                      <!--near case-->
                      <do_if value="$staytime?">
                        <set_value name="$staytime" min="10s" max="20s"/>
                      </do_if>
                      <do_else>
                        <set_value name="$staytime" min="2s" max="6s"/>
                      </do_else>
                    </do_else>
                  </actions>
                  <cues>
                    <cue name="ENTER_idle_stay_interrupt">
                      <delay exact="$staytime"/>
                      <actions>
                        <signal_objects object="$NPC" param="'idle_stay__end'"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="EXIT_idle_stay" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_idle_attempt_move">
                  <conditions>
                    <check_any>
                      <check_all>
                        <!--NPC moved into nearby attention-->
                        <event_object_changed_attention object="$NPC"/>
                        <check_value value="event.param2 lt attention.nearby and event.param ge attention.nearby"/>
                      </check_all>
                      <check_all>
                        <!--NPC was signalled to attempt to move-->
                        <event_object_signalled object="$NPC" param="'idle_stay__end'"/>
                        <check_value value="$NPC.attention ge attention.nearby"/>
                      </check_all>
                    </check_any>
                  </conditions>
                  <delay min="0s" max="if event.name == 'event_object_changed_attention' then 10s else 1s"/>
                  <actions>
                    <include_actions ref="Validate_Usecase_Reservation"/>
                    <do_if value="@$UsecaseCue.exists">
                      <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay" />
                    </do_if>
                    <do_else>
                      <do_if value="$NPC.walkablemodule" chance="25">
                        <find_npc_slot name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.npc_generic"/>
                      </do_if>
                      <do_else>
                        <find_npc_slot name="this.$destinationslot" object="$NPC.container" tags="tag.npc_generic"/>
                      </do_else>
                      <do_if value="this.$destinationslot">
                        <include_actions ref="GetNextTargetPoint"/>
                        <do_if value="this.$pathtable">
                          <set_value name="$pathtable" exact="this.$pathtable"/>
                          <do_if value="this.$destinationslot.tags.indexof.{tag.stand_terminal}">
                            <do_if value="$NPC.room.parent.isclass.walkablemodule">
                              <set_value name="$pathtable.$speed" exact="$NPC.runspeed"/>
                            </do_if>
                            <do_else>
                              <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                            </do_else>
                          </do_if>
                          <do_else>
                            <set_value name="$pathtable.$speed" exact="[$NPC.slowwalkspeed, $NPC.walkspeed].random"/>
                          </do_else>
                          <do_if value="this.$destinationslot.tags.indexof.{tag.npc}">
                            <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                          </do_if>
                          <do_else>
                            <clear_actor_roomslot actor="$NPC"/>
                          </do_else>
                          <signal_cue_instantly cue="ChangeState" param="STATE_idle_moving"/>
                        </do_if>
                        <do_else>
                          <include_actions ref="MoveFailedHandling"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay"/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay"/>
                      </do_else>

                    </do_else>
                    <!--Standard tranition exit handling-->
                    <include_actions ref="Transition_Exit"/>
                  </actions>
                </cue>

                <cue name="TRANSITION_idle_distant">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'idle_stay__end'"/>
                    <check_value value="$NPC.attention lt attention.nearby"/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle_stay"/>

                    <!--Standard tranition exit handling-->
                    <include_actions ref="Transition_Exit"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_idle_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_idle_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_idle_moving_finished"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="EXIT_idle_moving_finished" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_idle_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle_move_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_idle_move_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_idle_move_finished">
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                  </actions>
                </cue>

                <cue name="EXIT_idle_move_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="TRANSITION_control_dismissed" instantiate="true">
          <conditions>
            <event_object_signalled object="$NPC"/>
            <check_any>
              <check_value value="event.param == 'npc__control_dismissed'" comment="event.param2 = replacement NPC actor or npctemplate (optional), event.param3 = controllable for event.param2 if npctemplate"/>
              <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
            </check_any>
          </conditions>
          <actions>
            <do_if value="@$DispatchTransitionStateChange">
              <signal_cue_instantly cue="ChangeState" param="STATE_control_dismissed"/>
              <set_value name="ChangeState.$ParamTable" exact="table[$replacement = event.param2.{2}, $replacementroleobject = event.param2.{3}]"/>
            </do_if>
            <do_else>
              <include_actions ref="QueueTransitionRequest"/>
            </do_else>
          </actions>
        </cue>

        <cue name="STATE_control_dismissed">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_STATE_control_dismissed">
              <actions>
                <set_value name="this.$Controlled" exact="$NPC.assignedcontrolled"/>
                <do_if value="this.$Controlled">
                  <debug_text text="'Preparing to dismiss NPC ' + $NPC.knownname + ' ' + $NPC + ' from ' + this.$Controlled.knownname + ' ' + this.$Controlled + ' params: ' + STATE_control_dismissed.$ParamTable" chance="$DebugChance"/>
                  <set_value name="this.$assignment" exact="$NPC.controlpost"/>
                  <!--Fallback role for the dismissed NPC to take so they are not lost. Can be overwritten by the replacement NPCs old role-->
                  <set_value name="this.$FallbackRole" exact="null"/>
                  <set_value name="this.$ReplacementNPC" exact="null"/>
                  <set_value name="this.$ReplacementTemplate" exact="null"/>
                  <set_value name="this.$ReplacementRoleObject" exact="null"/>
                  <set_value name="this.$FoundExistingNPC" exact="false"/>

                  <do_if value="@STATE_control_dismissed.$ParamTable.$replacement">
                    <do_if value="typeof STATE_control_dismissed.$ParamTable.$replacement == datatype.npctemplate">
                      <set_value name="this.$ReplacementTemplate" exact="STATE_control_dismissed.$ParamTable.$replacement"/>
                      <set_value name="this.$ReplacementRoleObject" exact="STATE_control_dismissed.$ParamTable.$replacementroleobject"/>
                      <debug_text text="'Replacement NPC is the NPC template ' + this.$ReplacementTemplate + ' on ' + this.$ReplacementRoleObject" chance="$DebugChance"/>
                      <assert value="this.$ReplacementRoleObject.exists" text="'Invalid role object: ' + this.$ReplacementRoleObject + ' - [Owen]'"/>
                      <do_if value="this.$ReplacementRoleObject.people.{this.$ReplacementTemplate}.exists">
                        <!--Set the fallback role to the current role of the replacement (note, this $NPC prefer to stay on their current object instead of move to the $ReplacementRoleObject)-->
                        <!--TODO @Owen - better logbook messages of where who went and what they changed to-->
                        <set_value name="this.$FallbackRole" exact="this.$ReplacementRoleObject.people.{this.$ReplacementTemplate}.role"/>
                        <assert value="this.$FallbackRole" text="'Replacing NPC ' + $NPC + ' ' + $NPC.knownname + ' with person ' + this.$ReplacementTemplate + ' but they do not have a role. Defaulting to service [Owen]'"/>
                        <do_if value="not this.$FallbackRole">
                          <set_value name="this.$FallbackRole" exact="entityrole.service"/>
                        </do_if>
                        <debug_text text="'Attempting to find replacement NPC with template ' + this.$ReplacementTemplate" chance="$DebugChance"/>
                        <!--TODO @Owen this is not great. What if the NPC is instanced but not on their own role object?-->
                        <find_object_component name="this.$ReplacementNPC" object="this.$ReplacementRoleObject" npctemplate="this.$ReplacementTemplate"/>
                        <set_value name="this.$FoundExistingNPC" exact="this.$ReplacementNPC.exists"/>
                        <do_if value="not this.$FoundExistingNPC">
                          <!--We will attempt to create the replacement actor from the this.$ReplacementTemplate and this.$ReplacementRoleObject-->
                          <find_npc_waypoint name="this.$SpawnSlot" object="this.$ReplacementRoleObject.controlroom" tags="tag.npctransport"/>
                          <do_if value="not this.$SpawnSlot">
                            <find_npc_waypoint name="this.$SpawnSlot" object="this.$ReplacementRoleObject" tags="tag.npctransport"/>
                          </do_if>
                          <do_if value="not this.$SpawnSlot">
                            <debug_text text="'Unable to find a spawn slot for the replacement actor on their old role object ' + this.$ReplacementRoleObject + ' ' + this.$ReplacementRoleObject.knownname + ' - trying on their destination object ' + this.$Controlled + ' ' + this.$Controlled.knownname" filter="error"/>
                            <find_npc_waypoint name="this.$SpawnSlot" object="this.$Controlled" tags="tag.npctransport"/>
                          </do_if>
                          <do_if value="this.$SpawnSlot">
                            <create_npc_from_template name="this.$ReplacementNPC" object="this.$ReplacementRoleObject" template="this.$ReplacementTemplate" slot="this.$SpawnSlot" owner="this.$Controlled.owner"/>
                            <debug_text text="'Attempt to instantiate replacement control entity: ' + this.$ReplacementNPC + ' at ' + this.$SpawnSlot" chance="$DebugChance"/>
                          </do_if>
                          <do_else>
                            <create_npc_from_template name="this.$ReplacementNPC" object="this.$ReplacementRoleObject" template="this.$ReplacementTemplate" owner="this.$Controlled.owner" required="true"/>
                            <debug_text text="'Attempt to instantiate replacement control entity: ' + this.$ReplacementNPC + ' on any free slot on: ' + this.$ReplacementRoleObject + ' ' + this.$ReplacementRoleObject.knownname" chance="$DebugChance"/>
                          </do_else>

                          <!--Check if the replacement was instanced correctly. They could either be on their old role object or the destination if there were no suitable slots-->
                          <do_if value="this.$ReplacementNPC.exists">
                            <set_entity_traits entity="this.$ReplacementNPC" hidden="true"/>
                            <debug_text text="'Created instance of template ' + this.$ReplacementTemplate + ' - ' + this.$ReplacementNPC + ' at ' + this.$SpawnSlot"/>
                          </do_if>
                          <do_else>
                            <destroy_object object="this.$ReplacementNPC"/>
                            <set_value name="this.$ReplacementNPC" exact="null"/>
                          </do_else>
                        </do_if>
                      </do_if>
                      <do_else>
                        <debug_text text="'NPC template ' + this.$ReplacementTemplate + ' does not exist on object ' + this.$ReplacementRoleObject" chance="$DebugChance"/>
                      </do_else>
                    </do_if>
                    <do_elseif value="STATE_control_dismissed.$ParamTable.$replacement.isclass.npc">
                      <set_value name="this.$ReplacementNPC" exact="STATE_control_dismissed.$ParamTable.$replacement"/>
                      <set_value name="this.$FoundExistingNPC" exact="true"/>
                      <debug_text text="'Replacement NPC is the existing NPC ' + this.$ReplacementNPC + ' ' + this.$ReplacementNPC.knownname" chance="$DebugChance"/>
                    </do_elseif>
                    <do_else>
                      <assert value="typeof STATE_control_dismissed.$ParamTable.$replacement == datatype.npctemplate or STATE_control_dismissed.$ParamTable.$replacement.isclass.npc"
                              text="'Provided replacement for ' + $NPC + ' ' + $NPC.knownname + ' is neither a NPC nor a NPC Template. $replacement: ' + $replacement + ' - [Owen]'"/>
                    </do_else>
                  </do_if>
                  <!--Remove ReplacementNPC from their old role object-->
                  <do_if value="this.$ReplacementTemplate and this.$ReplacementRoleObject">
                    <debug_text text="'Successfully instanced or found an instance of a temporary NPC. Remove as a role NPC of its old role object. Instance: ' + @this.$ReplacementNPC + ' Template: ' + this.$ReplacementTemplate + ' Old role object: ' + this.$ReplacementRoleObject + ' ' + this.$ReplacementRoleObject.knownname" chance="$DebugChance"/>
                    <remove_npc_template object="this.$ReplacementRoleObject" template="this.$ReplacementTemplate"/>
                    <do_if value="this.$ReplacementNPC">
                      <clear_entity_role entity="this.$ReplacementNPC"/>
                    </do_if>
                  </do_if>
                  <do_if value="this.$ReplacementNPC and this.$ReplacementNPC.assignedcontrolled">
                    <debug_text text="'Dismissing the replacement NPC ' + this.$ReplacementNPC + ' ' + this.$ReplacementNPC.knownname + ' from their old object ' + this.$ReplacementNPC.assignedcontrolled + ' ' + this.$ReplacementNPC.assignedcontrolled.knownname" chance="$DebugChance"/>
                    <dismiss_control_entity actor="this.$ReplacementNPC" object="this.$ReplacementNPC.assignedcontrolled"/>
                  </do_if>
                  <!--Remove $NPC from their control post and reassign them a role if possible-->
                  <dismiss_control_entity actor="$NPC" object="this.$Controlled"/>
                  <do_if value="this.$FallbackRole">
                    <do_if value="this.$Controlled.people.free gt 0">
                      <create_npc_template object="this.$Controlled" entity="$NPC" role="this.$FallbackRole"/>
                      <debug_text text="'Dismissed NPC ' + $NPC + ' ' + $NPC.knownname + ' is now assigned to their old object: ' + this.$Controlled + ' ' + this.$Controlled.knownname + ' as ' + this.$FallbackRole" chance="$DebugChance"/>
                    </do_if>
                    <do_elseif value="this.$ReplacementRoleObject and this.$ReplacementRoleObject.people.free gt 0">
                      <create_npc_template object="this.$ReplacementRoleObject" entity="$NPC" role="this.$FallbackRole"/>
                      <debug_text text="'Dismissed NPC ' + $NPC + ' ' + $NPC.knownname + ' is now assigned to the old object of their replacement: ' + this.$ReplacementRoleObject + ' ' + this.$ReplacementRoleObject.knownname + ' as ' + this.$FallbackRole" chance="$DebugChance"/>
                    </do_elseif>
                    <do_else>
                      <assert value="false" text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' was dismissed but has no where to go. [Owen]'"/>
                    </do_else>
                    <set_entity_traits entity="$NPC" temporary="true"/>
                    <set_entity_role entity="$NPC" role="this.$FallbackRole"/>
                  </do_if>

                  <!--Set the replacement NPC to the old control post of $NPC-->
                  <do_if value="this.$ReplacementNPC">
                    <assign_control_entity actor="this.$ReplacementNPC" object="this.$Controlled" post="this.$assignment" init="false"/>
                    <do_if value="this.$assignment == controlpost.shiptrader">
                      <signal_cue_instantly cue="md.NPC_Shiptrader.Base" param="this.$ReplacementNPC"/>
                    </do_if>

                    <!--Transfer inventory wares from $NPC to the replacement NPC.-->
                    <set_value name="this.$NPCInventory" exact="$NPC.inventory.list"/>
                    <do_all exact="this.$NPCInventory.count" counter="$i">
                      <set_value name="this.$InventoryAmount" exact="$NPC.inventory.{this.$NPCInventory.{$i}}.count"/>
                      <debug_text text="'Transfering ' + this.$InventoryAmount + ' of inventory ware: ' + this.$NPCInventory.{$i} + ' from ' + $NPC + ' ' + $NPC.knownname + ' to ' + this.$ReplacementNPC + ' ' + this.$ReplacementNPC.knownname" chance="$DebugChance"/>
                      <add_inventory entity="this.$ReplacementNPC" ware="this.$NPCInventory.{$i}" exact="this.$InventoryAmount"/>
                      <remove_inventory entity="$NPC" ware="this.$NPCInventory.{$i}" exact="this.$InventoryAmount"/>
                    </do_all>

                    <debug_text text="this.$assignment.name + ' is now ' + this.$ReplacementNPC + ' ' + this.$ReplacementNPC.knownname" chance="$DebugChance"/>
                    <do_if value="this.$FoundExistingNPC">
                      <signal_objects object="this.$ReplacementNPC" param="'npc_state_reinit'"/>
                      <remove_value name="this.$ReplacementNPC.$role_object"/>
                    </do_if>
                  </do_if>
                  <do_if value="this.$FallbackRole">
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </do_if>
                  <do_else>
                    <set_owner object="$NPC" faction="faction.civilian"/>
                    <set_value name="$DespawnSlot" exact="null"/>
                    <do_if value="this.$Controlled.object">
                      <find_npc_waypoint name="$DespawnSlot" object="this.$Controlled.object" tags="tag.npctransport"/>
                    </do_if>
                    <do_if value="$DespawnSlot">
                      <signal_objects object="$NPC" param="'npc_despawn'" param2="table[$slot = $DespawnSlot]"/>
                    </do_if>
                    <do_else>
                      <signal_objects object="$NPC" param="'npc_despawn'"/>
                    </do_else>
                  </do_else>
                </do_if>
                <do_else>
                  <debug_text text="'Dismissing role NPC ' + $NPC + ' ' + $NPC.knownname + ' - Clearing role and owner'" chance="$DebugChance"/>
                  <set_value name="$roleobject" exact="@$NPC.$role_object"/>
                  <do_if value="$roleobject">
                    <remove_npc_template object="$roleobject" template="$NPC.npctemplate"/>
                    <remove_value name="$NPC.$role_object"/>
                  </do_if>
                  <clear_entity_role entity="$NPC"/>
                  <set_owner object="$NPC" faction="faction.civilian"/>
                  <set_value name="$DespawnSlot" exact="null"/>
                  <do_if value="$roleobject.object">
                    <find_npc_waypoint name="$DespawnSlot" object="$roleobject.object" tags="tag.npctransport"/>
                  </do_if>
                  <do_if value="$DespawnSlot">
                    <signal_objects object="$NPC" param="'npc_despawn'" param2="table[$slot = $DespawnSlot]"/>
                  </do_if>
                  <do_else>
                    <signal_objects object="$NPC" param="'npc_despawn'"/>
                  </do_else>
                </do_else>
                <raise_lua_event name="'info_updatePeople'"/>
              </actions>
            </cue>
            <cue name="EXIT_ai_pilot_control_dismissed" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_ai_pilot">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_ai_pilot">
              <actions>
                <set_value name="$NPCSlot" exact="null" comment="This is a valid scenario - it later tells the state machine that it is free to choose a valid slot at random" />
                <set_value name="$NPCSpeed" exact="null" comment="This is a valid scenario - it later tells the state machine that it is free to choose a speed at random" />

                <do_if value="$NPC.controlled">
                  <!--NPC is already controlling-->
                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post" />
                </do_if>
                <do_else>
                  <set_value name="this.$AssignedControlled" exact="$NPC.assignedcontrolled"/>
                  <do_if value="this.$AssignedControlled and this.$AssignedControlled.assignedcontrolentity.{controlpost.aipilot} == $NPC">
                    <do_if value="$NPC.isbusy">
                      <do_if value="$NPC.ishidden">
                        <!--NPC is hidden and busy-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_busy" />
                      </do_if>
                      <do_else>
                        <!--Have them vacate the pilot position-->
                        <!--TODO @Owen - improve busy pilot behaviour. They could simply move to a vacant slot in the room instead of despawning.-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post" />
                      </do_else>
                    </do_if>
                    <!--$ship.pilot is either the assigned AI pilot or the currently controlling player-->
                    <do_elseif value="this.$AssignedControlled.assignedpilot == $NPC">
                      <!--NPC is the assigned pilot but not currently in control-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_return_to_post" />
                    </do_elseif>
                  </do_if>
                  <do_else>
                    <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' is no longer a pilot. Re-init.'" chance="$DebugChance"/>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                  </do_else>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_ai_pilot">
              <conditions>
                <event_cue_signalled cue="parent" />
                <check_value value="@event.param == 'exit'" />
              </conditions>
              <actions>
                <remove_value name="$NPCSlot" />
              </actions>
            </cue>

            <!--Transitions-->
            <cue name="TRANSITION_ai_pilot_leave_post" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'npc__leave_post'"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post"/>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>

            <cue name="TRANSITION_ai_pilot_return_to_post" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'npc__return_to_post'"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_return_to_post"/>
                </do_if>
                <do_else>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>

            <!--Sub-states-->

            <cue name="STATE_ai_pilot_busy">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="EXIT_ai_pilot_busy" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_ai_pilot_move_to_post">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit actions -->
                <cue name="ENTER_ai_pilot_move_to_post">
                  <actions>
                    <do_if value="$NPC.controlpost != controlpost.aipilot">
                      <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                    </do_if>
                    <do_if value="$NPC.controlled">
                      <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already controlling ' + $NPC.controlled + ' ' + $NPC.controlled.knownname + ' - No need to move.'" chance="$DebugChance" />
                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post" />
                    </do_if>
                    <do_elseif value="$NPC.assignedcontrolled">
                      <set_value name="$Assigned" exact="$NPC.assignedcontrolled" />

                      <do_if value="$Assigned.pilot and $Assigned.pilot != $NPC">
                        <do_if value="$Assigned.pilot == player.entity">
                          <!--Player is currently piloting this object.-->
                          <debug_text text="'Player is currently piloting ' + $Assigned + ' ' + $Assigned.knownname + ' have the pilot go to standby.'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post" />
                        </do_if>
                        <do_else>
                          <assert value="$Assigned.pilot == player.entity or $Assigned.pilot == $NPC" text="'Current pilot of ship ' + $Assigned + ' ' + $Assigned.knownname + ' is ' + $Assigned.pilot + ' ' + $Assigned.pilot.knownname + ' - Not this NPC ' + $NPC + ' [Owen]'"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_else>
                      </do_if>
                      <do_else>
                        <!--Have the pilot move to the pilot slot-->
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is pilot of ' + $Assigned.knownname + ' ({' + $Assigned + '}) - safe to continue'" chance="$DebugChance" />
                        <find_npc_slot name="this.$destinationslot" object="$Assigned" post="controlpost.aipilot"/>

                        <set_value name="this.$AwaitingBusySlot" exact="false"/>
                        <do_if value="not this.$destinationslot">
                          <!--Check if the filled slot is simply not just blocked by this NPC-->
                          <find_npc_slot name="this.$potentialdestinationslot" object="$Assigned" post="controlpost.aipilot" excludefilled="false"/>
                          <do_if value="this.$potentialdestinationslot">
                            <do_if value="this.$potentialdestinationslot == $NPC.roomslot">
                              <set_value name="this.$destinationslot" exact="this.$potentialdestinationslot"/>
                            </do_if>
                            <do_else>
                              <debug_text text="'The pilot room slot is currently engaged by another entity: ' + $Assigned.controlposition.{this.$potentialdestinationslot.controlposition}.entity + ' they must either leave in the next frame or begin getting out of the chair.'" chance="$DebugChance"/>
                              <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_await_moving_to_post" />
                              <set_value name="this.$AwaitingBusySlot" exact="true"/>
                            </do_else>
                          </do_if>
                        </do_if>

                        <assert value="this.$destinationslot or this.$AwaitingBusySlot" text="'No pilot slot found on ' + $Assigned + ' ' + $Assigned.knownname + ' [Owen]'"/>

                        <do_if value="this.$destinationslot">
                          <set_entity_traits entity="$NPC" busy="false" intransit="true" />
                          <!-- hidden="false" -->
                          <include_actions ref="GetNextTargetPoint" />
                          <do_if value="this.$pathtable">
                            <set_value name="$pathtable" exact="this.$pathtable" />
                            <!-- If a speed was passed into the state machine, use it -->
                            <do_if value="$NPCSpeed">
                              <set_value name="$pathtable.$speed" exact="$NPCSpeed" />
                            </do_if>
                            <!-- Else, select one at random -->
                            <do_else>
                              <do_if value="$NPC.room.parent.isclass.walkablemodule">
                                <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                              </do_if>
                              <do_else>
                                <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                              </do_else>
                            </do_else>
                            <do_if value="this.$destinationslot.tags.indexof.{tag.npc}">
                              <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot" />
                            </do_if>
                            <do_else>
                              <clear_actor_roomslot actor="$NPC" />
                            </do_else>
                            <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_moving_to_post" />
                          </do_if>
                          <do_else>
                            <include_actions ref="MoveFailedHandling"/>
                            <debug_text text="'MoveFailedHandling triggered'" chance="$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post_finished" />
                          </do_else>
                        </do_if>
                        <do_elseif value="not this.$AwaitingBusySlot">
                          <!--No pilot slot found-->
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post" />
                        </do_elseif>
                      </do_else>
                    </do_elseif>
                    <do_else>
                      <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) had no assigned ship to pilot. Reinitialise'" filter="error" />
                      <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_move_to_post" ref="EXIT_Empty" />

                <!-- Sub-states -->

                <cue name="STATE_ai_pilot_await_moving_to_post">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_ai_pilot_await_moving_to_post">
                      <actions>
                        <set_value name="STATE_ai_pilot_await_moving_to_post.$Controllable" exact="$NPC.assignedcontrolled"/>
                        <do_if value="@STATE_ai_pilot_await_moving_to_post.$Controllable.assignedcontrolled.{controlpost.aipilot} == $NPC">
                          <find_npc_slot name="STATE_ai_pilot_await_moving_to_post.$Slot" object="STATE_ai_pilot_await_moving_to_post.$Controllable" post="controlpost.aipilot" excludefilled="false"/>
                          <assert value="STATE_ai_pilot_await_moving_to_post.$Slot" text="'Unable to find pilot slot [Owen]'"/>
                          <do_if value="STATE_ai_pilot_await_moving_to_post.$Slot">
                            <do_if value="STATE_ai_pilot_await_moving_to_post.$Controllable.ischairslot.{STATE_ai_pilot_await_moving_to_post.$Slot}">
                              <set_value name="this.$ChairEntity" exact="STATE_ai_pilot_await_moving_to_post.$Controllable.controlposition.{STATE_ai_pilot_await_moving_to_post.$Slot}.entity"/>
                              <do_if value="this.$ChairEntity">
                                <do_if value="this.$ChairEntity == $NPC">
                                  <assert value="this.$ChairEntity != $NPC" text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' is in a state waiting for someone to get out of the pilot chair, where that person is themelves. Reinitialising. [Owen]'"/>
                                  <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                                </do_if>
                                <!--else, allow the transition below to handle waiting for the chair to be free-->
                              </do_if>
                              <do_else>
                                <!--No NPC in the chair. Move towards it right away.-->
                                <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post" />
                              </do_else>
                            </do_if>
                            <do_else>
                              <!--Pilot slot is not a chair slot. Move towards it right away.-->
                              <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post" />
                            </do_else>
                          </do_if>
                          <do_else>
                            <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'$NPC ' + $NPC.knownname + ' ' + $NPC + ' is not assigned as a pilot. Reinitialise'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_ai_pilot_await_moving_to_post" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_ai_pilot_await_moving_to_post_finish" checkinterval="1ms">
                      <conditions>
                        <check_any>
                          <!--Check if the chair has been vacated-->
                          <check_value value="STATE_ai_pilot_await_moving_to_post.$Slot? and not STATE_ai_pilot_await_moving_to_post.$Controllable.controlposition.{STATE_ai_pilot_await_moving_to_post.$Slot}.entity" />
                          <check_all>
                            <!--Timeout if the chair entity has not left in a suitable amount of time-->
                            <check_value value="STATE_ai_pilot_await_moving_to_post.time + 10s lt player.age"/>
                            <debug_text text="'NPC ' + STATE_ai_pilot_await_moving_to_post.$Controllable.controlposition.{STATE_ai_pilot_await_moving_to_post.$Slot}.entity  + 
                                        ' took too long to leave the chair which ' + $NPC + ' ' + $NPC.knownname + ' is moving to.'" filter="error"/>
                          </check_all>
                        </check_any>
                      </conditions>
                      <actions>
                        <debug_text text="'NPC ' + $NPC.knownname + ' ' + $NPC + ' is now set to move to the chair.'" chance="$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_ai_pilot_moving_to_post">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_ai_pilot_moving_to_post" ref="PerformPath">
                      <param name="NPC" value="$NPC" />
                      <param name="pathtable" value="$pathtable" />
                      <param name="signalcue" value="TRANSITION_ai_pilot_moving_to_post_finished" />
                      <param name="DebugChance" value="$DebugChance" />
                    </cue>

                    <cue name="EXIT_ai_pilot_moving_to_post" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_ai_pilot_moving_to_post_finished">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <debug_text text="'PerformPath (pilot_moving_to_post) finished'" chance="$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post_finished" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_ai_pilot_move_to_post_finished">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <cue name="ENTER_ai_pilot_move_to_post_finished">
                      <actions>
                        <set_entity_traits entity="$NPC" busy="false" intransit="false" hidden="false"/>
                        <initialise_control_entity actor="$NPC"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post" />
                      </actions>
                    </cue>

                    <cue name="EXIT_ai_pilot_move_to_post_finished" ref="EXIT_Empty" />
                  </cues>
                </cue>
              </cues>
            </cue>

            <!--TODO @Owen - Rename?
            STATE_ai_pilot_working may be a better name. The pilot is the current active pilot of the ship and should move to the control post. (TODO Potential to wander around however in special cases.)-->
            <cue name="STATE_ai_pilot_at_post">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_ai_pilot_at_post">
                  <actions>
                    <do_if value="$NPC.controlled">
                      <do_if value="$NPC.controlled.istemptraffic or not $NPC.roomslot">
                        <!--Optimisation - Pilot is not in an object with a positioned pilot slot, so we put them in a very basic state.-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_invisible" />
                      </do_if>
                      <do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post_default" />
                      </do_else>
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_at_post" ref="EXIT_Empty"/>

                <!-- Sub-states -->
                <cue name="STATE_ai_pilot_invisible">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="EXIT_ai_pilot_invisible" ref="EXIT_Empty" />
                  </cues>
                </cue>

                <cue name="STATE_ai_pilot_at_post_default">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!--Allow usecases
                    If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                    Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                    <cue name="USECASE_CHECK_ai_pilot_at_post_default" instantiate="true">
                      <conditions>
                        <event_cue_signalled cue="parent"/>
                        <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                      </conditions>
                      <actions>
                        <include_actions ref="Allow_Usecase"/>
                      </actions>
                    </cue>

                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_ai_pilot_at_post_default">
                      <actions>
                        <debug_text text="'NPC ' + $NPC + ' ' + $NPC.knownname + ' ' + $NPC.attention + ' ENTER_ai_pilot_at_post_default'" chance="$DebugChance"/>
                        <do_if value="$NPC.controlled and ($NPC.controlled.istemptraffic or not $NPC.roomslot)">
                          <!--Pilot is not in an object with a positioned pilot slot, so we put them in a very basic state.-->
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_invisible" />
                        </do_if>
                        <do_else>
                          <do_if value="$NPC.attention ge attention.nearby" comment="TODO (@Lorraine): Make sure to remove this race check when new piloting animations become available">
                            <!-- If the ship is currently docked, pilot / commander is allowed to idle -->
                            <debug_text text="'Checking whether ship is docked: ' + $NPC.knownname + ' ({' + $NPC + '})'" chance="$DebugChance" />
                            <do_if value="$NPC.controlled.parent.isclass.{class.dockingbay} and $NPC.controlled.parent.dockstate == dockstate.default">
                              <debug_text text="'Ship is docked - NPC can idle'" chance="$DebugChance" />
                              <set_value name="$AnimationType" exact="'idle'" />
                            </do_if>
                            <do_else>
                              <debug_text text="'Ship is not docked - NPC must look busy'" chance="$DebugChance" />
                              <set_value name="$AnimationType" exact="'busy'" />
                              <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate" />
                            </do_else>
                            <debug_text text="'$AnimationType set to ' + $AnimationType" chance="$DebugChance" />

                            <!-- TODO (@Lorraine): remove behaviour check here when a) all ships use sit_pilot / stand_terminal_forward and b) piloting animations and sequences exist (means they can just use default 'busy') -->
                            <set_value name="$Behaviour" exact="null" />
                            <set_value name="$CurrentSlot" exact="$NPC.roomslot" />
                            <set_value name="$CurrentSlotTags" exact="$CurrentSlot.tags" />

                            <do_all exact="$CurrentSlotTags.count" counter="$TagCounter">
                              <set_value name="$Tag" exact="$CurrentSlotTags.{$TagCounter}" />
                              <do_if value="$Tag" exact="tag.sit_pilot">
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '})' + ' is sitting to pilot'" chance="$DebugChance" />
                                <set_value name="$Behaviour" exact="'sit_pilot'" />
                                <break />
                              </do_if>
                              <do_elseif value="$Tag" exact="tag.stand_terminal_forward">
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '})' + ' is standing to pilot'" chance="$DebugChance" />
                                <set_value name="$Behaviour" exact="'stand_terminal_captain'" />
                                <break />
                              </do_elseif>
                            </do_all>

                            <do_if value="not $Behaviour">
                              <do_if value="$CurrentSlot.component.ischairslot.{$CurrentSlot}">
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '})' + ' is sitting down'" chance="$DebugChance" />
                                <set_value name="$Behaviour" exact="'sit'" />
                              </do_if>
                              <do_else>
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '})' + ' is standing up'" chance="$DebugChance" />
                                <set_value name="$Behaviour" exact="'stand_terminal_captain'" />
                              </do_else>
                            </do_if>
                            <start_actor_sequence actor="$NPC" type="$AnimationType" behavior="$Behaviour" transition="true" immediate="true" result="this.$animationstarted" />
                            <do_if value="not this.$animationstarted">
                              <do_if value="$AnimationType" exact="'idle'">
                                <debug_text text="'Unable to start idle animation sequence for ' + $NPC.name + ' ' + $NPC" filter="error" />
                              </do_if>
                              <do_else>
                                <debug_text text="'Unable to start piloting animation sequence for ' + $NPC.name + ' ' + $NPC" filter="error" />
                              </do_else>
                            </do_if>
                          </do_if>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_ai_pilot_at_post_default" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_ai_pilot_at_post_undock" instantiate="true">
                      <conditions>
                        <event_object_signalled object="$NPC"/>
                        <!--TODO @Owen only queue transition if there are no other queued transitions? Otherwise, this may seem too late.-->
                        <check_any>
                          <check_value value="event.param == 'manage_undock'"/>
                          <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                        </check_any>
                      </conditions>
                      <actions>
                        <debug_text text="'UNDOCK TRANSITION NPC ' + $NPC.name + ' ({' + $NPC + '})'" chance="$DebugChance" />
                        <do_if value="@$DispatchTransitionStateChange">
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post_undock"/>
                        </do_if>
                        <do_else>
                          <debug_text text="'Requesting queued transition to state STATE_ai_pilot_at_post_undock'" chance="$DebugChance" />
                          <include_actions ref="QueueTransitionRequest"/>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="TRANSITION_ai_pilot_at_post_dock" instantiate="true">
                      <conditions>
                        <event_object_signalled object="$NPC"/>
                        <!--TODO @Owen only queue transition if there are no other queued transitions? Otherwise, this may seem too late.-->
                        <check_any>
                          <check_value value="event.param == 'manage_dock'"/>
                          <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                        </check_any>
                      </conditions>
                      <actions>
                        <debug_text text="'DOCK TRANSITION NPC ' + $NPC.name + ' ({' + $NPC + '})'" chance="$DebugChance" />
                        <do_if value="@$DispatchTransitionStateChange">
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_at_post_dock"/>
                        </do_if>
                        <do_else>
                          <debug_text text="'Requesting queued transition to state STATE_ai_pilot_at_post_dock'" chance="$DebugChance" />
                          <include_actions ref="QueueTransitionRequest"/>
                        </do_else>
                      </actions>
                    </cue>

                    <!-- Sub-states -->
                    <cue name="STATE_ai_pilot_at_post_undock">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <!-- Enter / Exit actions -->
                        <cue name="ENTER_ai_pilot_at_post_undock">
                          <actions>
                            <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is now entering STATE_ai_pilot_at_post_undock'" chance="$DebugChance" />

                            <do_if value="$NPC.attention ge attention.nearby">
                              <set_value name="$RoomSlot" exact="$NPC.roomslot" />
                              <set_value name="$Tags" exact="$RoomSlot.tags" />

                              <!-- Is the NPC sitting down... -->
                              <do_if value="$RoomSlot.component.ischairslot.{$RoomSlot}">
                                <debug_text text="'$NPC is sat down - focusing on sitting terminals'" chance="$DebugChance" />

                                <set_value name="$Behaviour" exact="'sit_pilot'" />
                              </do_if>

                              <!-- Or standing up? -->
                              <do_else>
                                <debug_text text="'$NPC is stood up - focusing on standing terminals'" chance="$DebugChance" />

                                <set_value name="$Behaviour" exact="'stand_terminal_captain'" />
                              </do_else>

                              <!--set_value name="$Behaviour" exact="'sit_terminal_left'" /-->
                              <debug_text text="'Behaviour: ' + $Behaviour" chance="$DebugChance" />
                              <start_actor_sequence actor="$NPC" type="'busy'" behavior="$Behaviour" transition="true" immediate="true" result="this.$animationstarted" />
                              <do_if value="not this.$animationstarted">
                                <debug_text text="'Unable to start busy animation sequence for ' + $NPC.name + ' ' + $NPC" filter="error" />
                              </do_if>
                              <do_else>
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '}) has started busy animation sequence'" chance="$DebugChance" />
                                <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="activate" />
                              </do_else>
                            </do_if>
                          </actions>
                        </cue>

                        <cue name="EXIT_ai_pilot_at_post_undock" ref="EXIT_Empty" />
                      </cues>
                    </cue>

                    <cue name="STATE_ai_pilot_at_post_dock">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <!-- Enter / Exit actions -->
                        <cue name="ENTER_ai_pilot_at_post_dock">
                          <actions>
                            <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is now entering STATE_ai_pilot_at_post_dock'" chance="$DebugChance" />
                            <do_if value="$NPC.attention ge attention.nearby">
                              <set_value name="$RoomSlot" exact="$NPC.roomslot" />
                              <set_value name="$Tags" exact="$RoomSlot.tags" />
                              <do_if value="$RoomSlot.component.ischairslot.{$RoomSlot}">
                                <debug_text text="'$NPC is sat down'" chance="$DebugChance" />
                                <set_value name="$Behaviour" exact="'sit'" />
                              </do_if>
                              <do_else>
                                <debug_text text="'$NPC is stood up'" chance="$DebugChance" />
                                <set_value name="$Behaviour" exact="'stand_terminal_captain'" />
                              </do_else>
                              <debug_text text="'Behaviour: ' + $Behaviour" chance="$DebugChance" />
                              <start_actor_sequence actor="$NPC" type="'idle'" behavior="$Behaviour" transition="true" immediate="true" result="this.$animationstarted" />
                              <do_if value="not this.$animationstarted">
                                <debug_text text="'Unable to start idle animation sequence for ' + $NPC.name + ' ' + $NPC" filter="error" />
                              </do_if>
                              <do_else>
                                <debug_text text="'NPC ' + $NPC.name + ' ({' + $NPC + '}) has started idle animation sequence'" chance="$DebugChance" />
                                <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="deactivate" />
                              </do_else>
                            </do_if>
                          </actions>
                        </cue>

                        <cue name="EXIT_ai_pilot_at_post_dock" ref="EXIT_Empty" />
                      </cues>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <!-- Move to inside at_post? -->
            <cue name="STATE_ai_pilot_leave_post">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_ai_pilot_leave_post">
                  <actions>
                    <do_if value="$NPC.assignedcontrolled and $NPC.assignedcontrolled.assignedcontrolentity.{controlpost.aipilot} == $NPC">
                      <!-- set_value name="$DebugChance" exact="100"/ -->
                      <debug_text text="'Attempting to tell NPC ' + $NPC + ' ' + $NPC.knownname + ' to leave its pilot post'" chance="$DebugChance"/>
                      <assert value="not @$NPC.controlled.order or $NPC.controlled.order.canplayercancel" text="'NPC pilot told to leave post during a non-cancellable order [Owen]'"/>
                      
                      <trigger_animation object="$NPC.roomslot.component" group="$NPC.roomslot.group" trigger="deactivate" />

                      <!--find a suitable this.$destinationslot-->
                      <include_actions ref="FindLocalDespawnLocation"/>

                      <!-- NOTE: The AI pilot is still a control entity. Normally that means that the order script keeps running, but we have to stop it here. -->
                      <!-- When pilot assumes control again (i.e. stops being "busy"), initialise_control_entity will start the script again. -->
                      <!-- TODO: Make sure pilot can't leave post if current order is in critical state -->
                      <abort_scripts entity="$NPC"/>
                      <set_entity_traits entity="$NPC" busy="true"/>
                      <do_if value="this.$destinationslot">
                        <include_actions ref="GetNextTargetPoint"/>
                        <do_if value="this.$pathtable">
                          <set_value name="$pathtable" exact="this.$pathtable"/>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                          <do_if value="this.$destinationslot.tags.indexof.{tag.npc}">
                            <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                          </do_if>
                          <do_else>
                            <clear_actor_roomslot actor="$NPC"/>
                          </do_else>
                          <!-- debug_text text="$pathtable"/ -->
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post_moving"/>
                        </do_if>
                        <do_else>
                          <include_actions ref="MoveFailedHandling"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post_finished"/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <debug_text text="player.age + ' Unable to find room slot with tag ' + tag.npctransport + ' - NPC will disappear instantly.'" filter="error"/>
                        <set_entity_traits entity="$NPC" hidden="true"/>
                        <add_actor_to_room actor="$NPC" slot="this.$destinationslot"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Attempting to tell NPC ' + $NPC + ' ' + $NPC.knownname + ' to leave its pilot post but it is not currently an assigned pilot. Reinitialise.'" chance="$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_leave_post" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_ai_pilot_leave_post_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_ai_pilot_leave_post_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_ai_pilot_leave_post_moving_finished"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="EXIT_ai_pilot_leave_post_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_ai_pilot_leave_post_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_leave_post_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_ai_pilot_leave_post_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_ai_pilot_leave_post_finished">
                  <actions>
                    <set_entity_traits entity="$NPC" hidden="true"/>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_leave_post_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_ai_pilot_return_to_post">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_ai_pilot_return_to_post">
                  <actions>
                    <do_if value="$NPC.assignedcontrolled.pilot">
                      <debug_text text="'Unable to return to control post as ' + $NPC.assignedcontrolled.pilot.knownname + ' ' + $NPC.assignedcontrolled.pilot + ' is there'" chance="$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_ai_pilot_move_to_post"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_ai_pilot_return_to_post" ref="EXIT_Empty"/>
              </cues>
            </cue>

          </cues>
        </cue>

        <!--TODO @Owen - manager is currently only in the controlroom with nowhere to walk to. Is this enough? Hiring/Firing usecase.-->
        <cue name="STATE_manager" version="3">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <patch sinceversion="2" state="complete">
            <do_if value="not $NPC.controlled">
              <debug_text text="'Manager ' + $NPC + ' ' + $NPC.knownname + ' owned by ' + $NPC.owner + ' did not initialise properly for ' + $NPC.assignedcontrolled + ' ' + $NPC.assignedcontrolled.knownname + ' - Reinitialising'" filter="savegame"/>
              <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
            </do_if>
          </patch>
          <patch sinceversion="3" state="complete">
            <do_if value="$NPC.ishidden">
              <set_entity_traits entity="$NPC" hidden="false"/>
            </do_if>
          </patch>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_manager">
              <actions>
                <do_if value="$NPC.controlled">
                  <!--If activly controlling, the NPC should not be hidden, even if in the invisible control room-->
                  <set_entity_traits entity="$NPC" hidden="false"/>
                </do_if>
                <do_elseif value="$NPC.assignedcontrolled">
                  <do_if value="$NPC.exists">
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                  </do_if>
                  <do_else>
                    <assign_control_entity actor="$NPC" object="$NPC.assignedcontrolled" post="controlpost.manager" transfer="true"/>
                  </do_else>
                </do_elseif>
                <do_else>
                  <assert value="$NPC.assignedcontrolled" text="'Manager control entity ' + $NPC + ' ' + $NPC.knownname + ' does not have an assigned controllable [Owen]'"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_manager" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_shiptrader" version="2">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <patch sinceversion="2" state="complete">
            <do_if value="$NPC.ishidden">
              <set_entity_traits entity="$NPC" hidden="false"/>
            </do_if>
          </patch>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_shiptrader">
              <actions>
                <do_if value="$NPC.controlled">
                  <!--If activly controlling, the NPC should not be hidden, even if in the invisible control room-->
                  <set_entity_traits entity="$NPC" hidden="false"/>
                </do_if>
                <do_elseif value="$NPC.assignedcontrolled">
                  <do_if value="$NPC.exists">
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                  </do_if>
                  <do_else>
                    <assign_control_entity actor="$NPC" object="$NPC.assignedcontrolled" post="controlpost.shiptrader" transfer="true"/>
                  </do_else>
                </do_elseif>
                <do_else>
                  <assert value="$NPC.assignedcontrolled" text="'Shiptrader control entity ' + $NPC + ' ' + $NPC.knownname + ' does not have an assigned controllable [Owen]'"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_shiptrader" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <!--Simple state machine to not have the NPC wander around-->
        <cue name="STATE_stay">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->

            <!--<cue name="ENTER_stay"/>-->

            <cue name="EXIT_stay" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_worker">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_worker">
              <actions>
                <do_if value="not $NPC.$role_object?">
                  <do_if value="$NPC.controllable.people.{$NPC.npctemplate}.exists">
                    <set_value name="$NPC.$role_object" exact="$NPC.controllable"/>
                  </do_if>
                </do_if>
                <assert value="$NPC.role" text="'Entity does not have a role in this NPC state'"/>
                <do_if value="@$NPC.$role_object.exists">
                  <debug_text text="'$NPC.controllable ' + $NPC.controllable + ' $NPC.$role_object ' + $NPC.$role_object" chance="$DebugChance"/>
                  <do_if value="$NPC.controllable == $NPC.$role_object">
                    <do_if value="$NPC.roomslot and $NPC.roomslot.tags.indexof.{$NPC.role.tag}">
                      <do_if value="($NPC.race != race.split and not $NPC.isfemale) and $NPC.attention ge attention.nearby">
                        <debug_text text="'ENTER_worker deciding what to do.'" chance="$DebugChance"/>
                        <do_any>
                          <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post" weight="50" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_welder" weight="5" />
                          <!-- signal_cue_instantly cue="ChangeState" param="STATE_worker_with_tool" weight="1" / -->
                        </do_any>
                      </do_if>
                      <do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post" />
                      </do_else>
                    </do_if>
                    <do_else>
                      <find_npc_slot name="$destinationslot" object="$NPC.$role_object" role="$NPC.role"/>
                      <do_if value="$destinationslot">
                        <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                      </do_if>
                      <do_else>
                        <!--No available room slot, stay for now-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post"/>
                      </do_else>
                    </do_else>
                  </do_if>
                  <do_else>
                    <!--Not on-board object-->
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                  </do_else>
                </do_if>
                <do_else>
                  <assert value="$NPC.$role_object.exists" text="'Entity does not know what object it has a role for. It is on board controllable ' + $NPC.controllable + ' ' + @$NPC.controllable.knownname"/>
                  <destroy_object object="$NPC"/>
                </do_else>

                <set_value name="$NPCSlot" exact="null" comment="This is a valid scenario - it later tells the state machine that it is free to choose a valid slot at random" />
                <set_value name="$NPCSpeed" exact="null" comment="This is a valid scenario - it later tells the state machine that it is free to choose a speed at random" />
              </actions>
            </cue>

            <cue name="EXIT_worker">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <do_if value="$staytime?">
                  <remove_value name="$staytime"/>
                </do_if>
                <remove_value name="$NPCSlot" />
              </actions>
            </cue>

            <!-- Transitions -->

            <cue name="TRANSITION_worker_to_post" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'npc_to_post'" comment="event.param2 = table[$NPCSlot = Target slot (optional)]"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post"/>
                  <set_value name="ChangeState.$ParamTable" exact="event.param2.{2}"/>
                </do_if>
                <do_else>
                  <!--TODO @Owen the slot is not reserved at this point. should it be?-->
                  <do_if value="event.param2.$DebugChance?">
                    <set_value name="$DebugChance" exact="event.param2.$DebugChance" />
                  </do_if>
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>

                <!--TODO @Owen check if we still need the $ActiveStates safeguard. We don't know what states will be active once this queued state transition happens. Just bulletproof the requested state?-->
                <!--
                <set_value name="$NPCSlot" exact="event.param2.$Slot" />
                <set_value name="$DebugChance" exact="event.param2.$DebugChance" />
                
                <do_if value="not $ActiveStates.indexof.{STATE_worker_at_post}" comment="Only signal entering sub-state if the pilot is not already at their post">
                  <debug_text text="'Signalling service personnel to enter STATE_worker_at_post'" chance="$DebugChance" />
                  <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post" />
                </do_if>-->
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_worker_at_post">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_worker_at_post">
                  <actions>
                    <set_value name="$NPCSlot" exact="@parent.$ParamTable.$NPCSlot"/>

                    <set_value name="$NPCAtPost" exact="false" />
                    <!-- Check to see whether NPC is already at their post or whether they need to be moved there -->
                    <do_if value="$NPCSlot">
                      <debug_text text="'A predefined slot has been passed into the state machine - checking to see whether NPC is there or not'" chance="$DebugChance" />
                      <do_if value="$NPC.roomslot == $NPCSlot and not $NPC.isintransit">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already in position'" chance="$DebugChance" />
                        <!-- The NPC is already in position, we do not need to move them and can move straight into STATE_worker_at_post_default -->
                        <set_value name="$NPCAtPost" exact="true" />
                      </do_if>
                      <do_elseif value="$NPC.isintransit">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already on their way to their post'" chance="$DebugChance" />
                        <!-- We should leave $NPCAtPost as it is, this will fall into STATE_worker_move_to_post, which can track when the $NPC actually reaches the slot -->
                      </do_elseif>
                      <do_elseif value="$NPC.roomslot != $NPCSlot">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is in wrong position'" chance="$DebugChance" />
                        <!-- We can leave $NPCAtPost as it is - STATE_worker_move_to_post should still be able to access $NPCSlot, so should be able to put $NPC in correct slot -->
                      </do_elseif>
                    </do_if>
                    <do_else>
                      <debug_text text="'No predefined slot has been passed in - check to see whether NPC is in a valid slot'" chance="$DebugChance" />
                      <set_value name="$CurrentSlot" exact="$NPC.roomslot" />
                      <debug_text text="'$CurrentSlot set to ' + $CurrentSlot" chance="$DebugChance" />

                      <do_if value="$CurrentSlot and $CurrentSlot.tags.indexof.{$NPC.role.tag}">
                        <debug_text text="'$CurrentSlot is valid!'" chance="$DebugChance" />
                        <set_value name="$InValidSlot" exact="true" />
                      </do_if>
                      <do_else>
                        <debug_text text="'$CurrentSlot is not valid!'" chance="$DebugChance" />
                        <set_value name="$InValidSlot" exact="false" />
                      </do_else>

                      <do_if value="$InValidSlot and not $NPC.isintransit">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already in position'" chance="$DebugChance" />
                        <!-- The NPC is already in position; we do not need to move them and can move straight into STATE_worker_at_post_default -->
                        <set_value name="$NPCAtPost" exact="true" />
                      </do_if>
                      <do_elseif value="$NPC.isintransit">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is already on their way to their post'" chance="$DebugChance" />
                        <!-- We should leave $NPCAtPost as it is - this will fall into STATE_worker_move_to_post, which can track when the $NPC actually reaches the slot -->
                      </do_elseif>
                      <do_elseif value="not $InValidSlot">
                        <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is in wrong position'" chance="$DebugChance" />
                        <!-- We can leave $NPCAtPost as it is - STATE_worker_move_to_post can find a valid position to move them to -->
                      </do_elseif>
                    </do_else>

                    <debug_text text="'Is $NPC at post?: ' + $NPCAtPost" chance="$DebugChance" />
                    <!-- If they're at their post then they should move to the default sub-state -->
                    <do_if value="$NPCAtPost">
                      <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post_default" />
                    </do_if>
                    <!-- Otherwise, they need to move into position -->
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_worker_move_to_post" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_worker_at_post" ref="EXIT_Empty"/>

                <!-- Sub-states -->
                <cue name="STATE_worker_move_to_post">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_move_to_post">
                      <actions>
                        <set_value name="$NPCRole" exact="$NPC.role" />
                        <set_value name="$NPC.$role_object" exact="$NPC.controllable" />

                        <do_if value="($NPCRole and $NPC.$role_object.exists)">
                          <debug_text text="'$NPC has a role, their $role_object exists and they belong to it - safe to continue'" chance="$DebugChance" />

                          <set_value name="$Assigned" exact="$NPC.$role_object" />
                          <set_value name="$Assignment" exact="$NPC.role" />
                          <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) - $Assigned: ' + $Assigned + '; $Assignment: ' + $Assignment" chance="$DebugChance" />

                          <set_value name="this.$destinationslot" exact="null" />
                          <set_value name="$currentroomslot" exact="$NPC.roomslot" />

                          <!-- No pre-defined slot has been passed in - the NPC should be moved to a random valid position -->
                          <do_if value="not $NPCSlot">
                            <do_if value="$currentroomslot and $currentroomslot.tags.indexof.{entityrole.service.tag}">
                              <set_value name="this.$destinationslot" exact="$currentroomslot" />
                            </do_if>
                            <do_else>
                              <find_npc_slot name="this.$destinationslot" object="$Assigned" role="$Assignment" />
                            </do_else>
                          </do_if>

                          <!-- Pre-defined slot has been passed into the state machine - the NPC should be moved to this position -->
                          <do_else>
                            <set_value name="this.$destinationslot" exact="$NPCSlot" />
                          </do_else>

                          <do_if value="not this.$destinationslot">
                            <!--Find a despawn slot on the object for a role entity-->
                            <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                            <!--TODO @Owen - check if this should instead signal the NPC to despawn to disconnect
                            <signal_objects object="$NPC" param="'npc_despawn'" param2="table[$disconnect = true]"/>-->
                          </do_if>
                          <do_else>
                            <include_actions ref="GetNextTargetPoint" />
                            <do_if value="this.$pathtable">
                              <set_value name="$pathtable" exact="this.$pathtable" />
                              <!-- If a speed was passted into the state machine, use it -->
                              <do_if value="$NPCSpeed">
                                <set_value name="$pathtable.$speed" exact="$NPCSpeed" />
                              </do_if>
                              <!-- Else, select one at random -->
                              <do_else>
                                <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                              </do_else>
                              <do_if value="this.$destinationslot.tags.indexof.{tag.npc}">
                                <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot" />
                              </do_if>
                              <do_else>
                                <clear_actor_roomslot actor="$NPC" />
                              </do_else>
                              <signal_cue_instantly cue="ChangeState" param="STATE_worker_moving_to_post" />
                            </do_if>
                            <do_else>
                              <include_actions ref="MoveFailedHandling"/>
                              <signal_cue_instantly cue="ChangeState" param="STATE_worker_move_to_post_finished" />
                            </do_else>
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'$NPC ' + $NPC.name + ' ({' + $NPC + '}) is in ENTER_worker_move_to_post when something is wrong. $NPCRole: ' + $NPCRole + '; $NPC.$role_object.exists: ' + $NPC.$role_object.exists" filter="error" />
                          <destroy_object object="$NPC" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_worker_move_to_post" ref="EXIT_Empty" />

                    <!-- Sub-states -->
                    <cue name="STATE_worker_moving_to_post">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <!-- Enter / Exit actions -->
                        <cue name="ENTER_worker_moving_to_post" ref="PerformPath">
                          <param name="NPC" value="$NPC" />
                          <param name="pathtable" value="$pathtable" />
                          <param name="signalcue" value="TRANSITION_worker_moving_to_post_finished" />
                          <param name="DebugChance" value="$DebugChance" />
                        </cue>

                        <cue name="EXIT_worker_moving_to_post" ref="EXIT_Empty" />

                        <!-- Transitions -->
                        <cue name="TRANSITION_worker_moving_to_post_finished">
                          <conditions>
                            <event_cue_signalled />
                          </conditions>
                          <actions>
                            <signal_cue_instantly cue="ChangeState" param="STATE_worker_move_to_post_finished" />
                          </actions>
                        </cue>
                      </cues>
                    </cue>

                    <cue name="STATE_worker_move_to_post_finished">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <cue name="ENTER_worker_move_to_post_finished">
                          <actions>
                            <set_entity_traits entity="$NPC" busy="false" intransit="false" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post_default" />
                          </actions>
                        </cue>

                        <cue name="EXIT_worker_move_to_post_finished" ref="EXIT_Empty" />
                      </cues>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_worker_at_post_default">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!--Allow usecases
                    If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                    Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                    <cue name="USECASE_CHECK_worker_at_post_default" instantiate="true">
                      <conditions>
                        <event_cue_signalled cue="parent"/>
                        <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                      </conditions>
                      <actions>
                        <include_actions ref="Allow_Usecase"/>
                      </actions>
                    </cue>

                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_at_post_default">
                      <actions>
                        <!-- TODO (@Lorraine): Define default behaviour for service personnel at their post -->
                        <!-- VERY TEMP -->
                        <do_if value="$NPC.attention lt attention.nearby">
                          <set_value name="$staytime" min="1min" max="2min" />
                        </do_if>
                        <do_else>
                          <do_if value="$staytime?">
                            <set_value name="$staytime" min="5s" max="30s" />
                          </do_if>
                          <do_else>
                            <set_value name="$staytime" min="180s" max="300s" />
                          </do_else>
                        </do_else>
                        <signal_objects object="$NPC" param="'TRANSITION_worker_at_post_wander'" delay="$staytime" />
                      </actions>
                    </cue>

                    <cue name="EXIT_worker_at_post_default" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_worker_at_post_leave" instantiate="true">
                      <conditions>
                        <event_object_signalled object="$NPC"/>
                        <check_any>
                          <check_value value="event.param == 'worker_at_post_leave'"/>
                          <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                        </check_any>
                      </conditions>
                      <actions>
                        <do_if value="@$DispatchTransitionStateChange">
                          <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                        </do_if>
                        <do_else>
                          <include_actions ref="QueueTransitionRequest"/>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="TRANSITION_worker_at_post_wander" instantiate="true">
                      <conditions>
                        <event_object_signalled object="$NPC" param="'TRANSITION_worker_at_post_wander'"/>
                      </conditions>
                      <actions>
                        <include_actions ref="Validate_Usecase_Reservation"/>
                        <do_if value="@$UsecaseCue.exists">
                          <signal_cue_instantly cue="ChangeState" param="STATE_worker_at_post_default" />
                        </do_if>
                        <do_else>
                          <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment"/>
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="TRANSITION_worker_at_post_dock">
                      <conditions>
                        <event_object_signalled object="$NPC" param="'manage_dock'" />
                      </conditions>
                      <actions>
                        <!-- TODO (@Lorraine): Define transition to docking substate -->
                      </actions>
                    </cue>

                    <!-- Sub-states -->
                    <cue name="STATE_worker_at_post_dock">
                      <conditions>
                        <event_cue_signalled />
                        <check_value value="not @event.param" />
                      </conditions>
                      <actions>
                        <include_actions ref="Init_State" />
                      </actions>
                      <cues>
                        <!-- Enter / Exit actions -->
                        <cue name="ENTER_worker_at_post_dock">
                          <actions>
                            <!-- TODO (@Lorraine): Define behaviour for entering into this substate -->
                          </actions>
                        </cue>

                        <!-- Events -->

                        <cue name="EXIT_worker_at_post_dock" ref="EXIT_Empty" />
                      </cues>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_worker_with_tool">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!--Allow usecases
                If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                <cue name="USECASE_CHECK_worker_with_tool" instantiate="true">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                  </conditions>
                  <actions>
                    <do_if value="$ToolInHand">
                      <include_actions ref="Disallow_Usecase"/>
                    </do_if>
                    <do_else>
                      <include_actions ref="Allow_Usecase"/>
                    </do_else>
                  </actions>
                </cue>

                <!-- Enter / Exit actions -->
                <cue name="ENTER_worker_with_tool">
                  <actions>
                    <set_value name="$DestinationSlot" exact="null" />
                    <!-- Select which type of tool the NPC should use -->
                    <do_any>
                      <!-- @Lorraine: Do-any is there because there will be other types of tools later -->
                      <set_value name="$ToolType" exact="'TwoHand'" />
                      <set_value name="$ToolType" exact="'OneHand'" />
                    </do_any>
                    <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will pick up a tool with type ' + $ToolType" chance="$DebugChance" />
                    <set_value name="$ToolInHand" exact="false" />

                    <signal_cue_instantly cue="ChangeState" param="STATE_worker_find_tool" />
                  </actions>
                </cue>

                <cue name="EXIT_worker_with_tool">
                  <conditions>
                    <event_cue_signalled cue="parent" />
                    <check_value value="@event.param == 'exit'" />
                  </conditions>
                  <actions>
                    <remove_value name="$ToolType" />
                    <remove_value name="$ToolInHand" />
                    <remove_value name="$DestinationSlot" />
                  </actions>
                </cue>

                <!-- Sub-states -->
                <cue name="STATE_worker_find_tool">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_find_tool">
                      <actions>
                        <do_if value="$NPC.walkablemodule">
                          <find_npc_waypoint name="$Waypoints" object="$NPC.walkablemodule" tags="tag.pickup_hole" multiple="true" />
                          <do_all exact="$Waypoints.count" counter="$WaypointCounter" reverse="true">
                            <do_if value="$Waypoints.{$WaypointCounter}" exact="$DestinationSlot">
                              <remove_value name="$Waypoints.{$WaypointCounter}" />
                            </do_if>
                          </do_all>
                          <do_if value="$Waypoints.count">
                            <set_value name="$DestinationSlot" list="$Waypoints" />
                          </do_if>
                        </do_if>

                        <do_if value="$DestinationSlot">
                          <set_value name="this.$destinationslot" exact="$DestinationSlot" />
                          <include_actions ref="GetNextTargetPoint" />
                          <do_if value="this.$pathtable">
                            <set_value name="$pathtable" exact="this.$pathtable" />
                            <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_worker_move_to_tool" />
                          </do_if>
                          <do_else>
                            <include_actions ref="MoveFailedHandling"/>
                            <signal_cue_instantly cue="ChangeState" param="STATE_worker_tool_action" />
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'Unable to find a pickup slot'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_worker_find_tool" ref="EXIT_Empty" />
                  </cues>
                </cue>

                <cue name="STATE_worker_move_to_tool">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!--Allow usecases
                    If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                    Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                    <cue name="USECASE_CHECK_worker_move_to_tool" instantiate="true">
                      <conditions>
                        <event_cue_signalled cue="parent"/>
                        <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                      </conditions>
                      <actions>
                        <do_if value="$ToolInHand">
                          <include_actions ref="Disallow_Usecase"/>
                        </do_if>
                        <do_else>
                          <include_actions ref="Allow_Usecase"/>
                        </do_else>
                      </actions>
                    </cue>

                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_move_to_tool" ref="PerformPath">
                      <param name="NPC" value="$NPC" />
                      <param name="pathtable" value="$pathtable" />
                      <param name="signalcue" value="TRANSITION_worker_tool_action" />
                      <param name="DebugChance" value="$DebugChance" />
                    </cue>

                    <cue name="EXIT_worker_move_to_tool" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_worker_tool_action">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_worker_tool_action" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_worker_tool_action">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_worker_tool_action">
                      <actions>
                        <do_if value="not $ToolInHand">
                          <do_any>
                            <set_value name="$AnimationType" exact="'tool_quickpickup_ground'" weight="70" />
                            <set_value name="$AnimationType" exact="'tool_pickup_ground'" weight="30" />
                          </do_any>
                        </do_if>
                        <do_elseif value="$ToolInHand">
                          <set_value name="$AnimationType" exact="'tool_drop_ground'" />
                        </do_elseif>
                        <debug_text text="'$AnimationType for tool interaction set to ' + $AnimationType" chance="$DebugChance" />

                        <trigger_animation object="$NPC.room" group="'groundhatch'" trigger="activate" />

                        <start_actor_sequence actor="$NPC" type="$AnimationType" transition="true" immediate="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <debug_text text="'Unable to start ' + $AnimationType + ' animation sequence for ' + $NPC.name + ' ({' + $NPC + '})'"  filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_worker_tool_action" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_worker_picked_up_tool">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'tran_stand_toolcrouch_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is picking up a tool'" chance="$DebugChance" />
                        <!-- TODO @Lorraine: The way this is currently set up means that if the NPC stops crouched down to search for the tool before picking it up, it
                             appears in their hand before they are done searching. This is not easily solved by separating out the sequences for searching and non-searching,
                             more likely, here we have to make the decision to search or not, have an optional sequence for searching and wait for that to be fired if searching
                             was selected - or something along these lines -->
                        <do_if value="$ToolType" exact="'OneHand'">
                          <set_actor_tool actor="$NPC" name="'tool1hand'" />
                        </do_if>
                        <do_elseif value="$ToolType" exact="'TwoHand'">
                          <set_actor_tool actor="$NPC" name="'tool2hand'" />
                        </do_elseif>
                        <set_value name="$ToolInHand" exact="true" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_worker_dropped_tool">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'tran_toolstand_toolcrouch_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is dropping a tool'" chance="$DebugChance" />
                        <clear_actor_tool actor="$NPC" />
                        <set_value name="$ToolInHand" exact="false" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_worker_tool_action_finished">
                      <conditions>
                        <check_any>
                          <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_toolstand_01'" />
                          <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_stand_01'" />
                        </check_any>
                      </conditions>
                      <actions>
                        <trigger_animation object="$NPC.room" group="'groundhatch'" trigger="deactivate" />

                        <do_if value="not $ToolInHand">
                          <debug_text text="'NPC does not have tool in hand - they can either reinitialise or go to find a tool'" chance="$DebugChance" />

                          <do_any>
                            <do_all weight="60">
                              <debug_text text="'NPC will reinitialise'" chance="$DebugChance" />
                              <signal_cue_instantly cue="ChangeState" param="STATE_init" weight="60" />
                            </do_all>
                            <do_all weight="40">
                              <debug_text text="'NPC will pick up another tool'" chance="$DebugChance" />
                              <signal_cue_instantly cue="ChangeState" param="STATE_worker_find_tool" weight="40" />
                            </do_all>
                          </do_any>
                        </do_if>
                        <do_else>
                          <debug_text text="'NPC has tool in hand, they should go to put the tool down'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_worker_find_tool" />
                        </do_else>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_move_to_assignment">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <!--TODO @Owen - broken case. Pilot being told to work as service. Doesn't get up.-->
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_move_to_assignment">
              <actions>
                <!--TODO @Owen check if they are in a conversation-->
                <do_if value="$NPC.controlpost">
                  <set_value name="$assigned" exact="$NPC.assignedcontrolled"/>
                  <debug_text text="player.age + ' assigned ' + $assigned" chance="$DebugChance"/>
                  <do_if value="$assigned">
                    <do_if value="$assigned == $NPC.controlled">
                      <!--Find correct state via the initial handler-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_find"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_idle"/>
                  </do_else>
                  <remove_value name="$assigned"/>
                </do_if>
                <do_elseif value="$NPC.role">
                  <do_if value="$NPC.controllable.people.{$NPC.npctemplate}.exists">
                    <set_value name="$NPC.$role_object" exact="$NPC.controllable"/>
                  </do_if>
                  <do_if value="$NPC.$role_object.exists">
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_find"/>
                  </do_if>
                  <do_else>
                    <assert value="$NPC.$role_object.exists" text="'entity ' + $NPC + ' ' + $NPC.knownname + ' has role ' + $NPC.role + ' but no assigned object. killing'"/>
                    <destroy_object object="$NPC"/>
                  </do_else>
                </do_elseif>
              </actions>
            </cue>

            <cue name="EXIT_move_to_assignment" ref="EXIT_Empty"/>

            <!--Sub-states-->

            <cue name="STATE_move_to_assignment_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_move_to_assignment_find">
                  <actions>
                    <do_if value="$NPC.isbusy">
                      <!--TODO @Owen check if entity is already in the place they should be 'busy' in. Should they walk to the cabin and 'hide'-->
                      <debug_text text="player.age + ' busy'" chance="$DebugChance"/>
                      <!--<signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_find"/>-->
                    </do_if>
                    <do_elseif value="$NPC.controlled">
                      <!--NPC is already controlling-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_elseif>
                    <do_elseif value="$NPC.controlpost == controlpost.aipilot">
                      <!--TODO @Owen this case can happen after a NPC has been hired while this state was queued by a transition request. Another transition request to re-init is probably pending from the hire request.-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_elseif>
                    <do_else>
                      <set_value name="$assigned" exact="null"/>
                      <do_if value="$NPC.controlpost">
                        <set_value name="$assigned" exact="$NPC.assignedcontrolled"/>
                        <set_value name="$assignment" exact="$NPC.controlpost"/>
                      </do_if>
                      <do_elseif value="$NPC.role">
                        <set_value name="$assigned" exact="@$NPC.$role_object"/>
                        <set_value name="$assignment" exact="$NPC.role"/>
                      </do_elseif>
                      <do_else>
                        <!--TODO @Owen no assignment?-->
                      </do_else>

                      <debug_text text="player.age + ' assigned ' + $assigned + ' ' + $assigned.knownname + ' as ' + $assignment" chance="$DebugChance"/>
                      <do_if value="$assigned.exists">
                        <set_value name="this.$destinationslot" exact="null"/>
                        <set_value name="$nextstate" exact="null"/>
                        <set_value name="$currentroomslot" exact="$NPC.roomslot"/>
                        <!--check if at or en-route to a suitable location-->
                        <do_if value="$currentroomslot and ($currentroomslot.component == $assigned or (not $currentroomslot.component.isclass.object and $currentroomslot.component.object == $assigned))">
                          <!--Only controlpost entities or those in-transit should look at their current room slot. Role NPCs should try to find new ones (unless there is no other slot available).-->
                          <do_if value="typeof $assignment == datatype.controlpost">
                            <!--while both controlpost and entityrole have the script property .tag, let's not assume that here in case that changes-->
                            <do_if value="$currentroomslot.tags.indexof.{$assignment.tag}">
                              <set_value name="this.$destinationslot" exact="$currentroomslot"/>
                            </do_if>
                          </do_if>
                          <do_elseif value="typeof $assignment == datatype.entityrole">
                            <do_if value="$NPC.isintransit and $currentroomslot.tags.indexof.{$assignment.tag}">
                              <set_value name="this.$destinationslot" exact="$currentroomslot"/>
                            </do_if>
                            <do_else>
                              <find_npc_slot name="this.$destinationslot" object="$assigned" role="$assignment"/>
                              <do_if value="not this.$destinationslot">
                                <!--No other slot for this role entity to move to. Stay at current location-->
                                <set_value name="this.$destinationslot" exact="$currentroomslot"/>
                              </do_if>
                            </do_else>
                          </do_elseif>
                        </do_if>

                        <!--if $currentroomslot is not suitable, search for a new one-->
                        <do_if value="not this.$destinationslot">
                          <do_if value="typeof $assignment == datatype.controlpost">
                            <!--If assignment was a controlpost, the above check for $NPC.controlled would have caught if it was already at a suitable location-->
                            <debug_text text="'Looking for control post slots'" chance="$DebugChance"/>
                            <find_npc_slot name="this.$destinationslot" object="$assigned" post="$assignment"/>
                            <do_if value="not this.$destinationslot">
                              <do_if value="$assignment == controlpost.manager">
                                <find_room name="$managersoffice" roomtype="roomtype.manager" object="$assigned"/>
                                <debug_text text="'Looking for slots in manager room'" chance="$DebugChance"/>
                                <do_if value="$managersoffice">
                                  <find_npc_slot name="this.$destinationslot" object="$managersoffice" tags="tag.control"/>
                                </do_if>
                                <do_if value="not this.$destinationslot">
                                  <find_npc_slot name="this.$destinationslot" object="$managersoffice"/>
                                </do_if>
                              </do_if>
                              <do_if value="$assignment == controlpost.shiptrader">
                                <!--TODO @Owen, using the tag here is a bit of a hack as using 'post' will not find slots on corners-->
                                <find_npc_slot name="this.$destinationslot" object="$assigned" tags="controlpost.shiptrader.tag"/>
                              </do_if>
                              <do_if value="not this.$destinationslot">
                                <!--No slots could be found. Simply finish so it can be assigned-->
                                <debug_text text="'No slots could be found. Simply finish so it can be assigned'" chance="$DebugChance"/>
                                <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_finished"/>
                              </do_if>
                            </do_if>
                          </do_if>
                          <do_elseif value="typeof $assignment == datatype.entityrole">
                            <find_npc_slot name="this.$destinationslot" object="$assigned" role="$assignment"/>
                            <do_if value="not this.$destinationslot">
                              <!--TODO @Owen better rules for wandering role NPCs-->
                              <!--Find random free NPC slot-->
                              <find_npc_slot name="this.$destinationslot" object="$assigned" tags="tag.npc_generic"/>
                            </do_if>
                          </do_elseif>
                        </do_if>

                        <do_if value="not this.$destinationslot and typeof $assignment == datatype.entityrole">
                          <!--Find a despawn slot on the object for a role entity-->
                          <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                        </do_if>

                        <!--Evaluate this.$destinationslot-->
                        <do_elseif value="not this.$destinationslot">
                          <!--Unable to find slot. Do nothing-->
                          <debug_text text="player.age + ' Unable to find slot. Waiting a while before trying again.'" chance="$DebugChance"/>
                        </do_elseif>
                        <do_elseif value="this.$destinationslot == $currentroomslot and not $NPC.isintransit">
                          <!--Current roomslot is fine and NPC is not in transit. Do nothing-->
                          <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_finished"/>
                        </do_elseif>
                        <do_else>
                          <!--Go to this.$destinationslot-->
                          <include_actions ref="GetNextTargetPoint"/>
                          <do_if value="this.$pathtable">
                            <set_value name="$pathtable" exact="this.$pathtable"/>
                            <do_if value="$NPC.distanceto.{this.$destinationslot} gt 200m">
                              <set_value name="$pathtable.$speed" exact="$NPC.runspeed"/>
                            </do_if>
                            <do_elseif value="$NPC.room.parent.isclass.walkablemodule">
                              <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                            </do_elseif>
                            <do_else>
                              <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                            </do_else>
                            <do_if value="this.$destinationslot.tags.indexof.{tag.npc}">
                              <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                            </do_if>
                            <do_else>
                              <clear_actor_roomslot actor="$NPC"/>
                            </do_else>
                            <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_moving"/>
                          </do_if>
                          <do_else>
                            <include_actions ref="MoveFailedHandling"/>
                            <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_finished"/>
                          </do_else>
                        </do_else>
                      </do_if>
                    </do_else>
                  </actions>
                  <cues>
                    <!--If there was no state change, no suitable destinationslot was found. Wait a little while and retry-->
                    <cue name="ENTER_HELPER_move_to_assignment_find_reset">
                      <delay exact="1s"/>
                      <actions>
                        <reset_cue cue="ENTER_move_to_assignment_find"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="EXIT_move_to_assignment_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_move_to_assignment_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Allow usecases
                If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                <cue name="USECASE_CHECK_move_to_assignment_moving" instantiate="true">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                  </conditions>
                  <actions>
                    <!--Only allow usecase interrupts for NPCs which are not control entities moving to their controlling positions-->
                    <do_if value="$NPC.controlpost">
                      <include_actions ref="Disallow_Usecase"/>
                    </do_if>
                    <do_else>
                      <include_actions ref="Allow_Usecase"/>
                    </do_else>
                  </actions>
                </cue>

                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_move_to_assignment_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_move_to_assignment_moving_finished"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="EXIT_move_to_assignment_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_move_to_assignment_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_move_to_assignment_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_move_to_assignment_finished">
                  <actions>
                    <set_entity_traits entity="$NPC" busy="false" intransit="false"/>
                    <do_if value="$NPC.assignedcontrolled">
                      <set_value name="$controlslot" exact="$NPC.assignedcontrolled.controlpostslot.{$NPC.controlpost}"/>
                      <do_if value="not $controlslot and $NPC.controlpost == controlpost.manager and $NPC.roomslot and $NPC.container == $NPC.assignedcontrolled and $NPC.assignedcontrolled.attention ge attention.nearby">
                        <!--Manager can be allowed to be at a position outside of the control room, but only allow this if they are on the controllable. Otherwise warp them to the control room for safety.-->
                        <debug_text text="'Manager ' + $NPC + ' ' + $NPC.knownname + ' is not in the controlroom but is onboard the nearby station. State machine will allow this.'" chance="$DebugChance"/>
                      </do_if>
                      <do_elseif value="$controlslot and $NPC.roomslot != $controlslot">
                        <assert value="false" text="'Control entity ' + $NPC + ' ' + $NPC.knownname + ' finished moving but not to their control position. Attempting to fix by adding them to their control location [Owen]'"/>
                        <add_actor_to_post_location actor="$NPC"/>
                      </do_elseif>
                      <do_elseif value="not $NPC.controlled">
                        <assert value="$NPC.controlled" text="'Control entity ' + $NPC + ' ' + $NPC.knownname + ' is not currently controlling. Attempting to fix by re-adding them to their control location [Owen]'"/>
                        <add_actor_to_post_location actor="$NPC"/>
                      </do_elseif>
                      <do_elseif value="$NPC.container != $NPC.assignedcontrolled">
                        <assert value="$NPC.container == $NPC.assignedcontrolled" text="'Control entity ' + $NPC + ' ' + $NPC.knownname + ' is not inside their assigned controllable. Attempting to fix by re-adding them to their control location [Owen]'"/>
                        <add_actor_to_post_location actor="$NPC"/>
                      </do_elseif>

                      <initialise_control_entity actor="$NPC"/>
                    </do_if>

                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </actions>
                </cue>

                <cue name="EXIT_move_to_assignment_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_pickup">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_pickup">
              <actions>
                <!-- set_value name="$DebugChance" exact="100"/ -->
                <set_value name="$PickupDone" exact="false"/>
                <signal_cue_instantly cue="ChangeState" param="STATE_pickup_find"/>
              </actions>
            </cue>

            <cue name="EXIT_pickup">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <remove_value name="$PickupDone"/>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_pickup_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_pickup_find">
                  <actions>
                    <find_npc_waypoint name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.pickup_hole"/>

                    <do_if value="this.$destinationslot">
                      <!--Go to this.$destinationslot-->
                      <include_actions ref="GetNextTargetPoint"/>
                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="$NPC.room.parent.isclass.walkablemodule">
                          <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving"/>
                      </do_if>
                      <do_else>
                        <include_actions ref="MoveFailedHandling"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Unable to find a pickup slot.'" chance="$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_pickup_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_pickup_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_pickup_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_pickup_moving_finished"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="EXIT_pickup_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_pickup_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_pickup_moving_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_pickup_moving_finished">
                  <actions>
                    <do_if value="$PickupDone">
                      <!--Pickup was done, end-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                    <do_else>
                      <!--Pickup was not done yet, do it-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_pickup_action"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_pickup_moving_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_pickup_action">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_pickup_action">
                  <actions>
                    <start_actor_sequence actor="$NPC" type="'tool_pickup_ground'" behavior="'standing'" transition="false" result="this.$animationstarted"/>
                    <set_actor_tool actor="$NPC" name="'tool1hand'" />
                    <do_if value="not this.$animationstarted">
                      <debug_text text="'Unable to start pickup animation for ' + $NPC.knownname + ' ' + $NPC" filter="error"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                  </actions>
                </cue>

                <cue name="EXIT_pickup_action" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_pickup_action_finished" instantiate="true">
                  <conditions>
                    <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_toolstand_01'"/>
                  </conditions>
                  <actions>
                    <set_value name="$PickupDone" exact="true"/>
                    <find_npc_slot name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.npc_generic"/>
                    <do_if value="not this.$destinationslot">
                      <find_npc_slot name="this.$destinationslot" object="$NPC.container" tags="tag.npc_generic"/>
                    </do_if>

                    <do_if value="this.$destinationslot">
                      <!--Go to this.$destinationslot-->
                      <include_actions ref="GetNextTargetPoint"/>
                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="$NPC.room.parent.isclass.walkablemodule">
                          <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <do_if value="this.$destinationslot.tags.indexof.{tag.npc}">
                          <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                        </do_if>
                        <do_else>
                          <clear_actor_roomslot actor="$NPC"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving"/>
                      </do_if>
                      <do_else>
                        <include_actions ref="MoveFailedHandling"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_pickup_moving_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Unable to find a destination slot.'" chance="$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_vendomat">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_vendomat">
              <actions>
                <!-- set_value name="$DebugChance" exact="100"/ -->
                <set_value name="$PickupDone" exact="false"/>
                <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_find"/>
              </actions>
            </cue>

            <cue name="EXIT_vendomat">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <remove_value name="$VendomatDone"/>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_vendomat_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_vendomat_find">
                  <actions>
                    <find_npc_slot name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.vendingmachine"/>

                    <do_if value="this.$destinationslot">
                      <set_value name="$vendomat" exact="this.$destinationslot.component"/>
                      <!--Go to this.$destinationslot-->
                      <include_actions ref="GetNextTargetPoint"/>
                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="$NPC.room.parent.isclass.walkablemodule">
                          <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving"/>
                      </do_if>
                      <do_else>
                        <include_actions ref="MoveFailedHandling"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Unable to find a vendomat slot.'" chance="$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_vendomat_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_vendomat_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->

                <!--Movement helper library-->
                <cue name="ENTER_vendomat_moving" ref="PerformPath">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_vendomat_moving_finished"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="EXIT_vendomat_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_vendomat_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_vendomat_moving_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_vendomat_moving_finished">
                  <actions>
                    <do_if value="$VendomatDone">
                      <!--Vendomat was done, end-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                    <do_else>
                      <!--Vendomat was not done yet, do it-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_action"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_vendomat_moving_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_vendomat_action">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_vendomat_action">
                  <actions>
                    <trigger_animation object="$vendomat" trigger="activate"/>
                    <start_actor_sequence actor="$NPC" type="'vendingmachine_use'" behavior="'generic'" transition="false" result="this.$animationstarted"/>
                    <do_if value="not this.$animationstarted">
                      <debug_text text="'Unable to start vendomat animation for ' + $NPC.knownname + ' ' + $NPC" filter="error"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                  </actions>
                </cue>

                <cue name="EXIT_vendomat_action" ref="EXIT_Empty"/>


                <cue name="TRANSITION_vendomat_action_finished" instantiate="true">
                  <conditions>
                    <!-- event_character_animation_finished object="$NPC" id="'tran_standterminal_stand_01'"/ -->
                    <event_character_animation_finished object="$NPC" id="'vending_takeout'"/>
                  </conditions>
                  <actions>
                    <trigger_animation object="$vendomat" trigger="deactivate"/>
                    <set_value name="$VendomatDone" exact="true"/>
                    <find_npc_slot name="this.$destinationslot" object="$NPC.walkablemodule" tags="tag.npc_generic"/>
                    <do_if value="not this.$destinationslot">
                      <find_npc_slot name="this.$destinationslot" object="$NPC.container" tags="tag.npc_generic"/>
                    </do_if>

                    <do_if value="this.$destinationslot">
                      <!--Go to this.$destinationslot-->
                      <include_actions ref="GetNextTargetPoint"/>
                      <do_if value="this.$pathtable">
                        <set_value name="$pathtable" exact="this.$pathtable"/>
                        <do_if value="$NPC.room.parent.isclass.walkablemodule">
                          <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                        </do_if>
                        <do_else>
                          <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                        </do_else>
                        <do_if value="this.$destinationslot.tags.indexof.{tag.npc}">
                          <set_actor_roomslot actor="$NPC" roomslot="this.$destinationslot"/>
                        </do_if>
                        <do_else>
                          <clear_actor_roomslot actor="$NPC"/>
                        </do_else>
                        <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving"/>
                      </do_if>
                      <do_else>
                        <include_actions ref="MoveFailedHandling"/>
                        <signal_cue_instantly cue="ChangeState" param="STATE_vendomat_moving_finished"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'Unable to find a destination slot.'" chance="$DebugChance"/>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_welder">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <debug_text text="'STATE_welder start.'" chance="$DebugChance"/>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_welder">
              <actions>
                <!-- set_value name="$DebugChance" exact="100" / -->
                <set_value name="$ToolInHand" exact="false" />
                <set_value name="$ToolType" exact="'TwoHand'" />
                <do_if value="@$NPC.$welder_ship.exists">
                  <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool"/>
                </do_if>
                <do_else>
                  <!--No dock assigned. Re-init, probably back to service behaviour-->
                  <!-- find ships -->
                  <set_value name="$DockArea" exact="null"/>
                  <set_value name="$Parent" exact="$NPC.parent"/>
                  <do_while value="$Parent">
                    <do_if value="$Parent.isclass.walkablemodule">
                      <set_value name="$DockArea" exact="$Parent"/>
                      <break/>
                    </do_if>
                    <set_value name="$Parent" exact="$Parent.parent"/>
                  </do_while>
                  <do_if value="not $DockArea">
                    <set_value name="$Parent" exact="$NPC.parent"/>
                    <do_while value="$Parent">
                      <do_if value="$Parent.isclass.object">
                        <set_value name="$DockArea" exact="$Parent"/>
                        <break/>
                      </do_if>
                      <set_value name="$Parent" exact="$Parent.parent"/>
                    </do_while>
                  </do_if>

                  <do_if value="$DockArea">
                    <debug_text text="'Welder found DockArea Parent' + $DockArea.macro" chance="$DebugChance"/>
                    <find_object_component name="$DockingBays" object="$DockArea" multiple="true">
                      <match_dock storage="false" size="tag.dock_s"/>
                    </find_object_component>

                    <create_group groupname="this.$Ships"/>
                    <do_all exact="$DockingBays.count" counter="$i">
                      <debug_text text="'dock ' + $DockingBays.{$i}.macro" chance="$DebugChance"/>
                      <do_if value="$DockingBays.{$i}.assignedship">
                        <debug_text text="'  assigned ship ' + $DockingBays.{$i}.assignedship.macro + ' KName ' + $DockingBays.{$i}.assignedship.knownname" chance="$DebugChance"/>
                        <add_to_group object="$DockingBays.{$i}.assignedship" groupname="this.$Ships"/>
                      </do_if>
                    </do_all>
                    <debug_text text="'ships ' + this.$Ships.count" chance="$DebugChance"/>
                    <do_if value="this.$Ships.count">
                      <set_value name="this.$DistanceTable" exact="table[]"/>
                      <do_all exact="this.$Ships.count" counter="$i">
                        <!--TODO @Owen - improve selection by distance. Walk distance may actually be longer than direct distance-->
                        <set_value name="this.$DistanceTable.{this.$Ships.{$i}}" exact="this.$Ships.{$i}.distanceto.{$NPC}"/>
                      </do_all>
                      <set_value name="this.$NearestShip" exact="this.$DistanceTable.keys.sorted.{1}"/>
                      <debug_text text="'Nearest Ship: ' + this.$NearestShip.macro + ' KName ' + this.$NearestShip.knownname" chance="$DebugChance"/>
                      <set_value name="$NPC.$welder_ship" exact="this.$NearestShip"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'Welder no ship found!'" chance="$DebugChance"/>
                    </do_else>
                  </do_if >
                  <do_else>
                    <debug_text text="'Welder no dockarea found!'"/>
                  </do_else>
                  <do_if value="@$DispatchTransitionStateChange">
                    <signal_cue_instantly cue="ChangeState" param="STATE_welder"/>
                  </do_if>
                  <do_else>
                    <include_actions ref="QueueTransitionRequest"/>
                  </do_else>
                  <!-- Second try with found ship -->
                  <do_if value="@$NPC.$welder_ship.exists">
                    <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool"/>
                  </do_if>
                  <do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </do_else>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_welder">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <remove_value name="$ToolType" />
                <remove_value name="$ToolInHand" />
                <remove_value name="$DestinationSlot" />
                <set_value name="$DebugChance" exact="0" />
                <!--<remove_value name="$JobDone"/>-->
                <do_if value="$AssignedShip?">
                  <remove_value name="$AssignedShip" />
                </do_if>
                <do_if value="$NPC.$welder_ship?">
                  <remove_value name="$NPC.$welder_ship" />
                </do_if>
                <do_if value="$Docking?">
                  <remove_value name="$Docking" />
                </do_if>
              </actions>
            </cue>
            <!-- Getting or dropping welding tool from box in the ground 
                This assumes the following variables have been set:
                $ToolInHand bool whether the welder is already carrying the tool or not
                $ToolType tool id which type of tool the welder is using (two handed for now) 
                -->
            <cue name="STATE_welder_with_tool">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit actions -->
                <cue name="ENTER_welder_with_tool">
                  <actions>
                    <set_value name="$DestinationSlot" exact="null" />
                    <!-- Select which type of tool the NPC should use -->
                    <do_if value="not $ToolInHand">
                      <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will pick up a tool with type ' + $ToolType" chance="$DebugChance" />
                    </do_if>
                    <do_else>
                      <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will drop tool with type ' + $ToolType" chance="$DebugChance" />
                    </do_else>
                    <signal_cue_instantly cue="ChangeState" param="STATE_welder_find_tool" />
                  </actions>
                </cue>

                <cue name="EXIT_welder_with_tool">
                  <conditions>
                    <event_cue_signalled cue="parent" />
                    <check_value value="@event.param == 'exit'" />
                  </conditions>
                  <actions>
                    <remove_value name="$DestinationSlot" />
                  </actions>
                </cue>

                <!-- Sub-states -->
                <cue name="STATE_welder_find_tool">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_find_tool">
                      <actions>
                        <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) trying to find a pickup location'" chance="$DebugChance" />
                        <do_if value="$NPC.walkablemodule">
                          <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) on walkable: ' + $NPC.walkablemodule" chance="$DebugChance" />
                          <do_if value="true" chance="20">
                            <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) trying to pickup from locker'" chance="$DebugChance" />
                            <find_npc_waypoint name="$Waypoints" object="$NPC.walkablemodule" tags="tag.pickup_locker" multiple="true" />
                            <do_all exact="$Waypoints.count" counter="$WaypointCounter" reverse="true">
                              <do_if value="$Waypoints.{$WaypointCounter}" exact="$DestinationSlot">
                                <remove_value name="$Waypoints.{$WaypointCounter}" />
                              </do_if>
                            </do_all>
                            <do_if value="$Waypoints.count">
                              <set_value name="$DistanceTable" exact="table[]"/>
                              <do_all exact="$Waypoints.count" counter="$i">
                                <!--TODO @Owen - improve selection by distance. Walk distance may actually be longer than direct distance-->
                                <set_value name="$DistanceTable.{$Waypoints.{$i}}" exact="$NPC.distanceto.{$Waypoints.{$i}}"/>
                              </do_all>
                              <set_value name="$DestinationSlot" exact="$DistanceTable.keys.sorted.{1}"/>
                              <!-- set_value name="$DestinationSlot" list="$Waypoints" / -->
                              <debug_text text="'DestinationSlot ' + $DestinationSlot" chance="$DebugChance" />
                            </do_if>
                          </do_if>
                          <do_if value ="not $DestinationSlot">
                            <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) trying to pickup from hole'" chance="$DebugChance" />
                            <find_npc_waypoint name="$Waypoints" object="$NPC.walkablemodule" tags="tag.pickup_hole" multiple="true" />
                            <do_all exact="$Waypoints.count" counter="$WaypointCounter" reverse="true">
                              <do_if value="$Waypoints.{$WaypointCounter}" exact="$DestinationSlot">
                                <remove_value name="$Waypoints.{$WaypointCounter}" />
                              </do_if>
                            </do_all>
                            <do_if value="$Waypoints.count">
                              <set_value name="$DistanceTable" exact="table[]"/>
                              <do_all exact="$Waypoints.count" counter="$i">
                                <!--TODO @Owen - improve selection by distance. Walk distance may actually be longer than direct distance-->
                                <set_value name="$DistanceTable.{$Waypoints.{$i}}" exact="$NPC.distanceto.{$Waypoints.{$i}}"/>
                              </do_all>
                              <set_value name="$DestinationSlot" exact="$DistanceTable.keys.sorted.{1}"/>
                              <!-- set_value name="$DestinationSlot" list="$Waypoints" / -->
                              <debug_text text="'DestinationSlot ' + $DestinationSlot" chance="$DebugChance" />
                            </do_if>
                          </do_if>
                        </do_if>
                        <do_if value ="not $DestinationSlot">
                          <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) trying to find a pickup location on the target ships dockingbay'" chance="$DebugChance" />
                          <do_if value="$NPC.$welder_ship">
                            <do_if value="$NPC.$welder_ship.dock">
                              <debug_text text="'welder ship dockingbay ' + $NPC.$welder_ship.dock.macro" chance="$DebugChance"/>
                              <find_npc_waypoint name="$DestinationSlot" object="$NPC.$welder_ship.dock" tags="tag.pickup_hole" />
                            </do_if>
                            <do_else>
                              <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) target ship does not have a dock'" chance="$DebugChance" />
                              <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                            </do_else>
                          </do_if>
                          <do_else>
                            <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) target ship does not exist'" chance="$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                          </do_else>
                        </do_if>
                        <do_if value="$DestinationSlot">
                          <debug_text text="'welder $NPC: ' + $NPC.name + ' $Destinationslot ' + $DestinationSlot" chance="$DebugChance"/>
                          <set_value name="this.$destinationslot" exact="$DestinationSlot" />
                          <include_actions ref="GetNextTargetPoint" />
                          <do_if value="this.$pathtable">
                            <set_value name="$pathtable" exact="this.$pathtable" />
                            <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_move_to_tool" />
                          </do_if>
                          <do_else>
                            <include_actions ref="MoveFailedHandling"/>
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_tool_action" />
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'Unable to find a pickup slot'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_welder_find_tool" ref="EXIT_Empty" />
                  </cues>
                </cue>

                <cue name="STATE_welder_move_to_tool">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_move_to_tool" ref="PerformPath">
                      <param name="NPC" value="$NPC" />
                      <param name="pathtable" value="$pathtable" />
                      <param name="signalcue" value="TRANSITION_welder_tool_action" />
                      <param name="DebugChance" value="$DebugChance" />
                    </cue>

                    <cue name="EXIT_welder_move_to_tool" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_welder_tool_action">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_welder_tool_action" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_welder_tool_action">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_tool_action">
                      <actions>
                        <do_if value="$DestinationSlot and $DestinationSlot.tags.indexof.{tag.pickup_locker}">
                          <debug_text text="'Pickup from Locker!'" chance="$DebugChance"/>
                          <do_if value="not $ToolInHand">
                            <set_value name="$AnimationType" exact="'tool_takeout_locker'" />
                          </do_if>
                          <do_elseif value="$ToolInHand">
                            <set_value name="$AnimationType" exact="'tool_putin_locker'" />
                          </do_elseif>
                          <trigger_animation object="$NPC.room" trigger="activate" />
                        </do_if>
                        <do_elseif value="$DestinationSlot and $DestinationSlot.tags.indexof.{tag.pickup_hole}">
                          <debug_text text="'Pickup from Hole!'" chance="$DebugChance"/>
                          <do_if value="not $ToolInHand">
                            <do_any>
                              <set_value name="$AnimationType" exact="'tool_quickpickup_ground'" weight="70" />
                              <set_value name="$AnimationType" exact="'tool_pickup_ground'" weight="30" />
                            </do_any>
                          </do_if>
                          <do_elseif value="$ToolInHand">
                            <set_value name="$AnimationType" exact="'tool_drop_ground'" />
                          </do_elseif>
                          <trigger_animation object="$NPC.room" group="'groundhatch'" trigger="activate" />
                        </do_elseif>
                        <do_else>
                          <debug_text text="'Pickup from unknwon location!'" chance="$DebugChance"/>
                        </do_else>
                        <debug_text text="'$AnimationType for tool interaction set to ' + $AnimationType" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="$AnimationType" transition="true" immediate="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <debug_text text="'Unable to start ' + $AnimationType + ' animation sequence for ' + $NPC.name + ' ({' + $NPC + '})'"  filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_welder_tool_action" ref="EXIT_Empty" />

                    <cue name="TRANSITION_welder_picked_up_tool_locker">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_locker_takeout'" />
                      </conditions>
                      <delay exact="1s"/>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is picking up a tool'" chance="$DebugChance" />
                        <!-- TODO @Lorraine: The way this is currently set up means that if the NPC stops crouched down to search for the tool before picking it up, it
                             appears in their hand before they are done searching. This is not easily solved by separating out the sequences for searching and non-searching,
                             more likely, here we have to make the decision to search or not, have an optional sequence for searching and wait for that to be fired if searching
                             was selected - or something along these lines -->
                        <do_if value="$ToolType" exact="'OneHand'">
                          <set_actor_tool actor="$NPC" name="'tool1hand'" />
                        </do_if>
                        <do_elseif value="$ToolType" exact="'TwoHand'">
                          <set_actor_tool actor="$NPC" name="'tool2hand'" />
                        </do_elseif>
                        <set_value name="$ToolInHand" exact="true" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_welder_dropped_tool_locker">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_locker_putin'" />
                      </conditions>
                      <delay exact="1s"/>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is dropping a tool'" chance="$DebugChance" />
                        <clear_actor_tool actor="$NPC" />
                        <set_value name="$ToolInHand" exact="false" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_welder_tool_action_locker_finished">
                      <conditions>
                        <check_any>
                          <event_character_animation_finished object="$NPC" id="'anim_locker_takeout'" />
                          <event_character_animation_finished object="$NPC" id="'anim_locker_putin'" />
                        </check_any>
                      </conditions>
                      <actions>
                        <trigger_animation object="$NPC.room" trigger="deactivate" />
                        <do_if value="not $ToolInHand">
                          <debug_text text="'Welder will reinitialise'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                        <do_else>
                          <debug_text text="'Welder has tool in hand, they should go and use it'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_welder_use_tool" />
                        </do_else>
                      </actions>
                    </cue>

                    <!-- Transitions -->
                    <cue name="TRANSITION_welder_picked_up_tool">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'tran_stand_toolcrouch_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is picking up a tool'" chance="$DebugChance" />
                        <!-- TODO @Lorraine: The way this is currently set up means that if the NPC stops crouched down to search for the tool before picking it up, it
                             appears in their hand before they are done searching. This is not easily solved by separating out the sequences for searching and non-searching,
                             more likely, here we have to make the decision to search or not, have an optional sequence for searching and wait for that to be fired if searching
                             was selected - or something along these lines -->
                        <do_if value="$ToolType" exact="'OneHand'">
                          <set_actor_tool actor="$NPC" name="'tool1hand'" />
                        </do_if>
                        <do_elseif value="$ToolType" exact="'TwoHand'">
                          <set_actor_tool actor="$NPC" name="'tool2hand'" />
                        </do_elseif>
                        <set_value name="$ToolInHand" exact="true" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_welder_dropped_tool">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'tran_toolstand_toolcrouch_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'NPC: ' + $NPC.name + ' ({' + $NPC + '}) is dropping a tool'" chance="$DebugChance" />
                        <clear_actor_tool actor="$NPC" />
                        <set_value name="$ToolInHand" exact="false" />
                        <debug_text text="'NPC now has tool in hand? ' + $ToolInHand" chance="$DebugChance" />
                      </actions>
                    </cue>

                    <cue name="TRANSITION_welder_tool_action_finished">
                      <conditions>
                        <check_any>
                          <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_toolstand_01'" />
                          <event_character_animation_finished object="$NPC" id="'tran_toolcrouch_stand_01'" />
                        </check_any>
                      </conditions>
                      <actions>
                        <trigger_animation object="$NPC.room" group="'groundhatch'" trigger="deactivate" />

                        <do_if value="not $ToolInHand">
                          <debug_text text="'Welder will reinitialise'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                        <do_else>
                          <debug_text text="'Welder has tool in hand, they should go and use it'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_welder_use_tool" />
                        </do_else>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>
            <!-- Welder using tool at ship. This includes moving to the position at the ship
            -->
            <cue name="STATE_welder_use_tool">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit actions -->
                <cue name="ENTER_welder_use_tool">
                  <actions>
                    <set_value name="$DestinationSlot" exact="null" />
                    <!-- Select which type of tool the NPC should use -->
                    <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will use the welding tool ' + $ToolType" chance="$DebugChance" />
                    <signal_cue_instantly cue="ChangeState" param="STATE_welder_find_position" />
                  </actions>
                </cue>

                <cue name="EXIT_welder_use_tool">
                  <conditions>
                    <event_cue_signalled cue="parent" />
                    <check_value value="@event.param == 'exit'" />
                  </conditions>
                  <actions>
                    <remove_value name="$DestinationSlot" />
                  </actions>
                </cue>
                <!-- Sub-states -->
                <cue name="STATE_welder_find_position">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_find_position">
                      <actions>
                        <do_if value="$NPC.$welder_ship">
                          <do_if value="$NPC.$welder_ship.dock">
                            <debug_text text="'welder ship dockingbay ' + $NPC.$welder_ship.dock.macro" chance="$DebugChance"/>
                            <find_npc_slot name="this.$destinationslot" object="$NPC.$welder_ship.dock" tags="tag.welder" excludefilled="true"/>
                            <debug_text text="'welder $destinationslot ' + this.$destinationslot" chance="$DebugChance"/>
                            <do_if value="this.$destinationslot">
                              <!-- calculate a position on the dockingbay -->
                              <find_actor_interaction_point posname="this.$destinationoffset" rotname="this.$destinationrotation" actor="$NPC" object="$NPC.$welder_ship" slot="this.$destinationslot"/>
                              <do_if value="this.$destinationoffset">
                                <debug_text text="'interaction point ' + this.$destinationoffset + ' * ' + this.$destinationrotation" chance="$DebugChance"/>
                                <debug_text text="'slot offset ' + this.$destinationslot.offset + ' * ' + this.$destinationslot.rotation" chance="$DebugChance"/>
                                <include_actions ref="GetNextTargetPoint" />
                                <do_if value="this.$pathtable">
                                  <set_value name="$pathtable" exact="this.$pathtable" />
                                  <debug_text text="'$pathtable.$targetoffset ' + $pathtable.$targetoffset" chance="$DebugChance"/>
                                  <set_value name="$pathtable.$speed" exact="[$NPC.walkspeed, $NPC.runspeed].random" />
                                  <signal_cue_instantly cue="ChangeState" param="STATE_welder_move_to_position" />
                                </do_if>
                                <do_else>
                                </do_else>
                              </do_if>
                              <do_else>
                                <include_actions ref="MoveFailedHandling"/>
                                <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                              </do_else>
                            </do_if>
                            <do_else>
                              <debug_text text="'Welding slot occupied'" chance="$DebugChance" />
                              <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                            </do_else>
                          </do_if>
                          <do_else>
                            <debug_text text="'Welder ship has no dock'" chance="$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'Unable to find the ship to weld'" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                        </do_else>
                      </actions>
                    </cue>

                    <cue name="EXIT_welder_find_position" ref="EXIT_Empty" />
                  </cues>
                </cue>

                <cue name="STATE_welder_move_to_position">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->

                    <cue name="ENTER_welder_move_to_position" ref="PerformPath">
                      <param name="NPC" value="$NPC" />
                      <param name="pathtable" value="$pathtable" />
                      <param name="signalcue" value="TRANSITION_welder_use_action" />
                      <param name="DebugChance" value="$DebugChance" />
                    </cue>

                    <cue name="EXIT_welder_move_to_position" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_welder_use_action">
                      <conditions>
                        <event_cue_signalled />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_welder_use_action" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_welder_use_action">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit actions -->
                    <cue name="ENTER_welder_use_action">
                      <actions>
                        <set_value name="$AnimationType" exact="'2htool_use'" />
                        <debug_text text="'$AnimationType for welding action set to ' + $AnimationType" chance="$DebugChance" />

                        <!-- trigger_animation object="$NPC.room" group="'groundhatch'" trigger="activate" / -->

                        <start_actor_sequence actor="$NPC" type="$AnimationType" behavior="'generic'" transition="false" immediate="false" result="this.$animationstarted" />
                        <!--
                        <do_if value="not this.$animationstarted">
                          <debug_text text="'Unable to start ' + $AnimationType + ' animation sequence for ' + $NPC.name + ' ({' + $NPC + '})'"  filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                        -->
                      </actions>
                    </cue>

                    <cue name="EXIT_welder_use_action" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_welder_use_action_finished">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_stand_conversation_01'" />
                      </conditions>
                      <actions>
                        <do_any>
                          <do_all weight="80">
                            <debug_text text="'welder finished using tool, move to another position'" chance="$DebugChance" />
                            <set_value name="$DestinationSlot" exact="null" />
                            <!-- Select which type of tool the NPC should use -->
                            <debug_text text="'$NPC: ' + $NPC.name + ' ({' + $NPC + '}) will use the welding tool ' + $ToolType" chance="$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_find_position" />
                          </do_all>
                          <do_all weight="20">
                            <debug_text text="'welder finished using tool, they should put it back'" chance="$DebugChance" />
                            <signal_cue_instantly cue="ChangeState" param="STATE_welder_with_tool" />
                          </do_all>
                        </do_any>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_airmarshal">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_airmarshal">
              <actions>
                <!-- set_value name="$DebugChance" exact="100" / -->
                <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                  <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_find"/>
                </do_if>
                <do_else>
                  <!--No dock assigned. Re-init, probably back to service behaviour-->
                  <remove_value name="$NPC.$airmarshal_dockingbay"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_airmarshal">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <!--<remove_value name="$JobDone"/>-->
                <do_if value="$AssignedShip?">
                  <remove_value name="$AssignedShip" />
                </do_if>
                <do_if value="$NPC.$airmarshal_dockingbay?">
                  <remove_value name="$NPC.$airmarshal_dockingbay" />
                </do_if>
                <do_if value="$Docking?">
                  <remove_value name="$Docking" />
                </do_if>
              </actions>
            </cue>

            <!--Transitions-->

            <!--Sub-states-->
            <cue name="STATE_airmarshal_find">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_find">
                  <actions>
                    <set_value name="this.$destinationslot" exact="null"/>
                    <do_if value="$NPC.roomslot and $NPC.roomslot.component == $NPC.$airmarshal_dockingbay and $NPC.roomslot.tags.indexof.{tag.airmarshal}">
                      <set_value name="this.$destinationslot" exact="$NPC.roomslot"/>
                    </do_if>

                    <do_if value="this.$destinationslot and not $NPC.isintransit">
                      <!--Already standing in a suitable slot-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moving_finished"/>
                    </do_if>
                    <do_else>
                      <find_npc_slot name="this.$destinationslot" object="$NPC.$airmarshal_dockingbay" tags="tag.airmarshal"/>
                      <do_if value="this.$destinationslot">
                        <!--Go to this.$destinationslot-->
                        <include_actions ref="GetNextTargetPoint"/>
                        <do_if value="this.$pathtable">
                          <set_value name="$pathtable" exact="this.$pathtable"/>
                          <do_if value="$NPC.room.parent.isclass.walkablemodule">
                            <set_value name="$pathtable.$speed" exact="$NPC.runspeed" />
                          </do_if>
                          <do_else>
                            <set_value name="$pathtable.$speed" exact="$NPC.walkspeed"/>
                          </do_else>
                          <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moving"/>
                        </do_if>
                        <do_else>
                          <include_actions ref="MoveFailedHandling"/>
                          <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moving_finished"/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <debug_text text="'$NPC ' + $NPC.knownname + ' ({' + $NPC + '}) unable to find an air marshal slot on ' + $NPC.$airmarshal_dockingbay.knownname + ' ({' + $NPC.$airmarshal_dockingbay + '}).'" filter="error"/>
                        <!--TODO @Owen wait a little while and try to find slot again-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_idle_stay"/>
                      </do_else>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_find" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_moving">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_moving" ref="PerformPath" comment="Movement helper library">
                  <param name="NPC" value="$NPC"/>
                  <param name="pathtable" value="$pathtable"/>
                  <param name="signalcue" value="TRANSITION_airmarshal_moving_finished"/>
                  <param name="DebugChance" value="$DebugChance"/>
                </cue>

                <cue name="EXIT_airmarshal_moving" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_airmarshal_moving_finished" instantiate="true">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moving_finished"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_moving_finished">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_moving_finished">
                  <actions>
                    <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                      <do_if value="$NPC.roomslot.tags.indexof.{tag.airmarshal}">
                        <!--Arrived at air marshaling position-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_standby"/>
                      </do_if>
                      <do_else>
                        <!--Should be at an airmarshal slot-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_find"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <!--Done with marshalling for now. Just idle at this point for a while-->
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_idle_stay"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_moving_finished" ref="EXIT_Empty"/>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_standby">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>

                <!-- Identify the ship that is docking / undocking -->
                <set_value name="$AssignedShip" exact="null" />
                <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                  <set_value name="$AssignedShip" exact="$NPC.$airmarshal_dockingbay.assignedship" />
                </do_if>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_standby">
                  <actions>
                    <do_if value="$NPC.attention lt attention.nearby">
                      <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="30s" />
                    </do_if>
                    <do_else>
                      <start_actor_sequence actor="$NPC" type="'marshalling_standby'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                      <do_if value="not this.$animationstarted">
                        <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                        <set_value name="$NpcLocation" exact="$NPC.container" />
                        <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                        <set_value name="$NPCAttention" exact="$NPC.attention" />

                        <set_value name="$PlayerLocation" exact="player.container" />
                        <do_if value="player.container.isclass.station">
                          <set_value name="$PlayerOnStation" exact="'is on'" />
                        </do_if>
                        <do_else>
                          <set_value name="$PlayerOnStation" exact="'is not on'" />
                        </do_else>

                        <debug_text text="'Unable to start marshalling_standby animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                      </do_if>

                      <do_elseif value="$AssignedShip and $AssignedShip.isclass.ship">
                        <debug_text text="'$AssignedShip is ' + $AssignedShip.knownname + ' with ID code ' + $AssignedShip.idcode + ' ({' + $AssignedShip + '})'" chance="$DebugChance" />
                        <debug_text text="'$NPC is ' + $NPC.knownname + ' ({' + $NPC + '})'" chance="$DebugChance" />

                        <!-- Checking these cases allows the air marshal to turn up late and known which state the $AssignedShip is in -->
                        <!-- Playership approaching -->
                        <do_if value="(($AssignedShip == player.ship and $NPC.$airmarshal_dockingbay.dockstate == dockstate.default) and not $AssignedShip.dock) and $AssignedShip.distanceto.{$NPC.$airmarshal_dockingbay} le 500m">
                          <debug_text text="'$AssignedShip (playership) is approaching station - swapping to dock state'" chance="$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'dock'" />
                          <!--As we've already signalled to identifygate, no need to have another cue doing it-->
                          <cancel_cue cue="TRANSITION_airmarshal_standby_identifygate_approachingship"/>
                        </do_if>

                        <!-- Approaching Case -->
                        <do_elseif value="($NPC.$airmarshal_dockingbay.dockstate == dockstate.default and not $AssignedShip.dock) and $AssignedShip.distanceto.{$NPC.$airmarshal_dockingbay} le 500m">
                          <debug_text text="'$AssignedShip is approaching station - swapping to identifygate state'" chance="$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'identifygate'" />
                          <!--As we've already signalled to identifygate, no need to have another cue doing it-->
                          <cancel_cue cue="TRANSITION_airmarshal_standby_identifygate_approachingship"/>
                        </do_elseif>

                        <!-- Docking Case -->
                        <do_elseif value="$NPC.$airmarshal_dockingbay.dockstate == dockstate.docking">
                          <debug_text text="'$AssignedShip is docking - swapping to docking state'" chance="$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'dock'" />
                        </do_elseif>

                        <!-- Docked Case -->
                        <do_elseif value="$NPC.$airmarshal_dockingbay.dockstate == dockstate.default and $AssignedShip.dock">
                          <debug_text text="'$AssignedShip is docked - swapping to idle state'" chance="$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" />
                        </do_elseif>

                        <!-- Undocking Case -->
                        <do_elseif value="$NPC.$airmarshal_dockingbay.dockstate == dockstate.undocking">
                          <debug_text text="'$AssignedShip is undocking - swapping to undocking state'" chance="$DebugChance" />
                          <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'undock'" />
                        </do_elseif>
                      </do_elseif>

                      <!-- Idle Case -->
                      <do_else>
                        <debug_text text="'There is currently no ship assigned to marshal for $NPC ' + $NPC.knownname + ' ({' + $NPC + '})'" chance="$DebugChance" />
                        <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="30s" />
                      </do_else>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_standby" ref="EXIT_Empty" />

                <!--Transitions-->
                <cue name="TRANSITION_airmarshal_standby_leave" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC"/>
                    <check_any>
                      <check_value value="event.param == 'npc_airmarshal' and event.param2 == 'leave'"/>
                      <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="@$DispatchTransitionStateChange">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_leave"/>
                    </do_if>
                    <do_else>
                      <include_actions ref="QueueTransitionRequest"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_standby_identifygate_approachingship" checkinterval="1s">
                  <conditions>
                    <check_value value="$AssignedShip and $AssignedShip.isoperational" />
                    <check_value value="$AssignedShip.distanceto.{$NPC.$airmarshal_dockingbay}" max="500m" />
                    <check_value value="not $AssignedShip.dock" />
                    <check_value value="$NPC.attention ge attention.nearby" />
                  </conditions>
                  <actions>
                    <debug_text text="'$AssignedShip is approaching station - signalling change to identifygate state'" chance="$DebugChance" />
                    <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'identifygate'" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_standby_identifygate" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC"/>
                    <check_any>
                      <check_value value="event.param == 'npc_airmarshal' and event.param2 == 'identifygate'"/>
                      <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="@$DispatchTransitionStateChange">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_identifygate"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'$AssignedShip is approaching station - requesting queued state change to identifygate state'" chance="$DebugChance" />
                      <include_actions ref="QueueTransitionRequest"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_standby_dock" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC"/>
                    <check_any>
                      <check_value value="event.param == 'npc_airmarshal' and event.param2 == 'dock'"/>
                      <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="@$DispatchTransitionStateChange">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'$AssignedShip is docking with station - requesting queued state change to dock state'" chance="$DebugChance" />
                      <include_actions ref="QueueTransitionRequest"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_standby_undock" instantiate="true">
                  <conditions>
                    <check_any>
                      <check_all>
                        <event_object_signalled object="$NPC"/>
                        <check_any>
                          <check_value value="event.param == 'npc_airmarshal' and event.param2 == 'undock'"/>
                          <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                        </check_any>
                      </check_all>
                      <check_all>
                        <event_object_started_to_undock_from container="$NPC.container" />
                        <check_value value="event.param.dock" exact="$NPC.$airmarshal_dockingbay" />
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <do_if value="@$DispatchTransitionStateChange">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_undock"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'$AssignedShip has undocked from station - requesting queued state change to undock state'" chance="$DebugChance" />
                      <include_actions ref="QueueTransitionRequest"/>
                    </do_else>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_identifygate">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit Actions -->
                <cue name="ENTER_airmarshal_identifygate">
                  <actions>
                    <debug_text text="'$NPC is signalling the bay at which ship should dock'" chance="$DebugChance" />
                    <start_actor_sequence actor="$NPC" type="'marshalling_identifygate'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                    <do_if value="not this.$animationstarted">
                      <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                      <set_value name="$NpcLocation" exact="$NPC.container" />
                      <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                      <set_value name="$NPCAttention" exact="$NPC.attention" />

                      <set_value name="$PlayerLocation" exact="player.container" />
                      <do_if value="player.container.isclass.station">
                        <set_value name="$PlayerOnStation" exact="'is on'" />
                      </do_if>
                      <do_else>
                        <set_value name="$PlayerOnStation" exact="'is not on'" />
                      </do_else>

                      <debug_text text="'Unable to start marshalling_identifygate animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_if>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_identifygate" ref="EXIT_Empty" />

                <!-- Transitions -->
                <cue name="TRANSITION_airmarshal_identifygate_dock" instantiate="true">
                  <conditions>
                    <event_object_started_to_dock_at container="$NPC.container" />
                    <check_value value="event.param.assigneddock" exact="$NPC.$airmarshal_dockingbay" />
                  </conditions>
                  <actions>
                    <debug_text text="'$AssignedShip is docking with station - changing to dock state'" chance="$DebugChance" />
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_dock">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
                <set_value name="$AssignedShip" exact="null" />
                <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                  <set_value name="$AssignedShip" exact="$NPC.$airmarshal_dockingbay.assignedship" />
                </do_if>
              </actions>
              <cues>
                <!-- Enter / Exit Actions -->
                <cue name="ENTER_airmarshal_dock">
                  <actions>
                    <debug_text text="'$NPC is signalling docking procedure'" chance="$DebugChance" />
                    <do_if value="$NPC.attention lt attention.nearby">
                      <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="30s" />
                    </do_if>
                    <do_else>
                      <do_if value="not $AssignedShip">
                        <!-- TODO (@Lorraine / @Owen): Continue to evaluate whether this is the best way of solving this problem -->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_leave"/>
                      </do_if>
                      <do_else>

                        <!-- "Set pose" to fall back to after each animation -->
                        <start_actor_sequence actor="$NPC" type="'marshalling_hover'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_hover animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                        <do_else>
                          <!-- ~~~~~~~~ ROTATION ~~~~~~~~ -->
                          <set_value name="$ShipAligned" exact="false" comment="True iff the ship is safely aligned with the dock, otherwise false. While ship is not aligned, we should only focus on alignment. Then, and only then, can we focus on actual ship position" />
                          <!-- Identify important connection rotations: rotation of connection on ship that will connect to dock when landed, rotation of connection on dock that will connect to ship when ship is landed, range in which ship should be to safely land -->
                          <set_value name="$ShipRot" exact="$AssignedShip.rotation" />
                          <set_value name="$DockRot" exact="$NPC.$airmarshal_dockingbay.dockslot.rotation" />
                          <set_value name="$MaxOffsetRot" exact="$NPC.$airmarshal_dockingbay.maxoffset.{$AssignedShip.docksize}.rotation" />

                          <!-- Calculate the difference between the ship's current and final rotation on pitch (x axis) and yaw (z-axis) -->
                          <do_if value="$DebugChance" min="100" comment="Extra debugging information">
                            <debug_text text="'$ShipRot - Yaw: ' + $ShipRot.yaw + ', Pitch: ' + $ShipRot.pitch" />
                            <debug_text text="'$DockRot - Yaw: ' + $DockRot.yaw + ', Pitch: ' + $DockRot.pitch" />
                            <debug_text text="'($MaxOffsetRot - Yaw: ' + $MaxOffsetRot.yaw + ', Pitch: ' + $MaxOffsetRot.pitch + ')'" />
                          </do_if>

                          <set_value name="$DeltaRotations" exact="table[]" />
                          <set_value name="$DeltaRotations.$Yaw" exact="$ShipRot.yaw - $DockRot.yaw" />
                          <set_value name="$DeltaRotations.$Pitch" exact="$ShipRot.pitch - $DockRot.pitch" />

                          <!-- ~~~~~~~~ POSITION ~~~~~~~~ -->
                          <!-- Identify important connection positions: Position of connection on ship that will connect to dock when landed, position of connection on dock that will connect to ship when ship is landed, range in which ship should be to safely land  -->
                          <set_value name="$ShipPos" exact="$AssignedShip.dockslot.offset" />
                          <set_value name="$DockPos" exact="$NPC.$airmarshal_dockingbay.dockslot.offset" />
                          <!-- Create new position for $ShipPos in $NPC.$airmarshal_dockingbay space so that we can see the ship's docking position relative to the docking bay's docking position -->
                          <create_position name="$RelativeShipPos" object="$AssignedShip" space="$NPC.$airmarshal_dockingbay" value="$ShipPos" />
                          <set_value name="$MaxOffsetPos" exact="$NPC.$airmarshal_dockingbay.maxoffset.{$AssignedShip.docksize}.position" />

                          <!-- Calculate the difference between the ship's current and final position on all three axes -->
                          <do_if value="$DebugChance" min="100" comment="Extra debugging information">
                            <debug_text text="'$RelativeShipPos - X: ' + $RelativeShipPos.x + ', Y: ' + $RelativeShipPos.y + ', Z: ' + $RelativeShipPos.z" />
                            <debug_text text="'$DockPos - X: ' + $DockPos.x + ', Y: ' + $DockPos.y + ', Z: ' + $DockPos.z" />
                            <debug_text text="'($MaxOffsetPos - X: ' + $MaxOffsetPos.x + ', Y: ' + $MaxOffsetPos.y + ', Z: ' + $MaxOffsetPos.z + ')'" />
                          </do_if>

                          <set_value name="$DeltaPositions" exact="table[]" />
                          <set_value name="$DeltaPositions.$X" exact="$RelativeShipPos.x - $DockPos.x" />
                          <set_value name="$DeltaPositions.$Z" exact="$RelativeShipPos.z - $DockPos.z" />
                          <set_value name="$DeltaPositions.$Y" exact="$RelativeShipPos.y - $DockPos.y" />

                          <!-- ~~~~~~~~ CALCULATION OF MOST CRITICAL AXIS TO SIGNAL ~~~~~~~~ -->
                          <set_value name="$LargestDeltaAxis" exact="null" />
                          <set_value name="$LargestDeltaValue" exact="0" />

                          <!-- Check to see whether ship is already safely aligned - if so, focus on position, otherwise focus on alignment -->
                          <set_value name="$CurrentRelYaw" exact="$DeltaRotations.$Yaw" />
                          <set_value name="$CurrentRelPitch" exact="$DeltaRotations.$Pitch" />
                          <do_if value="$CurrentRelYaw lt 0">
                            <set_value name="$CurrentRelYaw" exact="$CurrentRelYaw * -1" />
                          </do_if>
                          <do_if value="$CurrentRelPitch lt 0">
                            <set_value name="$CurrentRelPitch" exact="$CurrentRelPitch * -1" />
                          </do_if>
                          <do_if value="$CurrentRelYaw le $MaxOffsetRot.yaw and $CurrentRelPitch le $MaxOffsetRot.pitch">
                            <set_value name="$ShipAligned" exact="true" />
                          </do_if>

                          <!-- Focus on Alignment -->
                          <do_if value="not $ShipAligned">
                            <debug_text text="'$AssignedShip is not yet safely aligned with $NPC.$airmarshal_dockingbay - focusing on alignment'" chance="$DebugChance" />

                            <do_all exact="$DeltaRotations.keys.count" counter="$Counter">
                              <set_value name="$DeltaRotationAxis" exact="$DeltaRotations.keys.{$Counter}" />
                              <debug_text text="'$DeltaRotationAxis: ' + $DeltaRotationAxis" chance="$DebugChance" />

                              <set_value name="$DeltaRotationValue" exact="$DeltaRotations.{$DeltaRotationAxis}" />
                              <do_if value="$DeltaRotationValue lt 0">
                                <set_value name="$DeltaRotationValue" exact="$DeltaRotationValue * -1" />
                              </do_if>
                              <debug_text text="'$DeltaRotationValue: ' + $DeltaRotationValue" chance="$DebugChance" />

                              <!-- Compare the rotation value to the largest collected so far - if bigger, then we need to investigate further -->
                              <do_if value="$DeltaRotationValue gt $LargestDeltaValue">
                                <debug_text text="'$DeltaRotationValue is largest delta value so far'" chance="$DebugChance" />
                                <do_if value="$DeltaRotationAxis" exact="'$Yaw'">
                                  <set_value name="$MaxOffsetRotation" exact="$MaxOffsetRot.yaw" />
                                </do_if>
                                <do_elseif value="$DeltaRotationAxis" exact="'$Pitch'">
                                  <set_value name="$MaxOffsetRotation" exact="$MaxOffsetRot.pitch" />
                                </do_elseif>

                                <!-- Compare the rotation value to the safe offset range on same axis - if outside of this range, then this is the priority axis -->
                                <do_if value="$DeltaRotationValue gt $MaxOffsetRotation">
                                  <debug_text text="'$DeltaRotationValue is out of safe range - this is a priority axis'" chance="$DebugChance" />
                                  <set_value name="$LargestDeltaAxis" exact="$DeltaRotationAxis" />
                                  <set_value name="$LargestDeltaValue" exact="$DeltaRotationValue" />
                                </do_if>
                              </do_if>
                            </do_all>
                          </do_if>

                          <!-- Focus on Position -->
                          <do_else>
                            <debug_text text="'$AssignedShip is safely aligned with $NPC.$airmarshal_dockingbay - focusing on position'" chance="$DebugChance" />

                            <do_all exact="$DeltaPositions.keys.count" counter="$Counter">
                              <set_value name="$DeltaPositionAxis" exact="$DeltaPositions.keys.{$Counter}" />
                              <debug_text text="'$DeltaPositionAxis: ' + $DeltaPositionAxis" chance="$DebugChance" />

                              <set_value name="$DeltaPositionValue" exact="$DeltaPositions.{$DeltaPositionAxis}" />
                              <do_if value="$DeltaPositionValue lt 0">
                                <set_value name="$DeltaPositionValue" exact="$DeltaPositionValue * -1" />
                              </do_if>
                              <debug_text text="'$DeltaPositionValue: ' + $DeltaPositionValue" chance="$DebugChance" />

                              <!-- Compare the position value to the largest collected so far - if bigger, then we need to investigate further -->
                              <do_if value="$DeltaPositionValue gt $LargestDeltaValue">
                                <debug_text text="'$DeltaPositionValue is largest delta value so far'" chance="$DebugChance" />
                                <do_if value="$DeltaPositionAxis" exact="'$X'">
                                  <set_value name="$MaxOffsetPosition" exact="$MaxOffsetPos.x" />
                                </do_if>
                                <do_elseif value="$DeltaPositionAxis" exact="'$Z'">
                                  <set_value name="$MaxOffsetPosition" exact="$MaxOffsetPos.z" />
                                </do_elseif>
                                <do_elseif value="$DeltaPositionAxis" exact="'$Y'">
                                  <set_value name="$MaxOffsetPosition" exact="$MaxOffsetPos.y" />
                                </do_elseif>

                                <!-- Compare the rotation value to the safe offset range on same axis - if outside of this range, then this is the priority axis -->
                                <do_if value="$DeltaPositionValue gt $MaxOffsetPosition">
                                  <debug_text text="'$DeltaPositionValue is out of safe range - this is a priority axis'" chance="$DebugChance" />

                                  <!-- With position, we want to make sure the ship is in safe range on the XZ axis before we start signalling Y movement -->
                                  <do_if value="$DeltaPositionAxis" exact="'$Y'">
                                    <do_if value="$DeltaPositions.$X le $MaxOffsetPos.x and $DeltaPositions.$Z le $MaxOffsetPos.z">
                                      <debug_text text="'$DeltaPositionAxis is $Y and XZ Plane is within suitable range - position is vital'" chance="$DebugChance" />
                                      <set_value name="$PositionIsVital" exact="true" />
                                    </do_if>
                                    <do_else>
                                      <debug_text text="'$DeltaPositionAxis is $Y and XZ Plane is not in suitable range - position is not vital'" chance="$DebugChance" />
                                      <set_value name="$PositionIsVital" exact="false" />
                                    </do_else>
                                  </do_if>
                                  <do_else>
                                    <debug_text text="'$DeltaPositionAxis is not $Y - position is vital'" chance="$DebugChance" />
                                    <set_value name="$PositionIsVital" exact="true" />
                                  </do_else>

                                  <!-- If $PositionIsVital then this is a priority axis -->
                                  <do_if value="$PositionIsVital">
                                    <set_value name="$LargestDeltaAxis" exact="$DeltaPositionAxis" />
                                    <set_value name="$LargestDeltaValue" exact="$DeltaPositionValue" />
                                  </do_if>
                                </do_if>
                              </do_if>
                            </do_all>
                          </do_else>

                          <debug_text text="'After comparison, $LargestDeltaAxis: ' + @$LargestDeltaAxis + ' with value: ' + $LargestDeltaValue" chance="$DebugChance" />
                          <!-- If $LargestDeltaAxis is still null, ship is in an okay position to land -->
                          <do_if value="not $LargestDeltaAxis">
                            <set_value name="$MovementOrder" exact="STATE_airmarshal_land" />
                          </do_if>
                          <do_else>
                            <do_if value="$ShipAligned">
                              <set_value name="$ActualDelta" exact="$DeltaPositions.{$LargestDeltaAxis}" />
                            </do_if>
                            <do_else>
                              <set_value name="$ActualDelta" exact="$DeltaRotations.{$LargestDeltaAxis}" />
                            </do_else>
                            <debug_text text="'$ActualDelta: ' + $ActualDelta" chance="$DebugChance" />

                            <!-- If $LargestDeltaAxis is yaw, the ship has to turn left or right -->
                            <do_if value="$LargestDeltaAxis" exact="'$Yaw'">
                              <!-- turn left -->
                              <do_if value="$ActualDelta gt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_turnleft" />
                              </do_if>
                              <!-- turn right -->
                              <do_elseif value="$ActualDelta lt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_turnright" />
                              </do_elseif>
                            </do_if>

                            <!-- If $LargestDeltaAxis is pitch, the ship has to pitch up or down -->
                            <do_elseif value="$LargestDeltaAxis" exact="'$Pitch'">
                              <!-- pitch down -->
                              <do_if value="$ActualDelta gt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_pitchdown" />
                              </do_if>
                              <!-- pitch up -->
                              <do_elseif value="$ActualDelta lt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_pitchup" />
                              </do_elseif>
                            </do_elseif>

                            <!-- If $LargestDeltaAxis is on x-axis, the ship has to strafe left or right -->
                            <do_elseif value="$LargestDeltaAxis" exact="'$X'">
                              <!-- strafe left -->
                              <do_if value="$ActualDelta gt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_strafeleft" />
                              </do_if>
                              <!-- straight right -->
                              <do_elseif value="$ActualDelta lt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_straferight" />
                              </do_elseif>
                            </do_elseif>

                            <!-- If $LargestDeltaAxis is on z-axis, the ship has to move forwards or backwards -->
                            <do_elseif value="$LargestDeltaAxis" exact="'$Z'">
                              <!-- move backwards -->
                              <do_if value="$ActualDelta gt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_moveback" />
                              </do_if>
                              <!-- move forwards -->
                              <do_elseif value="$ActualDelta lt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_straightahead" />
                              </do_elseif>
                            </do_elseif>

                            <!-- If $LargestDeltaAxis is on y-axis, the ship has to strafe up or down -->
                            <do_else>
                              <!-- strafe down -->
                              <do_if value="$ActualDelta gt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_movedown" />
                              </do_if>
                              <!-- strafe up -->
                              <do_elseif value="$ActualDelta lt 0">
                                <set_value name="$MovementOrder" exact="STATE_airmarshal_dock_moveup" />
                              </do_elseif>
                            </do_else>
                          </do_else>

                          <!-- Trigger the right animation on the NPC -->
                          <debug_text text="'$NPC is telling $AssignedShip to ' + $MovementOrder" chance="$DebugChance" />
                          <signal_cue_instantly cue="ChangeState" param="$MovementOrder" />
                        </do_else>
                      </do_else>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_dock" ref="EXIT_Empty" />

                <!-- Transitions-->
                <cue name="TRANSITION_airmarshal_dock_straightahead" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'straightahead'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_straightahead" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_moveback" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'moveback'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moveback" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_movedown" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'movedown'" />
                  </conditions>
                  <actions>
                    <debug_text text="'TRANSITION FROM DOCK TO MOVEDOWN'" chance="$DebugChance" />
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_movedown" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_strafeleft" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'strafeleft'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_strafeleft" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_straferight" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'straferight'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_straferight" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_pitchup" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'pitchup'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_pitchup" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_pitchdown" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'pitchdown'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_pitchdown" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_turnleft" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'turnleft'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_turnleft" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_turnright" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'turnright'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_turnright" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_dock_land" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'land'" />
                  </conditions>
                  <actions>
                    <debug_text text="'TRANSITION FROM DOCK TO LAND'" chance="$DebugChance" />
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_land" />
                  </actions>
                </cue>

                <!-- Sub-States -->
                <cue name="STATE_airmarshal_straightahead">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_straightahead">
                      <actions>
                        <debug_text text="'$NPC is signalling that ship should move forwards'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_straightahead'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_straightahead animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_straightahead" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_straightahead_dock">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_straightahead_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_moveback">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmashaller_moveback">
                      <actions>
                        <debug_text text="'$NPC is signalling that ship should move backwards'" chance="$DebugChance" />
                        <!-- TODO (@Lorraine): Replace with correct sequence when animations arrive -->
                        <start_actor_sequence actor="$NPC" type="'marshalling_identifygate'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_moveback animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_moveback" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_moveback_dock">
                      <conditions>
                        <!-- TODO (@Lorraine): Replace with correct finishing animation when animations arrive -->
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_identifygate_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_movedown">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_movedown">
                      <actions>
                        <debug_text text="'$NPC is signalling that the ship should move down.'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_movedown'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_movedown animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_movedown" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_movedown_dock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_movedown_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'TRANSITION FROM MOVEDOWN TO DOCK'" chance="$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_dock_moveup">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_dock_moveup">
                      <actions>
                        <debug_text text="'$NPC is signalling that the ship should move up.'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_moveup'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_moveup animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_dock_moveup" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_dock_moveup_dock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_moveup_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'TRANSITION FROM MOVEUP TO DOCK'" chance="$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_strafeleft">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_strafeleft">
                      <actions>
                        <debug_text text="'$NPC is signalling that the ship should strafe left.'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_strafeleft'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_strafeleft animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_strafeleft" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_strafeleft_dock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_strafeleft_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_straferight">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_straferight">
                      <actions>
                        <debug_text text="'$NPC is signalling that the ship should strafe right.'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_straferight'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_straferight animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_straferight" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_straferight_dock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_straferight_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_pitchup">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_pitchup">
                      <actions>
                        <debug_text text="'$NPC is signalling that ship should pitch up'" chance="$DebugChance" />
                        <!-- TODO (@Lorraine): Replace with correct animations when they have been put in the game -->
                        <start_actor_sequence actor="$NPC" type="'marshalling_hover'" behavior="'generic'" transition="true" result="this.$animationstarted"/>
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_pitchup animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_pitchup" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_pitchup_dock" instantiate="true">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_marshal_hover_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_pitchdown">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_pitchdown">
                      <actions>
                        <debug_text text="'$NPC is signalling that ship should pitch down'" chance="$DebugChance" />
                        <!-- TODO (@Lorraine): Replace with correct animations when they have been put in the game -->
                        <start_actor_sequence actor="$NPC" type="'marshalling_hover'" behavior="'generic'" transition="true" result="this.$animationstarted"/>
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_pitchdown animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_pitchdown" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_pitchdown_dock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_hover_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_turnleft">
                  <conditions>
                    <event_cue_signalled/>
                    <check_value value="not @event.param"/>
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State"/>
                  </actions>
                  <cues>
                    <!--Enter / Exit actions-->
                    <cue name="ENTER_airmarshal_turnleft">
                      <actions>
                        <debug_text text="'$NPC is signalling that ship should turn left'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_turnleft'" behavior="'generic'" transition="true" result="this.$animationstarted"/>
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_turnleft animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_turnleft" ref="EXIT_Empty"/>

                    <!--Transitions-->
                    <cue name="TRANSITION_airmarshal_turnleft_dock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_turnleft_01'"/>
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_turnright">
                  <conditions>
                    <event_cue_signalled/>
                    <check_value value="not @event.param"/>
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State"/>
                  </actions>
                  <cues>
                    <!--Enter / Exit actions-->
                    <cue name="ENTER_airmarshal_turnright">
                      <actions>
                        <debug_text text="'$NPC is signalling that ship should turn right'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_turnright'" behavior="'generic'" transition="true" result="this.$animationstarted"/>
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_turnright animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_turnright" ref="EXIT_Empty"/>

                    <!--Transitions-->
                    <cue name="TRANSITION_airmarshal_turnright_dock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_turnright_01'"/>
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dock"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_land">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_land">
                      <actions>
                        <debug_text text="'$NPC is signalling that the ship should land.'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_land'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_land animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_land" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_land_dispatch" instantiate="true">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_marshal_land_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_dispatch" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_dispatch">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_dispatch">
                      <actions>
                        <debug_text text="'$NPC is dispatching the ship'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_dispatch'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_dispatch animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_dispatch" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_dispatch_standby" instantiate="true">
                      <conditions>
                        <event_character_animation_started object="$NPC" id="'anim_marshal_dispatch_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_standby" />
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_undock">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
                <set_value name="$AssignedShip" exact="null" />
                <do_if value="@$NPC.$airmarshal_dockingbay.exists">
                  <set_value name="$AssignedShip" exact="$NPC.$airmarshal_dockingbay.assignedship" />
                </do_if>
              </actions>
              <cues>
                <!-- Enter / Exit actions -->
                <cue name="ENTER_airmarshal_undock">
                  <actions>
                    <do_if value="$NPC.attention lt attention.nearby">
                      <signal_objects object="$NPC" param="'npc_airmarshal'" param2="'leave'" delay="30s" />
                    </do_if>
                    <do_else>
                      <debug_text text="'$NPC is signalling undocking procedure'" chance="$DebugChance" />
                      <start_actor_sequence actor="$NPC" type="'marshalling_hover'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                      <do_if value="not this.$animationstarted">
                        <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                        <set_value name="$NpcLocation" exact="$NPC.container" />
                        <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                        <set_value name="$NPCAttention" exact="$NPC.attention" />

                        <set_value name="$PlayerLocation" exact="player.container" />
                        <do_if value="player.container.isclass.station">
                          <set_value name="$PlayerOnStation" exact="'is on'" />
                        </do_if>
                        <do_else>
                          <set_value name="$PlayerOnStation" exact="'is not on'" />
                        </do_else>

                        <debug_text text="'Unable to start marshalling_hover animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                      </do_if>
                      <do_else>
                        <!-- TODO (@Lorraine): Improve undocking procedure -->
                        <!--<signal_objects object="$NPC" param="'npc_airmarshal'" param2="'moveup'" />-->
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moveup" />
                      </do_else>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_undock" ref="EXIT_Empty" />

                <!-- Transitions -->
                <cue name="TRANSITION_airmarshal_undock_startengines" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'startengines'" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_startengines" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_undock_moveup" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'npc_airmarshal'" param2="'moveup'" />
                  </conditions>
                  <actions>
                    <debug_text text="'TRANSITION FROM UNDOCK TO MOVEUP'" chance="$DebugChance" />
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_moveup" />
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_undock_standby" instantiate="true">
                  <conditions>
                    <event_object_undocked_from container="$NPC.container" />
                    <check_value value="event.param" exact="$AssignedShip" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_standby" />
                  </actions>
                </cue>

                <!-- Sub-states -->
                <cue name="STATE_airmarshal_startengines">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_startengines">
                      <actions>
                        <debug_text text="'$NPC is signalling that the ship should start engines'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_startengines'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_startengines animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_startengines" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_startengines_undock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_startengines_01'" />
                      </conditions>
                      <actions>
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_undock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="STATE_airmarshal_moveup">
                  <conditions>
                    <event_cue_signalled />
                    <check_value value="not @event.param" />
                  </conditions>
                  <actions>
                    <include_actions ref="Init_State" />
                  </actions>
                  <cues>
                    <!-- Enter / Exit Actions -->
                    <cue name="ENTER_airmarshal_moveup">
                      <actions>
                        <debug_text text="'$NPC is signalling that the ship should move up.'" chance="$DebugChance" />
                        <start_actor_sequence actor="$NPC" type="'marshalling_moveup'" behavior="'generic'" transition="true" result="this.$animationstarted" />
                        <do_if value="not this.$animationstarted">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_moveup animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                          <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                        </do_if>
                      </actions>
                    </cue>

                    <cue name="EXIT_airmarshal_moveup" ref="EXIT_Empty" />

                    <!-- Transitions -->
                    <cue name="TRANSITION_airmarshal_moveup_undock" instantiate="true">
                      <conditions>
                        <event_character_animation_finished object="$NPC" id="'anim_marshal_moveup_01'" />
                      </conditions>
                      <actions>
                        <debug_text text="'TRANSITION FROM LAND TO STANDBY'" chance="$DebugChance" />
                        <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_undock" />
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_leave">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_airmarshal_leave">
                  <actions>
                    <do_all chance="$DebugChance">
                      <set_value name="$AirMarshalDockingBay" exact="$NPC.$airmarshal_dockingbay" />
                    </do_all>
                    <remove_value name="$NPC.$airmarshal_dockingbay"/>

                    <debug_text text="'$NPC wants to go back to idling'" chance="$DebugChance" />
                    <do_if value="$NPC.attention ge attention.nearby">
                      <start_actor_sequence actor="$NPC" type="'marshalling_end'" behavior="'generic'" transition="true" result="this.$animationstarted"/>
                      <do_if value="not this.$animationstarted">
                        <do_all chance="$DebugChance">
                          <!-- DEBUG INFO TO TRACK DOWN ERRORS -->
                          <set_value name="$NpcLocation" exact="$NPC.container" />
                          <set_value name="$NPCAttention" exact="$NPC.attention" />

                          <set_value name="$PlayerLocation" exact="player.container" />
                          <do_if value="player.container.isclass.station">
                            <set_value name="$PlayerOnStation" exact="'is on'" />
                          </do_if>
                          <do_else>
                            <set_value name="$PlayerOnStation" exact="'is not on'" />
                          </do_else>

                          <debug_text text="'Unable to start marshalling_end animation sequence for ' + $NPC.knownname + ' ({' + $NPC + '}) - $NPC is in ' + $NPCAttention + ' and player ' + $PlayerOnStation + ' a station. - $PlayerLocation: ' + $PlayerLocation.knownname + ' ({' + $PlayerLocation + '}) - $NpcLocation: ' + $NpcLocation.knownname + ' ({' + $NpcLocation + '}) and $AirMarshalDockingBay: ' + $AirMarshalDockingBay.knownname + ' ({' + $AirMarshalDockingBay + '})'" filter="error" />
                        </do_all>
                        <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                      </do_if>
                      <!--Else, state change via TRANSITION_airmarshal_leave_reinit when animation ends-->
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                    </do_else>
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_leave" ref="EXIT_Empty"/>

                <cue name="TRANSITION_airmarshal_leave_reinit" instantiate="true">
                  <conditions>
                    <event_character_animation_finished object="$NPC" id="'anim_stand_conversation_01'"/>
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_init"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="STATE_airmarshal_idle_stay">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!-- Enter / Exit Actions -->
                <cue name="ENTER_airmarshal_idle_stay">
                  <actions>
                    <do_if value="$NPC.attention lt attention.nearby">
                      <set_value name="$staytime" min="1min" max="2min" />
                    </do_if>
                    <do_else>
                      <do_if value="$staytime?">
                        <set_value name="$staytime" min="5s" max="30s" />
                      </do_if>
                      <do_else>
                        <set_value name="$staytime" min="30s" max="60s" />
                      </do_else>
                    </do_else>
                    <signal_objects object="$NPC" param="'airmarshal_idle_stay__end'" delay="$staytime" />
                  </actions>
                </cue>

                <cue name="EXIT_airmarshal_idle_stay" ref="EXIT_Empty" />

                <!-- Transitions -->
                <cue name="TRANSITION_airmarshal_idle_stay_near" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'airmarshal_idle_stay__end'" />
                    <check_value value="$NPC.attention ge attention.nearby" />
                  </conditions>
                  <actions>
                    <include_actions ref="Validate_Usecase_Reservation"/>
                    <do_if value="@$UsecaseCue.exists">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_idle_stay" />
                    </do_if>
                    <do_elseif value="@$NPC.$airmarshal_dockingbay.exists">
                      <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_find" />
                    </do_elseif>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_init" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_airmarshal_idle_stay_distant" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'airmarshal_idle_stay__end'" />
                    <check_value value="$NPC.attention lt attention.nearby" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_airmarshal_idle_stay" />
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_prisoner">
          <conditions>
            <event_cue_signalled />
            <check_value value="not @event.param" />
          </conditions>
          <actions>
            <include_actions ref="Init_State" />
          </actions>
          <cues>
            <!-- Enter / Exit actions -->
            <cue name="EXIT_prisoner" ref="EXIT_Empty" />

            <!-- Transitions -->

            <!--event.param2 = table[
            $slot = Target slot (optional),
            $movementspeed = Movement speed (optional)]-->
            <cue name="TRANSITION_prisoner_escape" instantiate="true">
              <conditions>
                <event_object_signalled object="$NPC"/>
                <check_any>
                  <check_value value="event.param == 'escape_prison'"/>
                  <check_value value="event.param == staticbase" comment="Internal use. Parameters passed in the other case are now accessed by event.param2.{1} / .{2} / .{3}"/>
                </check_any>
              </conditions>
              <actions>
                <do_if value="@$DispatchTransitionStateChange">
                  <set_value name="STATE_despawn.$ParamTable" exact="event.param2"/>
                  <signal_cue_instantly cue="ChangeState" param="STATE_despawn"/>
                </do_if>
                <do_else>
                  <debug_text text="'$AssignedShip has undocked from station - requesting queued state change to undock state'" chance="$DebugChance" />
                  <include_actions ref="QueueTransitionRequest"/>
                </do_else>
              </actions>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_trader">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="EXIT_trader" ref="EXIT_Empty"/>
          </cues>
        </cue>

        <cue name="STATE_marine_guard">
          <conditions>
            <event_cue_signalled />
            <check_value value="not @event.param" />
          </conditions>
          <actions>
            <include_actions ref="Init_State" />
          </actions>
          <cues>
            <!-- Enter / Exit Actions -->
            <cue name="Enter_marine_guard">
              <actions>
                <do_if value="not $NPC.$role_object?">
                  <do_if value="$NPC.controllable.people.{$NPC.npctemplate}.exists">
                    <set_value name="$NPC.$role_object" exact="$NPC.controllable" />
                  </do_if>
                </do_if>
                <assert value="$NPC.role" text="'Entity does not have a role in this NPC state'" />
                <do_if value="$NPC.$role_object.exists">
                  <debug_text text="'$NPC.controllable ' + $NPC.controllable + '$NPC.$role_object ' + $NPC.$role_object" chance="$DebugChance" />
                  <do_if value="$NPC.controllable == $NPC.$role_object">
                    <do_if value="$NPC.roomslot and $NPC.roomslot.tags.indexof.{$NPC.role.tag}">
                      <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard_stay" />
                    </do_if>
                    <do_else>
                      <find_npc_slot name="$destinationslot" object="$NPC.$role_object" role="$NPC.role" />
                      <do_if value="$destinationslot">
                        <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment" />
                      </do_if>
                      <do_else>
                        <!-- No available room slot, despawn -->
                        <signal_cue_instantly cue="ChangeState" param="STATE_despawn" />
                      </do_else>
                    </do_else>
                  </do_if>
                  <do_else>
                    <!-- Not on-board object -->
                    <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment" />
                  </do_else>
                </do_if>
                <do_else>
                  <assert value="$NPC.$role_object.exists" text="'Entity does not know what object it has a role for. It is on board controllable ' + $NPC.controllable + ' ' + @NPC.controllable.knownname" />
                  <destroy_object object="$NPC" />
                </do_else>
              </actions>
            </cue>

            <cue name="EXIT_marine_guard">
              <conditions>
                <event_cue_signalled cue="parent" />
                <check_value value="@event.param == 'exit'" />
              </conditions>
              <actions>
                <do_if value="$staytime?">
                  <remove_value name="$staytime" />
                </do_if>
              </actions>
            </cue>

            <!-- Sub-states -->
            <cue name="STATE_marine_guard_stay">
              <conditions>
                <event_cue_signalled />
                <check_value value="not @event.param" />
              </conditions>
              <actions>
                <include_actions ref="Init_State" />
              </actions>
              <cues>
                <!--Allow usecases
                If the parent is signalled with 'check_can_allow_npc_usecase_reservation', evaluate if the state is currently allows being interrupted for a usecase
                Call Disallow_Usecase if there is a condition met where it is not currently possible e.g. the NPC is currently holding an item they HAVE to return-->
                <cue name="USECASE_CHECK_marine_guard_stay" instantiate="true">
                  <conditions>
                    <event_cue_signalled cue="parent"/>
                    <check_value value="@event.param == 'check_can_allow_npc_usecase_reservation'"/>
                  </conditions>
                  <actions>
                    <include_actions ref="Allow_Usecase"/>
                  </actions>
                </cue>

                <!-- Enter / Exit Actions -->
                <cue name="ENTER_marine_guard_stay">
                  <actions>
                    <do_if value="$NPC.attention lt attention.nearby">
                      <set_value name="$staytime" min="1min" max="2min" />
                    </do_if>
                    <do_else>
                      <do_if value="$staytime?">
                        <set_value name="$staytime" min="5s" max="30s" />
                      </do_if>
                      <do_else>
                        <set_value name="$staytime" min="30s" max="60s" />
                      </do_else>
                    </do_else>
                    <signal_objects object="$NPC" param="'marine_guard_stay__end'" delay="$staytime" />
                  </actions>
                </cue>

                <cue name="EXIT_marine_guard_stay" ref="EXIT_Empty" />

                <!-- Transitions -->
                <cue name="TRANSITION_marine_guard_stay_near" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'marine_guard_stay__end'" />
                    <check_value value="$NPC.attention ge attention.nearby" />
                  </conditions>
                  <actions>
                    <include_actions ref="Validate_Usecase_Reservation"/>
                    <do_if value="@$UsecaseCue.exists">
                      <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard_stay" />
                    </do_if>
                    <do_else>
                      <signal_cue_instantly cue="ChangeState" param="STATE_move_to_assignment" />
                    </do_else>
                  </actions>
                </cue>

                <cue name="TRANSITION_marine_guard_stay_distant" instantiate="true">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'marine_guard_stay__end'" />
                    <check_value value="$NPC.attention lt attention.nearby" />
                  </conditions>
                  <actions>
                    <signal_cue_instantly cue="ChangeState" param="STATE_marine_guard_stay" />
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <cue name="STATE_dockarea_movement_test">
          <conditions>
            <event_cue_signalled/>
            <check_value value="not @event.param"/>
          </conditions>
          <actions>
            <include_actions ref="Init_State"/>
          </actions>
          <cues>
            <!--Enter / Exit actions-->
            <cue name="ENTER_dockarea_movement_test">
              <actions>
                <signal_cue_instantly cue="ChangeState" param="STATE_dockarea_movement_test_stay"/>
              </actions>
            </cue>

            <cue name="EXIT_dockarea_movement_test">
              <conditions>
                <event_cue_signalled cue="parent"/>
                <check_value value="@event.param == 'exit'"/>
              </conditions>
              <actions>
                <do_if value="$staytime?">
                  <remove_value name="$staytime"/>
                </do_if>
              </actions>
            </cue>

            <!--Sub-states-->
            <cue name="STATE_dockarea_movement_test_stay">
              <conditions>
                <event_cue_signalled/>
                <check_value value="not @event.param"/>
              </conditions>
              <actions>
                <include_actions ref="Init_State"/>
              </actions>
              <cues>
                <!--Enter / Exit actions-->
                <cue name="ENTER_dockarea_movement_test_stay">
                  <actions>
                    <set_value name="$staytime" exact="1s"/>
                  </actions>
                  <cues>
                    <cue name="ENTER_dockarea_movement_test_stay_interrupt">
                      <delay exact="$staytime"/>
                      <actions>
                        <signal_objects object="$NPC" param="'dockarea_movement_test_stay__end'"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>

                <cue name="EXIT_dockarea_movement_test_stay" ref="EXIT_Empty"/>

                <!--Transitions-->
                <cue name="TRANSITION_dockarea_movement_test_attempt_move">
                  <conditions>
                    <event_object_signalled object="$NPC" param="'dockarea_movement_test_stay__end'"/>
                  </conditions>
                  <delay exact="10ms"/>
                  <actions>
                    <do_if value="$ProblematicSlot?">
                      <debug_text text="'NPC ' + $NPC"/>
                      <debug_text text="player.age + ' Testing movement to ' + $ProblematicSlot"/>
                      <do_if value="$NPC.roomslot">
                        <debug_text text="'start: ' + $NPC.roomslot + ' ' + $NPC.roomslot.component.knownname"/>
                      </do_if>
                      <do_else>
                        <debug_text text="'start: room ' + $NPC.parent + ' ' + $NPC.parent.knownname"/>
                      </do_else>
                      <debug_text text="'end: ' + $ProblematicSlot + ' ' + $ProblematicSlot.component.knownname"/>
                      <set_value name="this.$destinationslot" exact="$ProblematicSlot"/>
                      <!--<include_actions ref="GetNextTargetPoint"/>-->
                      <check_walk_path actor="$NPC" end="$ProblematicSlot" result="$WalkResult"/>
                      <do_if value="$WalkResult">
                        <debug_text text="'it finally worked'"/>
                      </do_if>
                      <do_else>
                        <debug_text text="'it still failed'"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <!-- set_value name="$DebugChance" exact="100"/ -->
                      <!--TODO @Owen find out why .dockarea isn't working in some cases-->
                      <set_value name="$DockArea" exact="null"/>
                      <set_value name="$Parent" exact="$NPC.parent"/>
                      <do_while value="$Parent">
                        <do_if value="$Parent.isclass.walkablemodule">
                          <set_value name="$DockArea" exact="$Parent"/>
                          <break/>
                        </do_if>
                        <set_value name="$Parent" exact="$Parent.parent"/>
                      </do_while>

                      <do_if value="$DockArea">
                        <find_object_component name="$DockingBays" object="$DockArea" multiple="true">
                          <match_dock storage="false" size="tag.dock_s"/>
                        </find_object_component>

                        <create_group groupname="this.$Ships"/>
                        <do_all exact="$DockingBays.count" counter="$i">
                          <debug_text text="'dock ' + $DockingBays.{$i}"/>
                          <do_if value="$DockingBays.{$i}.assignedship">
                            <add_to_group object="$DockingBays.{$i}.assignedship" groupname="this.$Ships"/>
                          </do_if>
                        </do_all>
                        <debug_text text="'ships ' + this.$Ships.count"/>
                        <set_value name="$ShipBackroomSlots" exact="[]"/>
                        <do_all exact="this.$Ships.count" counter="$i">
                          <find_npc_waypoint name="$ShipBackroomSlots" append="true" object="this.$Ships.{$i}" tags="tag.npctransport" multiple="true"/>
                        </do_all>
                        <find_npc_slot name="$DockAreaSlots" object="$DockArea" multiple="true"/>

                        <debug_text text="'Found ' + $ShipBackroomSlots.count + ' ship backroom waypoint slots'"/>
                        <debug_text text="'Found ' + $DockAreaSlots.count + ' dock area slots'"/>

                        <shuffle_list list="$ShipBackroomSlots"/>
                        <shuffle_list list="$DockAreaSlots"/>

                        <do_any>
                          <do_all>
                            <set_value name="$FirstList" exact="$ShipBackroomSlots"/>
                            <set_value name="$SecondList" exact="$DockAreaSlots"/>
                          </do_all>
                          <do_all>
                            <set_value name="$FirstList" exact="$DockAreaSlots"/>
                            <set_value name="$SecondList" exact="$ShipBackroomSlots"/>
                          </do_all>
                        </do_any>

                        <do_all exact="2" counter="$i">
                          <do_if value="$i == 1">
                            <set_value name="$List" exact="$FirstList"/>
                          </do_if>
                          <do_else>
                            <set_value name="$List" exact="$SecondList"/>
                          </do_else>

                          <do_all exact="$List.count" counter="$k">
                            <set_value name="this.$destinationslot" exact="$List.{$k}"/>
                            <do_if value="this.$destinationslot and not this.$destinationslot.tags.indexof.{tag.airmarshal}">
                              <include_actions ref="GetNextTargetPoint"/>
                              <do_if value="this.$pathtable">
                                <!--Clear and try the next one-->
                                <remove_value name="this.$pathtable"/>
                              </do_if>
                              <do_else>
                                <!--<assert value="false" text="player.age + ' Unable to find path from ' + (if $NPC.roomslot then $NPC.roomslot else $NPC.parent) + ' to destinationslot ' + this.$destinationslot + ' - NPC ' + $NPC + ' will repeat again and for debugging'" break="always"/>-->
                                <set_value name="$ProblematicSlot" exact="this.$destinationslot"/>
                                <include_actions ref="GetNextTargetPoint"/>
                                <!--Turning off output to save on state change spam-->
                                <set_value name="$DebugChance" exact="0"/>
                                <break/>
                              </do_else>
                            </do_if>
                          </do_all>
                        </do_all>

                        <do_if value="not $ProblematicSlot?">
                          <do_if value="$ShipBackroomSlots.count and $DockAreaSlots.count">
                            <do_any>
                              <set_value name="this.$NewSlot" exact="$ShipBackroomSlots.random"/>
                              <set_value name="this.$NewSlot" exact="$DockAreaSlots.random"/>
                            </do_any>
                          </do_if>
                          <do_elseif value="$ShipBackroomSlots.count">
                            <set_value name="this.$NewSlot" exact="$ShipBackroomSlots.random"/>
                          </do_elseif>
                          <do_elseif value="$DockAreaSlots.count">
                            <set_value name="this.$NewSlot" exact="$DockAreaSlots.random"/>
                          </do_elseif>

                          <debug_text text="'Warping NPC to new slot to try again. ' + this.$NewSlot"/>

                          <do_if value="this.$NewSlot">
                            <add_actor_to_room actor="$NPC" slot="this.$NewSlot"/>
                          </do_if>
                        </do_if>
                      </do_if>
                    </do_else>

                    <signal_cue_instantly cue="ChangeState" param="STATE_dockarea_movement_test"/>

                    <!--Standard tranition exit handling-->
                    <include_actions ref="Transition_Exit"/>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>


        <!--
        ##################
        Libraries
        ##################-->

        <!--Library to initialise a state, adding it to the $ActiveStates list and processing any queued transtion requests which may ultimatly result in ending this state-->
        <library name="Init_State">
          <actions>
            <append_to_list name="$ActiveStates" exact="this"/>
            <debug_text text="'Activated state ' + this" chance="$DebugChance"/>
            <debug_text text="'Currently active states are: ' + $ActiveStates" chance="$DebugChance"/>

            <!--If there is a request waiting, prepare to process it. The running state may request another state change, which may be ignored if non-critical and another request is waiting after a critical state-->
            <do_if value="$QueuedTransitionRequests.count">
              <signal_cue_instantly cue="QueuedStateChangeTrigger"/>
            </do_if>
          </actions>
        </library>

        <!--Library run when a state is initialising, marking it as a state which can allow a usecase to take this NPC.-->
        <library name="Allow_Usecase">
          <actions>
            <set_value name="parent.$AllowUsecaseReservation"/>
          </actions>
        </library>

        <!--Cue to signal to disallow usecase interrupts for a certain staterun when a state is initialising, marking it as a state which can allow a usecase to take this NPC.-->
        <library name="Disallow_Usecase">
          <actions>
            <set_value name="parent.$AllowUsecaseReservation" exact="false"/>
          </actions>
        </library>

        <library name="EXIT_Empty">
          <conditions>
            <event_cue_signalled cue="parent"/>
            <check_value value="@event.param == 'exit'"/>
          </conditions>
          <!--This doesn't do anything but currently helps keep STATE_ cues alive, as they would be cleaned up if they had no waiting sub-cues-->
        </library>

        <library name="State_Exit_Actions">
          <actions>
            <reset_cue cue="parent"/>
          </actions>
        </library>

        <library name="Transition_Exit">
          <actions>
            <!--No state change was requested. Reset this transition-->
            <do_if value="ChangeState.state == cuestate.waiting">
              <reset_cue cue="this"/>
            </do_if>
          </actions>
        </library>

        <!--If NPC is currently hidden, this.$startslot will be set, to be used as the spawning location-->
        <library name="CheckStartLocation">
          <actions>
            <do_if value="$NPC.ishidden">
              <debug_text text="'NPC is hidden. Finding a slot to have them appear at.'" chance="$DebugChance"/>
              <find_npc_waypoint name="this.$startslots" object="$NPC.room" tags="tag.npctransport" multiple="true"/>
              <debug_text text="'potential room startslots ' + this.$startslots" chance="$DebugChance"/>
              <do_if value="this.$destinationslot and this.$startslots.indexof.{this.$destinationslot}">
                <remove_value name="this.$startslots.{this.$startslots.indexof.{this.$destinationslot}}"/>
              </do_if>
              <do_if value="not this.$startslots.count">
                <find_npc_waypoint name="this.$startslots" object="$NPC.container" tags="tag.npctransport" multiple="true"/>
                <debug_text text="'potential object [' + $NPC.container + '] startslots ' + this.$startslots" chance="$DebugChance"/>
                <do_if value="this.$startslots.indexof.{this.$destinationslot}">
                  <remove_value name="this.$startslots.{this.$startslots.indexof.{this.$destinationslot}}"/>
                </do_if>
              </do_if>
              <do_if value="this.$startslots.count">
                <do_if value="this.$destinationslot">
                  <sort_list list="this.$startslots" sortbyvalue="this.$destinationslot.distanceto.{loop.element}" sortdescending="false"/>
                </do_if>
                <do_else>
                  <sort_list list="this.$startslots" sortbyvalue="$NPC.distanceto.{loop.element}" sortdescending="false"/>
                </do_else>
                <set_value name="this.$startslot" exact="this.$startslots.{1}"/>
              </do_if>
              <debug_text text="@this.$startslot + ' was selected as the start slot'" chance="$DebugChance"/>
            </do_if>
          </actions>
        </library>

        <!--result saved to this.$destinationslot-->
        <library name="FindLocalDespawnLocation">
          <actions>
            <find_npc_waypoint name="this.$destinationslot" object="$NPC.room" tags="tag.npctransport"/>
            <do_if value="not this.$destinationslot">
              <find_npc_waypoint name="this.$destinationslots" object="$NPC.container" tags="tag.npctransport" multiple="true"/>
              <do_if value="this.$destinationslots.count">
                <do_all exact="this.$destinationslots.count" counter="$destslotscounter">
                  <check_walk_path actor="$NPC" end="this.$destinationslots.{$destslotscounter}" result="$walkresult" checkstate="false"/>
                  <do_if value="$walkresult">
                    <set_value name="this.$destinationslot" exact="this.$destinationslots.{$destslotscounter}"/>
                    <break/>
                  </do_if>
                </do_all>
                <do_if value="not this.$destinationslot">
                  <set_value name="this.$destinationslot" exact="this.$destinationslots.random"/>
                </do_if>
              </do_if>
            </do_if>
            <do_if value="not this.$destinationslot">
              <debug_text text="'unable to find a place to despawn ' + $NPC + ' ' + $NPC.knownname" filter="error"/>
              <find_npc_slot name="this.$destinationslot" object="$NPC.room" tags="tag.npc_generic"/>
            </do_if>
          </actions>
        </library>

        <!--Requires this.$destinationslot to be set-->
        <library name="MoveFailedHandling">
          <actions>
            <!--<set_value name="$DebugChance" exact="100"/>-->
            <do_if value="this.$destinationslot">
              <debug_text text="player.age + ' Unable to find path from ' + (if $NPC.roomslot then $NPC.roomslot else $NPC.parent) + ' to destinationslot ' + this.$destinationslot + ' - NPC will disappear instantly.'" filter="error" chance="$DebugChance"/>
            </do_if>
            <do_else>
              <debug_text text="player.age + ' Unable to find path from ' + (if $NPC.roomslot then $NPC.roomslot else $NPC.parent) + ' to destination ' + this.$destinationcontext + ' ' + this.$destinationoffset + ' - NPC will disappear instantly.'" filter="error" chance="$DebugChance"/>
            </do_else>

            <!--Uncomment below line with DebugChange at 100 for a repeat attempt at pathing with output-->
            <!--<include_actions ref="GetNextTargetPoint"/>-->

            <do_if value="not @this.$destinationslot.tags.indexof.{tag.npc}">
              <clear_actor_roomslot actor="$NPC"/>
            </do_if>

            <do_if value="@this.$destinationslot.tags.indexof.{tag.npctransport}">
              <set_entity_traits entity="$NPC" hidden="true"/>
            </do_if>
            <do_else>
              <set_entity_traits entity="$NPC" hidden="false"/>
            </do_else>
            <!--TODO @Owen @Klaus Allow passing in null values for positions and rotations-->
            <do_if value="this.$destinationslot">
              <do_if value="this.$destinationoffset and this.$destinationrotation">
                <add_actor_to_room actor="$NPC" slot="this.$destinationslot">
                  <position value="this.$destinationoffset"/>
                  <rotation value="this.$destinationrotation"/>
                </add_actor_to_room>
              </do_if>
              <do_elseif value="this.$destinationoffset">
                <add_actor_to_room actor="$NPC" slot="this.$destinationslot">
                  <position value="this.$destinationoffset"/>
                </add_actor_to_room>
              </do_elseif>
              <do_elseif value="this.$destinationrotation">
                <add_actor_to_room actor="$NPC" slot="this.$destinationslot">
                  <rotation value="this.$destinationrotation"/>
                </add_actor_to_room>
              </do_elseif>
              <do_else>
                <add_actor_to_room actor="$NPC" slot="this.$destinationslot"/>
              </do_else>
            </do_if>
            <do_elseif value="this.$destinationoffset and this.$destinationcontext and this.$destinationcontextroom">
              <!--Warp to $destinationcontextroom at position $destinationoffset in coordinate space $destinationcontext-->
              <do_if value="this.$destinationrotation">
                <add_actor_to_room actor="$NPC" object="this.$destinationcontextroom">
                  <position value="this.$destinationoffset" object="this.$destinationcontext" space="this.$destinationcontextroom"/>
                  <rotation value="this.$destinationrotation"/>
                </add_actor_to_room>
              </do_if>
              <do_else>
                <add_actor_to_room actor="$NPC" object="this.$destinationcontextroom">
                  <position value="this.$destinationoffset" object="this.$destinationcontext" space="this.$destinationcontextroom"/>
                </add_actor_to_room>
              </do_else>
            </do_elseif>
            <do_else>
              <assert value="false" text="'Destination not defined correctly. Will not move NPC anywhere.'"/>
            </do_else>

            <do_if value="this.$destinationslot and this.$destinationslot.component.ischairslot.{this.$destinationslot}">
              <animate_chair slot="this.$destinationslot" actor="$NPC" chairtrigger="activate_chair"/>
            </do_if>
          </actions>
        </library>

        <!--TODO @Owen recognise ships docked in storage. Walk to elevator to despawn-->

        <!--Result saved to: this.$pathtable
        Requires EITHER
        this.$destinationslot (this.$destinationoffset and this.$destinationrotation are optional)
        OR
        this.$destinationcontext AND this.$destinationoffset AND this.$destinationcontextroom (this.$destinationrotation is optional)-->
        <library name="GetNextTargetPoint">
          <actions>
            <do_if value="not @this.$startslot">
              <debug_text text="'dont have a this.$startslot looking for one'" chance="$DebugChance"/>
              <include_actions ref="CheckStartLocation"/>
            </do_if>
            <do_else>
              <debug_text text="'already have a this.$startslot which is ' + this.$startslot" chance="$DebugChance"/>
            </do_else>

            <set_value name="this.$pathtable" exact="null"/>
            <set_value name="this.$LocalWaypointTagList" exact="[tag.npctransport, tag.ladder_top, tag.ladder_bottom]"/>
            <!--TODO @Owen object local waypoint cache?-->
            <!--Validate parameter types-->
            <do_if value="not @this.$destinationoffset">
              <set_value name="this.$destinationoffset" exact="null"/>
            </do_if>
            <do_elseif value="typeof this.$destinationoffset != datatype.position">
              <debug_text text="'Invalid position value this.$destinationoffset ' + this.$destinationoffset + ' - setting to null'" filter="error"/>
              <set_value name="this.$destinationoffset" exact="null"/>
            </do_elseif>
            <do_if value="not @this.$destinationrotation">
              <set_value name="this.$destinationrotation" exact="null"/>
            </do_if>
            <do_elseif value="typeof this.$destinationrotation != datatype.rotation">
              <debug_text text="'Invalid rotation value this.$destinationrotation ' + this.$destinationrotation + ' - setting to null'" filter="error"/>
              <set_value name="this.$destinationrotation" exact="null"/>
            </do_elseif>
            <do_if value="not @this.$destinationtags">
              <set_value name="this.$destinationtags" exact="null"/>
            </do_if>
            <do_elseif value="typeof this.$destinationtags != datatype.list">
              <debug_text text="'Invalid destinationtags value this.$destinationtags ' + this.$destinationtags + ' - setting to null'" filter="error"/>
              <set_value name="this.$destinationtags" exact="null"/>
            </do_elseif>
            <!--Validate that this.$destinationcontext exists and is provided with this.$destinationoffset and this.$destinationcontextroom, or this.$destinationslot was provided-->
            <do_if value="@this.$destinationcontext.exists and this.$destinationoffset and @this.$destinationcontextroom.exists">
              <assert value="not @this.$destinationslot" text="'destination slot ' + this.$destinationslot + ' was provided along with a context offset, clearing [Owen]'"/>
              <set_value name="this.$destinationslot" exact="null"/>
            </do_if>
            <do_else>
              <set_value name="this.$destinationcontext" exact="null"/>
              <set_value name="this.$destinationcontextroom" exact="null"/>
            </do_else>
            <assert value="this.$destinationslot or this.$destinationcontext" text="'destination is neither a slot nor a position [Owen]'"/>
            <assert value="not @this.$destinationslot.component.ischairslot.{this.$destinationslot} or not this.$destinationoffset" text="'Attempting to walk to a chair slot with an additional offset. Will probably interfere with the approach position, so ignoring. [Owen]'"/>
            <!--TODO @Owen look into this assert firing-->
            <!--<assert value="(this.$destinationslot.tags.indexof.{tag.airmarshal} != 0) == @$NPC.$airmarshal_dockingbay.exists" text="'non-airmarshal NPC trying to walk to airmarshal slot.'"/>-->
            <debug_text text="'NPC room is ' + $NPC.room + ' ' + $NPC.room.knownname + ' - Pos: ' + $NPC.position" chance="$DebugChance"/>
            <do_if value="this.$destinationslot or this.$destinationcontext">
              <!--this.$resolveddestinationcontext is a helper variable which is either this.$destinationcontext or the component of this.$destinationslot-->
              <set_value name="this.$resolveddestinationcontext" exact="null"/>
              <do_if value="this.$destinationslot">
                <!--Set this.$destinationwalkslot as the final slot walk checks should target. This prevents having to check further down if the destination is a chair slot with an approach slot.
                If an offset is provided, do not attempt to find a chair approach slot.-->
                <set_value name="this.$destinationwalkslot" exact="if this.$destinationoffset then this.$destinationslot else this.$destinationslot.component.chairapproachslot.{this.$destinationslot}"/>
                <do_if value="not this.$destinationwalkslot">
                  <set_value name="this.$destinationwalkslot" exact="this.$destinationslot"/>
                </do_if>
                <debug_text text="'Current NPC roomslot is ' + @$NPC.roomslot + ' looking for path to slot ' + this.$destinationslot + ' with the final slot to walk to being ' + this.$destinationwalkslot" chance="$DebugChance"/>
                <set_value name="this.$resolveddestinationcontext" exact="this.$destinationslot.component"/>
              </do_if>
              <do_else>
                <debug_text text="'Current NPC roomslot is ' + @$NPC.roomslot + ' looking for path to position ' + this.$destinationoffset + ' in context ' + this.$destinationcontext + ' ' + this.$destinationcontext.knownname" chance="$DebugChance"/>
                <set_value name="this.$resolveddestinationcontext" exact="this.$destinationcontext"/>
              </do_else>
              <do_if value="this.$resolveddestinationcontext.isclass.object">
                <set_value name="this.$resolveddestinationcontextobject" exact="this.$resolveddestinationcontext"/>
              </do_if>
              <do_else>
                <set_value name="this.$resolveddestinationcontextobject" exact="this.$resolveddestinationcontext.object"/>
              </do_else>
              <assert value="this.$resolveddestinationcontextobject" text="'Unable to resolve an object from ' + this.$resolveddestinationcontext + ' [Owen]'"/>
              <set_value name="this.$BaseSubTargetDefinition" exact="table[]"/>
              <do_if value="@this.$startslot">
                <set_value name="this.$BaseSubTargetDefinition.$targetslot" exact="this.$startslot" comment="the startslot may not be where the NPC currently is"/>
                <set_value name="this.$BaseSubTargetDefinition.$context" exact="this.$startslot.component"/>
              </do_if>
              <do_else>
                <set_value name="this.$BaseSubTargetDefinition.$targetslot" exact="null" comment="when null, use $NPC"/>
                <set_value name="this.$BaseSubTargetDefinition.$context" exact="$NPC.room.slotcontext"/>
              </do_else>

              <do_if value="@this.$destinationslot.tags.indexof.{tag.npc}">
                <!--$roomslot is a room slot which the NPC should reserve when walking towards it, those tagged as 'npc'-->
                <set_value name="this.$BaseSubTargetDefinition.$roomslot" exact="this.$destinationslot"/>
              </do_if>

              <do_if value="$NPC.attention lt attention.nearby">
                <!--Simply warp to the destination-->
                <!--TODO @Owen do we want NPCs to still take time?-->
                <set_value name="this.$pathtable" exact="this.$BaseSubTargetDefinition"/>
                <set_value name="this.$SubTargetDefinition" exact="table[]"/>
                <set_value name="this.$SubTargetDefinition.$context" exact="this.$resolveddestinationcontext"/>
                <set_value name="this.$SubTargetDefinition.$targetslot" exact="this.$destinationslot"/>
                <set_value name="this.$SubTargetDefinition.$targetoffset" exact="this.$destinationoffset"/>
                <set_value name="this.$SubTargetDefinition.$targetrotation" exact="this.$destinationrotation"/>
                <set_value name="this.$SubTargetDefinition.$targetroom" exact="this.$destinationcontextroom" comment="Only set when walking to a non-slot position"/>
                <set_value name="this.$SubTargetDefinition.$warp" exact="true"/>
                <do_all chance="$DebugChance">
                  <do_if value="this.$destinationslot">
                    <debug_text text="'NPC is in low attention and will warp to destinationslot ' + this.$SubTargetDefinition + ' of ' + this.$resolveddestinationcontext.knownname"/>
                  </do_if>
                  <do_else>
                    <debug_text text="'NPC is in low attention and will warp to position ' + this.$SubTargetDefinition + ' of ' + this.$resolveddestinationcontext.knownname"/>
                  </do_else>
                </do_all>
                <set_value name="this.$BaseSubTargetDefinition.$subdefinition" exact="this.$SubTargetDefinition"/>
                <remove_value name="this.$SubTargetDefinition"/>
              </do_if>
              <do_else>
                <!--Prepare the tables for use in the GetNextSubTargetPoint library-->
                <!--Note: this is not the place to check if the NPC can walk from A-B in an attempt to skip the pathing library. It does more e.g. chair actions-->
                <set_value name="this.$CommonContext" exact="$NPC.commoncontext.{this.$resolveddestinationcontext}"/>
                <set_value name="this.$ContainerEntryPoints" exact="[]"/>
                <set_value name="this.$SlotContainer" exact="null"/>
                <do_if value="this.$resolveddestinationcontext.isclass.container">
                  <set_value name="this.$SlotContainer" exact="this.$resolveddestinationcontext"/>
                </do_if>
                <do_else>
                  <set_value name="this.$SlotContainer" exact="this.$resolveddestinationcontext.container"/>
                </do_else>
                <!--TODO @Owen check what this should be set to-->
                <set_value name="this.$DestinationSlotContainer"/>
                <do_while value="this.$SlotContainer and this.$SlotContainer != $NPC.container and this.$SlotContainer != this.$CommonContext and this.$SlotContainer.hascontext.{this.$CommonContext}">
                  <!--Find transporters exiting the object and bottoms of ladders-->
                  <find_npc_waypoint name="this.$EntryPoints" object="this.$SlotContainer" tags="tag.npc_location_exit" multiple="true"/>
                  <find_npc_waypoint name="this.$EntryPoints" object="this.$SlotContainer" tags="tag.ladder_bottom" multiple="true" append="true"/>
                  <!--TODO @Owen - disabled until corrected-->
                  <do_if value="false and not this.$EntryPoints.count and this.$DestinationSlotContainer.hascontext.{this.$SlotContainer}">
                    <!--There are no entry points for this object which contains the destination object. Check if there are transporters which can be walked to from outside to reach the destination.
                    This may be a M ship with a cockpit reachable from outside. It may have a transporter also reachable from outside which is not tagged npc_location_exit-->
                    <find_npc_waypoint name="this.$EntryPoints" object="this.$SlotContainer" tags="tag.npctransport" multiple="true"/>
                  </do_if>
                  <do_if value="this.$EntryPoints.count">
                    <append_to_list name="this.$ContainerEntryPoints" exact="this.$EntryPoints"/>
                    <do_all exact="this.$EntryPoints.count" counter="$entrypoint_i" chance="$DebugChance">
                      <debug_text text="'Entry points for ' + this.$SlotContainer + ' ' + this.$SlotContainer.knownname + ' are ' + this.$EntryPoints"/>
                    </do_all>
                  </do_if>
                  <set_value name="this.$SlotContainer" exact="this.$SlotContainer.container"/>
                </do_while>
                <debug_text text="'Container entry points are: ' + this.$ContainerEntryPoints" chance="$DebugChance"/>
                <remove_value name="this.$SlotContainer"/>
                <remove_value name="this.$CommonContext"/>

                <set_value name="this.$TempSlotStorer" exact="[]" comment="List to store a sequence of slots when iterating over potential pashs. Used to prevent going backwards."/>
                <set_value name="this.$CheckedTransporterObjects" exact="[]" comment="List of objects which have already had exit transporters checked. Optimisation to prevent doing the same checks multiple times."/>
                <!--Create a list to contain tables for the variables of this library
                  Have to do this because it is recursive and they share the same variable context-->
                <assert value="not this.$SubTargetVariableList?" text="'$SubTargetVariableList was already defined which should not be the case for this library [Owen]'" break="1"/>
                <set_value name="this.$SubTargetVariableList" exact="[]"/>
                <set_value name="this.$SubTargetVariables" exact="table[]"/>
                <set_value name="this.$SubTargetVariables.$definition" exact="this.$BaseSubTargetDefinition"/>
                <append_to_list name="this.$SubTargetVariableList" exact="this.$SubTargetVariables"/>
                <do_if value="this.$SubTargetVariables.$definition.$targetslot">
                  <!-- if hidden and in teleporter cabin, first step is closing the door -->
                  <do_if value="$NPC.ishidden and this.$SubTargetVariables.$definition.$targetslot.group == tag.cabin_01">
                    <set_value name="this.$SubTargetVariables.$definition.$appearincabin" exact="true"/>
                  </do_if>
                  <do_else>
                    <!--If $targetslot is set for the base subtarget definition, it means the NPC will be warped there to start their path. Used when moving NPCs which were hidden.-->
                    <set_value name="this.$SubTargetVariables.$definition.$warp" exact="true"/>
                  </do_else>
                  <!--Add the start slot to the $TempSlotStorer to prevent the NPC finding it as a potential destination-->
                  <append_to_list name="this.$TempSlotStorer" exact="this.$SubTargetVariables.$definition.$targetslot"/>
                </do_if>
                <!--this.$SubTargetVariableList should now be:
                  [
                    element 1 = table
                      [
                        key: $definition = table
                          [
                            key: $context = Room or controllable
                            key: $targetslot = null or $startslot
                            key: $warp = true if $startslot is set (otherwise key does not exist)
                          ]                
                      ]
                  ]-->
                <include_actions ref="GetNextSubTargetPoint"/>


                <debug_text text="'End ' + this.$BaseSubTargetDefinition" chance="$DebugChance"/>
                <do_if value="this.$BaseSubTargetDefinition.$subdefinition?">
                  <set_value name="this.$pathtable" exact="this.$BaseSubTargetDefinition"/>
                  <!--Success-->
                  <debug_text text="'The path is: '" chance="$DebugChance"/>
                  <set_value name="this.$SubDef" exact="this.$BaseSubTargetDefinition"/>
                  <do_while value="this.$SubDef">
                    <do_if value="$DebugChance">
                      <set_value name="$DebugSubDef" exact="this.$SubDef.clone"/>
                      <set_value name="$DebugSubDef.$subdefinition" exact="null"/>
                      <debug_text text="$DebugSubDef" chance="$DebugChance"/>
                      <debug_text text="'slot: ' + if @this.$SubDef.$targetslot then this.$SubDef.$targetslot else 'the beginning'" chance="$DebugChance"/>
                    </do_if>
                    <set_value name="this.$SubDef" exact="@this.$SubDef.$subdefinition"/>
                  </do_while>
                  <remove_value name="this.$SubDef"/>
                </do_if>
                <remove_value name="this.$SubTargetVariableList"/>
                <do_if value="this.$SubTargetVariables?">
                  <remove_value name="this.$SubTargetVariables"/>
                </do_if>
                <remove_value name="this.$BaseSubTargetDefinition"/>
              </do_else>
            </do_if>
            <!-- debug_text text="'$pathtable: ' + this.$pathtable" chance="$DebugChance"/ -->
          </actions>
        </library>

        <!--
        Helper library which is called from GetNextTargetPoint and then calls itself recursivly to find a path
        Result added to: this.$SubTargetVariableList.{1}.$definition.$subdefinition
        Requires this.$SubTargetVariableList and this.$resolveddestinationcontext and (this.$destinationslot and this.$destinationwalkslot or this.$destinationcontext) to be set-->
        <library name="GetNextSubTargetPoint">
          <actions>
            <do_if value="(this.$destinationslot or this.$destinationcontext) and this.$SubTargetVariableList.{this.$SubTargetVariableList.count}.$definition">
              <!--Create and append a new table of variables for this iteration-->
              <set_value name="this.$SubTargetVariables" exact="table[]"/>
              <append_to_list name="this.$SubTargetVariableList" exact="this.$SubTargetVariables"/>
              <set_value name="this.$SubTargetVariables.$previousdefinition" exact="this.$SubTargetVariableList.{this.$SubTargetVariableList.count - 1}.$definition"/>
              <do_all chance="$DebugChance">
                <set_value name="$DebugIndent" exact="''"/>
                <do_all exact="this.$TempSlotStorer.count">
                  <set_value name="$DebugIndent" operation="add" exact="' '"/>
                </do_all>
              </do_all>
              <debug_text text="$DebugIndent + 'Trying to find next point from ' + this.$SubTargetVariables.$previousdefinition" chance="$DebugChance"/>
              <!--TODO @Owen deal with other non-animated chairs with the 'sit' tag-->
              <!-- Check if NPC is currently in a chair and has to get up -->
              <do_if value="not this.$NPC_IsSeated?">
                <set_value name="this.$NPC_IsSeated" exact="$NPC.currentchair != null"/>
                <debug_text text="$DebugIndent + 'NPC was sitting down. Will have to get up.'" chance="if this.$NPC_IsSeated then $DebugChance else 0"/>
              </do_if>
              <set_value name="this.$SubTargetVariables.$canwalk" exact="false"/>
              <assert value="not this.$SubTargetVariables.$previousdefinition.$targetslot or this.$SubTargetVariables.$previousdefinition.$targetslot.component == this.$SubTargetVariables.$previousdefinition.$context"
                      text="this.$SubTargetVariables.$previousdefinition.$targetslot.component + ' ' + this.$SubTargetVariables.$previousdefinition.$targetslot.component.knownname + ' is not ' + this.$SubTargetVariables.$previousdefinition.$context + ' ' + this.$SubTargetVariables.$previousdefinition.$context.knownname" break="always"/>
              
              <do_if value="this.$SubTargetVariables.$previousdefinition.$targetslot and not @this.$SubTargetVariables.$previousdefinition.$warp">
                <!--Check if the previous targetslot was a container entry point. If so, remove all container entry points for that object and any following objects-->
                <do_if value="this.$ContainerEntryPoints?">
                  <do_all exact="this.$ContainerEntryPoints.count" counter="$CEP_i">
                    <do_if value="this.$ContainerEntryPoints.{$CEP_i}.indexof.{this.$SubTargetVariables.$previousdefinition.$targetslot}">
                      <debug_text text="$DebugIndent + 'Container entry point was used. Disregarding all reamaining entry points on this level and precursor levels. ' + this.$ContainerEntryPoints.{$CEP_i}" chance="$DebugChance"/>
                      <clear_list list="this.$ContainerEntryPoints.{$CEP_i}"/>
                    </do_if>
                  </do_all>
                  <do_all exact="this.$ContainerEntryPoints.count" counter="$CEP_i" reverse="true">
                    <do_if value="this.$ContainerEntryPoints.{$CEP_i}.count == 0">
                      <remove_value name="this.$ContainerEntryPoints.{$CEP_i}"/>
                    </do_if>
                  </do_all>
                </do_if>
              </do_if>
              
              <do_if value="not this.$SubTargetVariables.$previousdefinition.$targetslot or @this.$SubTargetVariables.$previousdefinition.$warp">
                <!-- If there is no $targetslot either get out of the chair or check if the NPC can walk -->
                <do_if value="this.$NPC_IsSeated">
                  <!--Get out of the chair-->
                  <set_value name="this.$SubTargetVariables.$waypoints" exact="[$NPC.roomslot]"/>
                  <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                  <set_value name="this.$SubTargetVariables.$chair_disembarking" exact="true"/>
                </do_if>
                <do_else>
                  <!--If the previous definition had no $targetslot, check whether the NPC can walk to this.$destinationslot (or the approach chair position if $destinationslot is a chair)-->
                  <assert value="this.$SubTargetVariableList.count le 2" text="'Previous definition had no $targetslot and it was not the first path. This is not allowed. [Owen]'" break="1"/>
                  <do_if value="this.$destinationslot">
                    <do_if value="@this.$startslot">
                      <!--$startslot is only set when spawning the NPC at a slot. The walk path should be checked from that slot position, not the NPC's current position-->
                      <do_if value="this.$destinationoffset">
                        <check_walk_path actor="$NPC" start="this.$startslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                          <end value="this.$destinationoffset"/>
                        </check_walk_path>
                      </do_if>
                      <do_else>
                        <check_walk_path actor="$NPC" start="this.$startslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false"/>
                      </do_else>
                      <debug_text text="$DebugIndent + 'Checking walk from spawn slot ' + this.$startslot + ' to ' + this.$destinationwalkslot + ' offset ' + this.$destinationoffset" chance="$DebugChance"/>
                    </do_if>
                    <do_else>
                      <do_if value="this.$destinationoffset">
                        <check_walk_path actor="$NPC" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                          <end value="this.$destinationoffset"/>
                        </check_walk_path>
                      </do_if>
                      <do_else>
                        <check_walk_path actor="$NPC" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false"/>
                      </do_else>
                      <debug_text text="$DebugIndent + 'Checking walk from NPC position to ' + this.$destinationwalkslot + ' offset ' + this.$destinationoffset" chance="$DebugChance"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <!--Not a slot destination. this.$destinationcontext, this.$destinationoffset-->
                    <do_if value="@this.$startslot">
                      <check_walk_path actor="$NPC" start="this.$startslot" end="this.$destinationcontext" result="this.$SubTargetVariables.$canwalk" checkstate="false" destination="this.$destinationcontextroom" destinationtags="this.$destinationtags">
                        <end value="this.$destinationoffset"/>
                      </check_walk_path>
                      <debug_text text="$DebugIndent + 'Checking walk from start slot ' + this.$startslot + ' to position ' + this.$destinationoffset + ' of ' + this.$destinationcontext" chance="$DebugChance"/>
                    </do_if>
                    <do_else>
                      <check_walk_path actor="$NPC" end="this.$destinationcontext" result="this.$SubTargetVariables.$canwalk" checkstate="false" destination="this.$destinationcontextroom" destinationtags="this.$destinationtags">
                        <end value="this.$destinationoffset"/>
                      </check_walk_path>
                      <debug_text text="$DebugIndent + 'Checking walk from NPC position to postion ' + this.$destinationoffset + ' of ' + this.$destinationcontext" chance="$DebugChance"/>
                    </do_else>
                  </do_else>
                  <do_if value="not this.$SubTargetVariables.$canwalk">
                    <!--NPC can't walk directly from here.-->
                    <debug_text text="$DebugIndent + 'Cannot walk directly to destination.'" chance="$DebugChance"/>
                    <debug_text text="$DebugIndent + 'Looking for slots on ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' ' + this.$SubTargetVariables.$previousdefinition.$context" chance="$DebugChance"/>

                    <do_if value="@this.$SubTargetVariables.$previousdefinition.$warp">
                      <!--Flag that the NPC appeared by warping into position. This will allow them to use the slot they warped to as a transporter, if it is one, without pathing complaining that that slot is already in the path-->
                      <set_value name="this.$SubTargetVariables.$postwarp" exact="true"/>
                    </do_if>
                    <set_value name="this.$SubTargetVariables.$waypoints" exact="[]"/>

                    <!--TODO @Owen check if a walkable context exists at all before checking if you can walk to the entry points-->
                    <do_if value="this.$ContainerEntryPoints? and this.$ContainerEntryPoints.count">
                      <!--Check if they can walk to any of the container entry points-->
                      <do_all exact="this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.count" counter="$CEP_i">
                        <!--TODO @Owen sort by distance to NPC-->
                        <debug_text text="$DebugIndent + 'adding container entry point ' + this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i} + ' on ' + this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i}.component.knownname" chance="$DebugChance"/>
                        <append_to_list name="this.$SubTargetVariables.$waypoints" exact="this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i}"/>
                      </do_all>
                    </do_if>

                    <assert value="not this.$SubTargetVariables.$tempwaypoints?" text="'We are not expecting this to be set yet [Owen]'"/>
                    <do_if value="not this.$SubTargetVariables.$tempwaypoints?">
                      <set_value name="this.$SubTargetVariables.$tempwaypoints" exact="[]"/>
                    </do_if>
                    <do_if value="@this.$SubTargetVariables.$previousdefinition.$context.walkablemodule">
                      <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$SubTargetVariables.$previousdefinition.$context.walkablemodule" anytag="this.$LocalWaypointTagList" multiple="true" append="true"/>
                      <debug_text text="$DebugIndent + 'Finding waypoints on context dockarea ' + this.$SubTargetVariables.$previousdefinition.$context.walkablemodule.knownname + ' ' + this.$SubTargetVariables.$previousdefinition.$context.walkablemodule" chance="$DebugChance"/>
                    </do_if>
                    <do_elseif value="this.$SubTargetVariables.$previousdefinition.$context.isclass.room and @this.$SubTargetVariables.$previousdefinition.$context.dynamicinterior">
                      <!--If the previous slot was in a dynamic interior, take all of waypoints in the contained rooms into consideration-->
                      <debug_text text="'Finding waypoints in dynamic interior: ' + this.$SubTargetVariables.$previousdefinition.$context.dynamicinterior.knownname + ' ' + this.$SubTargetVariables.$previousdefinition.$context.dynamicinterior" chance="$DebugChance"/>
                      <set_value name="this.$NavContextRooms" exact="this.$SubTargetVariables.$previousdefinition.$context.dynamicinterior.rooms"/>
                      <do_all exact="this.$NavContextRooms.count" counter="$NCR_i">
                        <debug_text text="$DebugIndent + 'Finding waypoints in dynamic room: ' + this.$NavContextRooms.{$NCR_i}.knownname + ' ' + this.$NavContextRooms.{$NCR_i}" chance="$DebugChance"/>
                        <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$NavContextRooms.{$NCR_i}" anytag="this.$LocalWaypointTagList" multiple="true" append="true"/>
                      </do_all>
                      <remove_value name="this.$NavContextRooms"/>
                    </do_elseif>
                    <do_else>
                      <do_if value="this.$SubTargetVariables.$previousdefinition.$context != @this.$destinationslot.component and this.$SubTargetVariables.$previousdefinition.$context != this.$destinationcontext">
                        <!--HACK @Owen - if previous definition has a different context to the destination, do not allow cabins to be used. This led to people thinking they could use them as transporters to another object.-->
                        <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints_2" object="this.$SubTargetVariables.$previousdefinition.$context" anytag="this.$LocalWaypointTagList" multiple="true"/>
                        <debug_text text="'Finding non cabin waypoints on object ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' ' + this.$SubTargetVariables.$previousdefinition.$context" chance="$DebugChance"/>
                        <do_for_each name="$tempwp" in="this.$SubTargetVariables.$tempwaypoints_2">
                          <do_if value="$tempwp.group != tag.cabin_01">
                            <append_to_list name="this.$SubTargetVariables.$tempwaypoints" exact="$tempwp"/>
                          </do_if>
                        </do_for_each>
                      </do_if>
                      <do_else>
                        <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$SubTargetVariables.$previousdefinition.$context" anytag="this.$LocalWaypointTagList" multiple="true" append="true"/>
                        <debug_text text="'Finding waypoints on object ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' ' + this.$SubTargetVariables.$previousdefinition.$context" chance="$DebugChance"/>
                      </do_else>

                      <do_if value="this.$destinationslot">
                        <set_value name="this.$CommonContext" exact="this.$SubTargetVariables.$previousdefinition.$context.commoncontext.{this.$destinationslot.component}"/>
                      </do_if>
                      <do_else>
                        <set_value name="this.$CommonContext" exact="this.$SubTargetVariables.$previousdefinition.$context.commoncontext.{this.$destinationcontext}"/>
                      </do_else>
                      <do_if value="this.$CommonContext.isclass.walkablemodule or this.$CommonContext.isclass.controllable">
                        <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$CommonContext" anytag="this.$LocalWaypointTagList" multiple="true" append="true"/>
                        <debug_text text="'Finding waypoints on common context dockarea or object ' + this.$CommonContext.knownname + ' ' + this.$CommonContext" chance="$DebugChance"/>
                      </do_if>
                      <remove_value name="this.$CommonContext"/>
                    </do_else>

                    <do_if value="@this.$SubTargetVariables.$tempwaypoints.count">
                      <set_value name="this.$SubTargetVariables.$disttable" exact="table[]"/>
                      <do_all exact="this.$SubTargetVariables.$tempwaypoints.count" counter="$TWP_i">
                        <!--table where the key is the slot and the value is the distance-->
                        <set_value name="this.$SubTargetVariables.$disttable.{this.$SubTargetVariables.$tempwaypoints.{$TWP_i}}" exact="$NPC.distanceto.{this.$SubTargetVariables.$tempwaypoints.{$TWP_i}}"/>
                      </do_all>
                      <set_value name="this.$SubTargetVariables.$tempwaypoints" exact="this.$SubTargetVariables.$disttable.keys.sorted"/>
                      <do_all exact="this.$SubTargetVariables.$tempwaypoints.count" counter="$DIST_i">
                        <append_to_list name="this.$SubTargetVariables.$waypoints" exact="this.$SubTargetVariables.$tempwaypoints.{$DIST_i}"/>
                      </do_all>
                    </do_if>

                    <set_value name="this.$SubTargetVariables.$direct_walk" exact="true"/>
                  </do_if>
                  <!-- end if not $canwalk -->
                  <do_elseif value="@this.$destinationslot.component.ischairslot.{this.$destinationslot}">
                    <!--Can walk to a chair. Take care of sitting down-->
                    <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$destinationslot]"/>
                    <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                    <set_value name="this.$SubTargetVariables.$chair_approaching" exact="true"/>
                    <set_value name="this.$SubTargetVariables.$canwalk" exact="false"/>
                  </do_elseif>
                  <do_elseif value="this.$destinationslot and this.$destinationslot.tags.indexof.{tag.npctransport}">
                    <!--Walking into a transporter as destination-->
                    <debug_text text="$DebugIndent + 'destination is a transporter'" chance="$DebugChance"/>
                    <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$destinationslot]"/>
                    <set_value name="this.$SubTargetVariables.$approachingtransporter" exact="true"/>
                    <set_value name="this.$SubTargetVariables.$canwalk" exact="false"/>
                  </do_elseif>
                </do_else>
              </do_if>
              <!-- end has no $previousdefinition.$targetslot -->
              <!--
              #########
              LADDERS
              #########-->
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$climbingladder_down and
                        this.$SubTargetVariables.$previousdefinition.$targetslot.tags.indexof.{tag.ladder_top}">
                <!--Find bottom of the ladder-->
                <debug_text text="$DebugIndent + 'Looking for bottom of ladder on ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' ' + this.$SubTargetVariables.$previousdefinition.$context" chance="$DebugChance"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[]"/>
                <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$SubTargetVariables.$previousdefinition.$context" multiple="true"/>
                <do_while value="this.$SubTargetVariables.$tempwaypoints.count">
                  <do_if value="this.$SubTargetVariables.$tempwaypoints.{1}.tags.indexof.{tag.ladder_bottom}">
                    <assert value="this.$SubTargetVariables.$waypoints.count == 0" text="'More than one bottom of ladder found. We need a link between top and bottom. [Owen]'" break="1"/>
                    <append_to_list name="this.$SubTargetVariables.$waypoints" exact="this.$SubTargetVariables.$tempwaypoints.{1}"/>
                    <set_value name="this.$SubTargetVariables.$climbedladder_atbottom" exact="true"/>
                  </do_if>
                  <remove_value name="this.$SubTargetVariables.$tempwaypoints.{1}"/>
                </do_while>
                <assert value="this.$SubTargetVariables.$waypoints.count" text="'No bottom of ladder found to pair with ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' [Owen]'" break="1"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$climbingladder_up and
                            this.$SubTargetVariables.$previousdefinition.$targetslot.tags.indexof.{tag.ladder_bottom}">
                <!--Find top of the ladder-->
                <debug_text text="$DebugIndent + 'Looking for top of ladder on ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' ' + this.$SubTargetVariables.$previousdefinition.$context" chance="$DebugChance"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[]"/>
                <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$SubTargetVariables.$previousdefinition.$context" multiple="true"/>
                <do_while value="this.$SubTargetVariables.$tempwaypoints.count">
                  <do_if value="this.$SubTargetVariables.$tempwaypoints.{1}.tags.indexof.{tag.ladder_top}">
                    <assert value="this.$SubTargetVariables.$waypoints.count == 0" text="'More than one top of ladder found. We need a link between top and bottom. [Owen]'" break="1"/>
                    <append_to_list name="this.$SubTargetVariables.$waypoints" exact="this.$SubTargetVariables.$tempwaypoints.{1}"/>
                    <set_value name="this.$SubTargetVariables.$climbedladder_attop" exact="true"/>
                  </do_if>
                  <remove_value name="this.$SubTargetVariables.$tempwaypoints.{1}"/>
                </do_while>
                <assert value="this.$SubTargetVariables.$waypoints.count" text="'No top of ladder found to pair with ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' [Owen]'" break="1"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$climbedladder_atbottom and
                            this.$SubTargetVariables.$previousdefinition.$targetslot.tags.indexof.{tag.ladder_bottom} and 
                            this.$SubTargetVariables.$previousdefinition.$context.object">
                <do_if value="this.$destinationslot">
                  <debug_text text="$DebugIndent + '(climbeddown)Checking if NPC can walk from ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' to destination ' + this.$destinationwalkslot + ' offset: ' + this.$destinationoffset" chance="$DebugChance"/>
                  <do_if value="this.$destinationoffset">
                    <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                      <end value="this.$destinationoffset"/>
                    </check_walk_path>
                  </do_if>
                  <do_else>
                    <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false"/>
                  </do_else>
                </do_if>
                <do_else>
                  <debug_text text="$DebugIndent + '(climbeddown)Checking if NPC can walk from ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' to destination position ' + this.$destinationoffset + ' of ' + this.$destinationcontext" chance="$DebugChance"/>
                  <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationcontext" result="this.$SubTargetVariables.$canwalk" checkstate="false" destination="this.$destinationcontextroom" destinationtags="this.$destinationtags">
                    <end value="this.$destinationoffset"/>
                  </check_walk_path>
                </do_else>
                <debug_text text="$DebugIndent + '(climbedladder_atbottom)' + (if this.$SubTargetVariables.$canwalk then 'can walk to destination' else 'can not walk to destination')" chance="$DebugChance"/>
                <do_if value="not this.$SubTargetVariables.$canwalk">
                  <!--At the bottom after climbing down. Find slots on parent.-->
                  <debug_text text="$DebugIndent + 'At bottom of ladder. Looking for slots on object ' + this.$SubTargetVariables.$previousdefinition.$context.object.knownname + ' ' +  this.$SubTargetVariables.$previousdefinition.$context.object" chance="$DebugChance"/>
                  <set_value name="this.$SubTargetVariables.$waypoints" exact="[]"/>

                  <!--Add the container entry points first-->
                  <do_if value="this.$ContainerEntryPoints? and this.$ContainerEntryPoints.count">
                    <do_all exact="this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.count" counter="$CEP_i">
                      <debug_text text="$DebugIndent + 'adding container entry point ' + this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i} + ' on ' + this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i}.component.knownname" chance="$DebugChance"/>
                      <append_to_list name="this.$SubTargetVariables.$waypoints" exact="this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i}"/>
                    </do_all>
                  </do_if>

                  <!--Find elevator locations on the object the NPC just stepped on and sort by distance-->
                  <set_value name="this.$SubTargetVariables.$disttable" exact="table[]"/>
                  <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$SubTargetVariables.$previousdefinition.$context.object" tags="tag.npctransport" multiple="true"/>
                  <do_all exact="this.$SubTargetVariables.$tempwaypoints.count" counter="$TWP_i">
                    <set_value name="this.$SubTargetVariables.$disttable.{this.$SubTargetVariables.$tempwaypoints.{$TWP_i}}" exact="this.$SubTargetVariables.$previousdefinition.$targetslot.distanceto.{this.$SubTargetVariables.$tempwaypoints.{$TWP_i}}"/>
                  </do_all>
                  <append_list_elements name="this.$SubTargetVariables.$waypoints" other="this.$SubTargetVariables.$disttable.keys.sorted"/>

                  <set_value name="this.$SubTargetVariables.$direct_walk" exact="true"/>
                </do_if>
              </do_elseif>
              <!--
              #########
              TRANSPORTERS
              #########-->
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$enteringtransporter and
                            this.$SubTargetVariables.$previousdefinition.$targetslot.tags.indexof.{tag.npctransport}">
                <!--TODO @Owen If the destination is a npctransport slot on the same object, no need to look for an exit transporter-->
                <!--Look for NPC transporters to exit from on the object-->
                <set_value name="this.$SubTargetVariables.$exitingtransporter" exact="true"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[]"/>

                <set_value name="this.$SubTargetVariables.$ContextObject" exact="null"/>
                <do_if value="this.$SubTargetVariables.$previousdefinition.$context.isclass.object">
                  <set_value name="this.$SubTargetVariables.$ContextObject" exact="this.$SubTargetVariables.$previousdefinition.$context"/>
                </do_if>
                <do_else>
                  <set_value name="this.$SubTargetVariables.$ContextObject" exact="@this.$SubTargetVariables.$previousdefinition.$context.object"/>
                </do_else>
                <assert value="this.$SubTargetVariables.$ContextObject.exists" text="'Context of previous context definition ' + this.$SubTargetVariables.$previousdefinition.$context + ' ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' does not have an object [Owen]'"/>

                <!--TODO @Owen Ship docked on a capship docked at a station. NPC on station can't path to the small ship. Need to find if any object from the small ship is at the pier.-->
                <do_if value="this.$SubTargetVariables.$ContextObject">
                  <do_if value="this.$CheckedTransporterObjects.indexof.{this.$SubTargetVariables.$ContextObject}">
                    <debug_text text="$DebugIndent + ' Already checked for exit transporters on ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' ' + this.$SubTargetVariables.$ContextObject + ' - Aborting.'" chance="$DebugChance"/>
                  </do_if>
                  <do_else>
                    <debug_text text="$DebugIndent + 'Looking for transporters to exit on object ' + this.$SubTargetVariables.$ContextObject.knownname + ' ' + this.$SubTargetVariables.$ContextObject" chance="$DebugChance"/>
                    <find_npc_waypoint name="this.$SubTargetVariables.$waypoints" object="this.$SubTargetVariables.$ContextObject" tags="tag.npctransport" multiple="true"/>
                    <append_to_list name="this.$CheckedTransporterObjects" exact="this.$SubTargetVariables.$ContextObject"/>
                    <set_value name="this.$SubTargetVariables.$DynamicInterior" exact="if this.$resolveddestinationcontext.isclass.navcontext then this.$resolveddestinationcontext else @this.$resolveddestinationcontext.dynamicinterior"/>
                    <do_if value="this.$SubTargetVariables.$DynamicInterior and this.$resolveddestinationcontext.hascontext.{this.$SubTargetVariables.$ContextObject} and this.$resolveddestinationcontext.isprivate">
                      <debug_text text="$DebugIndent + 'Destination slot is in a private room. Try to find exit transporters within the dynamic interior ' + this.$SubTargetVariables.$DynamicInterior + ' ' + this.$SubTargetVariables.$DynamicInterior.knownname" chance="$DebugChance"/>
                      <set_value name="this.$SubTargetVariables.$NavContextRooms" exact="this.$SubTargetVariables.$DynamicInterior.rooms"/>
                      <do_all exact="this.$SubTargetVariables.$NavContextRooms.count" counter="$navcontext_i">
                        <debug_text text="$DebugIndent + 'Appening waypoints from room ' + this.$SubTargetVariables.$NavContextRooms.{$navcontext_i} + ' waypoint count was ' + this.$SubTargetVariables.$waypoints.count" chance="$DebugChance"/>
                        <find_npc_waypoint name="this.$SubTargetVariables.$waypoints" object="this.$SubTargetVariables.$NavContextRooms.{$navcontext_i}" tags="tag.npctransport" append="true" multiple="true"/>
                        <debug_text text="$DebugIndent + 'waypoint count was ' + this.$SubTargetVariables.$waypoints.count" chance="$DebugChance"/>
                      </do_all>
                    </do_if>
                    <remove_value name="this.$SubTargetVariables.$DynamicInterior"/>
                  </do_else>

                  <do_if value="this.$SubTargetVariables.$ContextObject.isclass.ship and @this.$SubTargetVariables.$ContextObject.dock.pier.object == this.$resolveddestinationcontextobject">
                    <find_npc_waypoint name="this.$SubTargetVariables.$waypoints" object="this.$resolveddestinationcontextobject" tags="tag.npctransport" multiple="true" append="true"/>
                    <debug_text text="$DebugIndent + 'NPC is leaving a ship docked at a pier of the destination. Dest obj: ' + this.$resolveddestinationcontextobject + ' ' + this.$resolveddestinationcontextobject.knownname + ' look for exit elevators on that object.'" chance="$DebugChance"/>
                  </do_if>
                  <do_elseif value="this.$resolveddestinationcontextobject.isclass.ship and @this.$resolveddestinationcontextobject.dock.pier and this.$resolveddestinationcontextobject.hascontext.{this.$SubTargetVariables.$ContextObject}">
                    <find_npc_waypoint name="this.$SubTargetVariables.$waypoints" object="this.$resolveddestinationcontextobject" tags="tag.npctransport" multiple="true" append="true"/>
                    <debug_text text="$DebugIndent + 'NPC is leaving ' + this.$SubTargetVariables.$ContextObject + ' ' + this.$SubTargetVariables.$ContextObject.knownname + ' for a ship ' + this.$resolveddestinationcontextobject + ' ' + this.$resolveddestinationcontextobject.knownname + ' docked at a pier. Look for exit elevators on the ship.'" chance="$DebugChance"/>
                  </do_elseif>
                </do_if>

                <do_if value="this.$SubTargetVariables.$waypoints.count">
                  <do_if value="this.$destinationslot">
                    <sort_list list="this.$SubTargetVariables.$waypoints" sortbyvalue="loop.element.distanceto.{this.$destinationslot}" sortdescending="false"/>
                  </do_if>
                  <do_else>
                    <!--Sort the distance between the component slot and the floor offset-->
                    <sort_list list="this.$SubTargetVariables.$waypoints" sortbyvalue="loop.element.distanceto.[this.$destinationcontext, this.$destinationoffset]" sortdescending="false"/>
                  </do_else>
                </do_if>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$exitingtransporter">
                <do_if value="this.$destinationslot">
                  <debug_text text="$DebugIndent + '(exitingtransporter)Checking if NPC can walk from exit transporter ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' to destination ' + this.$destinationwalkslot + ' offset ' + this.$destinationoffset" chance="$DebugChance"/>
                  <do_if value="this.$destinationoffset">
                    <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                      <end value="this.$destinationoffset"/>
                    </check_walk_path>
                  </do_if>
                  <do_else>
                    <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false"/>
                  </do_else>
                </do_if>
                <do_else>
                  <debug_text text="$DebugIndent + '(exitingtransporter)Checking if NPC can walk from exit transporter ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' to destination ' + this.$destinationcontext + ' offset ' + this.$destinationoffset" chance="$DebugChance"/>
                  <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationcontext" result="this.$SubTargetVariables.$canwalk" checkstate="false" destination="this.$destinationcontextroom" destinationtags="this.$destinationtags">
                    <end value="this.$destinationoffset"/>
                  </check_walk_path>
                </do_else>
                <debug_text text="$DebugIndent + '(exitingtransporter)' + (if this.$SubTargetVariables.$canwalk then 'can walk to destination' else 'can not walk to destination')" chance="$DebugChance"/>
                <do_if value="not this.$SubTargetVariables.$canwalk">
                  <!--Find slots on parent.-->
                  <!--TODO @Owen sort by distance-->
                  <debug_text text="$DebugIndent + 'At exit transporter of previous object. Looking for slots on new object ' + this.$SubTargetVariables.$previousdefinition.$context.object.knownname + ' ' +  this.$SubTargetVariables.$previousdefinition.$context.object" chance="$DebugChance"/>
                  <set_value name="this.$SubTargetVariables.$waypoints" exact="[]"/>

                  <!--Check if they can walk to any of the container entry points-->
                  <do_if value="this.$ContainerEntryPoints? and this.$ContainerEntryPoints.count">
                    <do_all exact="this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.count" counter="$CEP_i">
                      <debug_text text="$DebugIndent + 'adding container entry point ' + this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i} + ' on ' + this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i}.component.knownname" chance="$DebugChance"/>
                      <append_to_list name="this.$SubTargetVariables.$waypoints" exact="this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.{$CEP_i}"/>
                    </do_all>
                  </do_if>

                  <do_if value="this.$SubTargetVariables.$previousdefinition.$targetslot.tags.indexof.{tag.npc_location_exit}">
                    <!--NPC left an object via a transporter which leads off of the object to a dockarea. Check if you can walk to the destination, otherwise, a transporter on the dockarea. Very similar to the bottom of ladder case.-->
                    <find_npc_waypoint name="this.$SubTargetVariables.$waypoints" object="this.$SubTargetVariables.$previousdefinition.$context.object" tags="tag.npctransport" multiple="true" append="true"/>
                    <assert value="this.$SubTargetVariables.$previousdefinition.$context.object.exists" text="'Context of previous context definition ' + this.$SubTargetVariables.$previousdefinition.$context + ' ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' does not have an object [Owen]'"/>
                  </do_if>
                  
                  <sort_list list="this.$SubTargetVariables.$waypoints" sortbyvalue="this.$SubTargetVariables.$previousdefinition.$targetslot.distanceto.{loop.element}" sortdescending="false"/>
                  <set_value name="this.$SubTargetVariables.$direct_walk" exact="true"/>
                </do_if>
                <do_elseif value="@this.$destinationslot.component.ischairslot.{this.$destinationslot}">
                  <!--Can walk to a chair. Take care of sitting down-->
                  <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$destinationslot]"/>
                  <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                  <set_value name="this.$SubTargetVariables.$chair_approaching" exact="true"/>
                  <set_value name="this.$SubTargetVariables.$canwalk" exact="false"/>
                </do_elseif>
                <do_elseif value="this.$destinationslot and this.$destinationslot.tags.indexof.{tag.npctransport}">
                  <!--Walking into a transporter as destination-->
                  <debug_text text="$DebugIndent + 'destination is a transporter'" chance="$DebugChance"/>
                  <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$destinationslot]"/>
                  <set_value name="this.$SubTargetVariables.$approachingtransporter" exact="true"/>
                  <set_value name="this.$SubTargetVariables.$canwalk" exact="false"/>
                </do_elseif>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$approachingtransporter">
                <set_value name="this.$SubTargetVariables.$lockingtransporter" exact="true"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$SubTargetVariables.$previousdefinition.$targetslot]"/>
              </do_elseif>
              <!--
              #########
              CABIN
              #########-->
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$enteringcabin">
                <set_value name="this.$SubTargetVariables.$closingcabin" exact="true"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$SubTargetVariables.$previousdefinition.$targetslot]"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$appearincabin">
                <set_value name="this.$SubTargetVariables.$exitingcabin" exact="true"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$SubTargetVariables.$previousdefinition.$targetslot]"/>
              </do_elseif>
              <!--
              #########
              CHAIRS
              #########-->
              <!--Going to chairs-->
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$chair_walkto">
                <assert value="this.$SubTargetVariables.$previousdefinition.$context.ischairslot.{this.$SubTargetVariables.$previousdefinition.$targetslot} or this.$SubTargetVariables.$previousdefinition.$targetslot.tags.indexof.{tag.tochair}" text="'target not a chair slot [Owen]'" break="1"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$SubTargetVariables.$previousdefinition.$targetslot]"/>
                <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                <set_value name="this.$SubTargetVariables.$chair_sitdown" exact="true"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$chair_sitdown">
                <assert value="this.$SubTargetVariables.$previousdefinition.$context.ischairslot.{this.$SubTargetVariables.$previousdefinition.$targetslot}" text="'target not a chair slot [Owen]'" break="1"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$SubTargetVariables.$previousdefinition.$targetslot]"/>
                <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                <set_value name="this.$SubTargetVariables.$chair_rotateforward" exact="true"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$chair_rotateforward">
                <assert value="this.$SubTargetVariables.$previousdefinition.$context.ischairslot.{this.$SubTargetVariables.$previousdefinition.$targetslot}" text="'target not a chair slot [Owen]'" break="1"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$SubTargetVariables.$previousdefinition.$targetslot]"/>
                <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                <set_value name="this.$SubTargetVariables.$chair_facingforward" exact="true"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$chair_facingforward">
                <!--Facing forward in a chair. End of path.-->
                <assert value="this.$SubTargetVariables.$previousdefinition.$context.ischairslot.{this.$SubTargetVariables.$previousdefinition.$targetslot}" text="'target not a chair slot [Owen]'" break="1"/>
                <set_value name="this.$SubTargetVariables.$finishedchair" exact="true"/>
              </do_elseif>
              <!--Getting up from chairs-->
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$chair_rotatebackward">
                <assert value="this.$SubTargetVariables.$previousdefinition.$context.ischairslot.{this.$SubTargetVariables.$previousdefinition.$targetslot}" text="'target not a chair slot [Owen]'" break="1"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$SubTargetVariables.$previousdefinition.$targetslot]"/>
                <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                <set_value name="this.$SubTargetVariables.$chair_getup" exact="true"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$previousdefinition.$chair_getup">
                <assert value="this.$SubTargetVariables.$previousdefinition.$context.ischairslot.{this.$SubTargetVariables.$previousdefinition.$targetslot}" text="'target not a chair slot [Owen]'" break="1"/>
                <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$SubTargetVariables.$previousdefinition.$targetslot]"/>
                <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                <set_value name="this.$SubTargetVariables.$chair_leave" exact="true"/>
              </do_elseif>
              <!--
              #########
              FINAL WALK CHECK
              #########-->
              <do_else>
                <do_if value="@this.$SubTargetVariables.$previousdefinition.$chair_leave">
                  <set_value name="this.$chairleftslot" exact="this.$SubTargetVariables.$previousdefinition.$targetslot.component.chairapproachslot.{this.$SubTargetVariables.$previousdefinition.$targetslot}"/>
                  <do_if value="this.$chairleftslot">
                    <do_if value="this.$destinationslot">
                      <debug_text text="$DebugIndent + '(leavechair)Checking if NPC can walk from seat approach slot ' + this.$chairleftslot + ' to destination ' + this.$destinationwalkslot + ' offset ' + this.$destinationoffset" chance="$DebugChance"/>
                      <do_if value="this.$destinationoffset">
                        <check_walk_path actor="$NPC" start="this.$chairleftslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                          <end value="this.$destinationoffset"/>
                        </check_walk_path>
                      </do_if>
                      <do_else>
                        <check_walk_path actor="$NPC" start="this.$chairleftslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false"/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="$DebugIndent + '(leavechair)Checking if NPC can walk from seat approach slot ' + this.$chairleftslot + ' to destination ' + this.$destinationcontext + ' offset ' + this.$destinationoffset" chance="$DebugChance"/>
                      <check_walk_path actor="$NPC" start="this.$chairleftslot" end="this.$destinationcontext" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                        <end value="this.$destinationoffset"/>
                      </check_walk_path>
                    </do_else>
                  </do_if>
                  <do_else>
                    <debug_text text="$DebugIndent + 'Chair ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' has no approach slot. NPC will estimate path from 1 meter behind chair'" chance="$DebugChance"/>
                    <do_if value="this.$destinationslot">
                      <do_if value="this.$destinationoffset">
                        <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                          <start z="-1m"/>
                          <end value="this.$destinationoffset"/>
                        </check_walk_path>
                      </do_if>
                      <do_else>
                        <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                          <start z="-1m"/>
                        </check_walk_path>
                      </do_else>
                    </do_if>
                    <do_else>
                      <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationcontext" result="this.$SubTargetVariables.$canwalk" checkstate="false" destination="this.$destinationcontextroom" destinationtags="this.$destinationtags">
                        <start z="-1m"/>
                        <end value="this.$destinationoffset"/>
                      </check_walk_path>
                    </do_else>
                  </do_else>
                  <remove_value name="this.$chairleftslot"/>
                </do_if>
                <do_elseif value="this.$destinationslot">
                  <!--Can the NPC walk from the $previousdefinition.$targetslot to this.$destinationslot?-->
                  <debug_text text="$DebugIndent + '(prevslot)Checking if NPC can walk from ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' to destination ' + this.$destinationwalkslot" chance="$DebugChance"/>
                  <do_if value="this.$destinationoffset">
                    <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false">
                      <end value="this.$destinationoffset"/>
                    </check_walk_path>
                  </do_if>
                  <do_else>
                    <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationwalkslot" result="this.$SubTargetVariables.$canwalk" checkstate="false"/>
                  </do_else>
                </do_elseif>
                <do_else>
                  <!--Can the NPC walk from the $previousdefinition.$targetslot to [this.$destinationcontext, this.$destinationoffset]?-->
                  <debug_text text="$DebugIndent + '(prevslot)Checking if NPC can walk from ' + this.$SubTargetVariables.$previousdefinition.$targetslot + ' to destination ' + this.$destinationcontext + ' ' + this.$destinationcontext.knownname" chance="$DebugChance"/>
                  <check_walk_path actor="$NPC" start="this.$SubTargetVariables.$previousdefinition.$targetslot" end="this.$destinationcontext" result="this.$SubTargetVariables.$canwalk" checkstate="false" destination="this.$destinationcontextroom" destinationtags="this.$destinationtags">
                    <end value="this.$destinationoffset"/>
                  </check_walk_path>
                </do_else>
                <!-- Determined if the NPC can directly walk to destination! -->
                <debug_text text="$DebugIndent + '(finalwalkcheck)' + (if this.$SubTargetVariables.$canwalk then 'can walk to destination' else 'can not walk to destination')" chance="$DebugChance"/>
                <do_if value="this.$SubTargetVariables.$canwalk">
                  <do_if value="this.$destinationslot and this.$destinationslot.component.ischairslot.{this.$destinationslot}">
                    <!--Walking to a chair. There were no previous actions related to this chair-->
                    <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$destinationslot]"/>
                    <set_value name="this.$SubTargetVariables.$perform_chair_action" exact="true"/>
                    <set_value name="this.$SubTargetVariables.$chair_approaching" exact="true"/>
                    <set_value name="this.$SubTargetVariables.$canwalk" exact="false"/>
                  </do_if>
                  <do_elseif value="this.$destinationslot and this.$destinationslot.group == tag.cabin_01">
                    <!--Walking into a cabin-->
                    <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$destinationslot]"/>
                    <set_value name="this.$SubTargetVariables.$enteringcabin" exact="true"/>
                    <set_value name="this.$SubTargetVariables.$canwalk" exact="false"/>
                  </do_elseif>
                  <do_elseif value="this.$destinationslot and this.$destinationslot.tags.indexof.{tag.npctransport}">
                    <!--Walking into a transporter-->
                    <debug_text text="$DebugIndent + 'destination is transporter'" chance="$DebugChance"/>
                    <set_value name="this.$SubTargetVariables.$waypoints" exact="[this.$destinationslot]"/>
                    <set_value name="this.$SubTargetVariables.$approachingtransporter" exact="true"/>
                    <set_value name="this.$SubTargetVariables.$canwalk" exact="false"/>
                  </do_elseif>
                  <do_else>
                    <debug_text text="$DebugIndent + 'destination not known case -1b-'" chance="$DebugChance"/>
                  </do_else>
                </do_if>
                <do_else>
                  <do_if value="@this.$ContainerEntryPoints.count">
                    <!--Check if they can walk to any of the container entry points-->
                    <!--TODO @Owen sort by distance to $previousdefinition.$targetslot-->
                    <debug_text text="$DebugIndent + 'adding all container entrypoints for evaluation ' + this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}" chance="$DebugChance"/>
                    <set_value name="this.$SubTargetVariables.$waypoints" exact="this.$ContainerEntryPoints.{this.$ContainerEntryPoints.count}.clone"/>
                  </do_if>
                  <do_else>
                    <set_value name="this.$SubTargetVariables.$waypoints" exact="[]"/>
                  </do_else>
                  <!--If moving from a npc_waypoint, do not try to move to another waypoint. Cases such as elevator > elevator or bottom of ladder > top of ladder must be handled in their own explicit case above.
                  Example of this being stupid. Trying to walk directly to a NPC position on a dockingbay but walking from one pickup location to another along the way.
                  The only exception is if the previous $targetslot was the $startslot, which means the NPC spawned at a waypoint e.g. an elevator-->
                  <do_if value="this.$SubTargetVariables.$previousdefinition.$targetslot == @this.$startslot or not this.$SubTargetVariables.$previousdefinition.$targetslot.tags.indexof.{tag.npctransport}">
                    <do_if value="this.$SubTargetVariables.$previousdefinition.$context.isclass.room and this.$SubTargetVariables.$previousdefinition.$context.dynamicinterior">
                      <!--TODO @Owen allow find_npc_waypoint to use NavContexts?-->
                      <set_value name="this.$NavContextRooms" exact="this.$SubTargetVariables.$previousdefinition.$context.dynamicinterior.rooms"/>
                      <do_all exact="this.$NavContextRooms.count" counter="$NCR_i">
                        <debug_text text="$DebugIndent + 'Finding waypoints in dynamic room: ' + this.$NavContextRooms.{$NCR_i}.knownname + ' ' + this.$NavContextRooms.{$NCR_i}" chance="$DebugChance"/>
                        <find_npc_waypoint name="this.$SubTargetVariables.$waypoints" object="this.$NavContextRooms.{$NCR_i}" anytag="this.$LocalWaypointTagList" multiple="true" append="true"/>
                      </do_all>
                      <remove_value name="this.$NavContextRooms"/>
                    </do_if>
                    <do_else>
                      <debug_text text="$DebugIndent + 'Previous context object ' + (if this.$SubTargetVariables.$previousdefinition.$context.isclass.object then this.$SubTargetVariables.$previousdefinition.$context else this.$SubTargetVariables.$previousdefinition.$context.object) + ' ' + this.$SubTargetVariables.$previousdefinition.$context.knownname + ' dest context object ' + this.$resolveddestinationcontextobject" chance="$DebugChance"/>
                      <do_if value="if this.$SubTargetVariables.$previousdefinition.$context.isclass.object then (this.$SubTargetVariables.$previousdefinition.$context == this.$resolveddestinationcontextobject) else (this.$SubTargetVariables.$previousdefinition.$context.object == this.$resolveddestinationcontextobject)">
                        <!--Previous definition has the same context to the destination-->
                        <find_npc_waypoint name="this.$SubTargetVariables.$waypoints" object="this.$resolveddestinationcontextobject" anytag="this.$LocalWaypointTagList" multiple="true" append="true"/>
                        <debug_text text="$DebugIndent + 'Found ' + this.$SubTargetVariables.$waypoints.count + ' transporter or entry-exit points on ' + this.$resolveddestinationcontextobject + ' ' + this.$resolveddestinationcontextobject.knownname" chance="$DebugChance"/>
                      </do_if>
                      <do_else>
                        <!--HACK @Owen - if previous definition has a different context to the destination, do not allow cabins to be used. This led to people thinking they could use them as transporters to another object.
                        TODO @Owen fix transporter destination slot selection. It could still seem wrong on ships with a transporter but also a ramp out of the cockpit. A NPC wanting to leave the ship will still take the ship transporter.-->
                        <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$SubTargetVariables.$previousdefinition.$context" anytag="this.$LocalWaypointTagList" multiple="true"/>
                        <debug_text text="$DebugIndent + 'Found ' + this.$SubTargetVariables.$tempwaypoints.count + ' potential transporter or entry-exit points on ' + this.$SubTargetVariables.$previousdefinition.$context + ' ' + this.$SubTargetVariables.$previousdefinition.$context.knownname" chance="$DebugChance"/>
                        <do_all exact="this.$SubTargetVariables.$tempwaypoints.count" counter="$TWP_i">
                          <do_if value="not this.$SubTargetVariables.$tempwaypoints.{$TWP_i}.tags.indexof.{tag.npctransport} or this.$SubTargetVariables.$tempwaypoints.{$TWP_i}.group != tag.cabin_01">
                            <append_to_list name="this.$SubTargetVariables.$waypoints" exact="this.$SubTargetVariables.$tempwaypoints.{$TWP_i}"/>
                          </do_if>
                        </do_all>

                        <!--If context is related to a ship, also attempt to find npctransport tags on either the walkablemodule or dockingbay
                        This is for the case where a ship has a ramp instead of a ladder and needs to use a teleporter to get to the destination-->
                        <set_value name="this.$SubTargetVariables.$ContextShip" exact="null"/>
                        <do_if value="this.$SubTargetVariables.$previousdefinition.$context.isclass.ship">
                          <set_value name="this.$SubTargetVariables.$ContextShip" exact="this.$SubTargetVariables.$previousdefinition.$context"/>
                        </do_if>
                        <do_elseif value="this.$SubTargetVariables.$previousdefinition.$context.ship.exists">
                          <set_value name="this.$SubTargetVariables.$ContextShip" exact="this.$SubTargetVariables.$previousdefinition.$context.ship"/>
                        </do_elseif>
                        <do_if value="this.$SubTargetVariables.$ContextShip">
                          <do_if value="@this.$SubTargetVariables.$ContextShip.module.isclass.walkablemodule">
                            <!--$context is a ship which is docked at a walkable module-->
                            <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$SubTargetVariables.$ContextShip.module" tags="tag.npctransport" multiple="true"/>
                            <debug_text text="$DebugIndent + 'Found ' + this.$SubTargetVariables.$tempwaypoints.count + ' transporter slots on ' + this.$SubTargetVariables.$ContextShip.module + ' ' + this.$SubTargetVariables.$ContextShip.module.knownname" chance="$DebugChance"/>
                          </do_if>
                          <do_elseif value="this.$SubTargetVariables.$ContextShip.dock">
                            <!--$context is a ship which is docked at a dockingbay not on a walkable module
                            TODO @Owen find other dockingbays on this object?-->
                            <find_npc_waypoint name="this.$SubTargetVariables.$tempwaypoints" object="this.$SubTargetVariables.$ContextShip.dock" tags="tag.npctransport" multiple="true"/>
                            <debug_text text="$DebugIndent + 'Found ' + this.$SubTargetVariables.$tempwaypoints.count + ' transporter slots on ' + this.$SubTargetVariables.$ContextShip.dock + ' ' + this.$SubTargetVariables.$ContextShip.dock.knownname" chance="$DebugChance"/>
                          </do_elseif>

                          <do_if value="@this.$SubTargetVariables.$tempwaypoints.count">
                            <set_value name="this.$SubTargetVariables.$disttable" exact="table[]"/>
                            <do_all exact="this.$SubTargetVariables.$tempwaypoints.count" counter="$TWP_i">
                              <!--table where the key is the slot and the value is the distance-->
                              <do_if value="this.$SubTargetVariables.$previousdefinition.$targetslot">
                                <set_value name="this.$SubTargetVariables.$disttable.{this.$SubTargetVariables.$tempwaypoints.{$TWP_i}}" exact="this.$SubTargetVariables.$previousdefinition.$targetslot.distanceto.{this.$SubTargetVariables.$tempwaypoints.{$TWP_i}}"/>
                              </do_if>
                              <do_else>
                                <set_value name="this.$SubTargetVariables.$disttable.{this.$SubTargetVariables.$tempwaypoints.{$TWP_i}}" exact="$NPC.distanceto.{this.$SubTargetVariables.$tempwaypoints.{$TWP_i}}"/>
                              </do_else>
                            </do_all>
                            <set_value name="this.$SubTargetVariables.$tempwaypoints" exact="this.$SubTargetVariables.$disttable.keys.sorted"/>
                            <do_all exact="this.$SubTargetVariables.$tempwaypoints.count" counter="$DIST_i">
                              <append_to_list name="this.$SubTargetVariables.$waypoints" exact="this.$SubTargetVariables.$tempwaypoints.{$DIST_i}"/>
                            </do_all>
                          </do_if>
                        </do_if>
                      </do_else>
                    </do_else>
                  </do_if>
                  <set_value name="this.$SubTargetVariables.$direct_walk" exact="true"/>
                </do_else>
              </do_else>

              <!-- Finished populating $SubTargetVariables, determine resulting $SubTargetDefinition -->

              <do_if value="this.$SubTargetVariables.$canwalk">
                <set_value name="this.$SubTargetDefinition" exact="table[]"/>
                <set_value name="this.$SubTargetDefinition.$context" exact="this.$resolveddestinationcontext"/>
                <set_value name="this.$SubTargetDefinition.$targetslot" exact="this.$destinationslot" comment="may be null, meaining $context must be set as the destination"/>
                <set_value name="this.$SubTargetDefinition.$targetoffset" exact="this.$destinationoffset"/>
                <set_value name="this.$SubTargetDefinition.$targetrotation" exact="this.$destinationrotation"/>
                <set_value name="this.$SubTargetDefinition.$targetroom" exact="this.$destinationcontextroom"/>
                <do_all chance="$DebugChance">
                  <do_if value="this.$destinationslot">
                    <debug_text text="$DebugIndent + 'Can walk to ' + this.$destinationslot + ' offset ' + this.$destinationoffset"/>
                  </do_if>
                  <do_else>
                    <debug_text text="$DebugIndent + 'Can walk to ' + this.$destinationcontext + ' ' + this.$destinationcontext + ' offset ' + this.$destinationoffset"/>
                  </do_else>
                </do_all>
                <set_value name="this.$SubTargetVariables.$previousdefinition.$subdefinition" exact="this.$SubTargetDefinition"/>
              </do_if>
              <do_if value="@this.$SubTargetVariables.$finishedchair">
                <debug_text text="$DebugIndent + 'NPC can walk to chair slot ' + this.$destinationslot + ' and sucessfully sit'" chance="$DebugChance"/>
                <set_value name="this.$SubTargetDefinition" exact="table[]"/>
                <set_value name="this.$SubTargetDefinition.$context" exact="this.$destinationslot.component"/>
                <set_value name="this.$SubTargetDefinition.$targetslot" exact="this.$destinationslot"/>
                <set_value name="this.$SubTargetDefinition.$finishedchair" exact="true"/>
                <set_value name="this.$SubTargetVariables.$previousdefinition.$subdefinition" exact="this.$SubTargetDefinition"/>
              </do_if>
              <do_elseif value="@this.$SubTargetVariables.$closingcabin">
                <debug_text text="$DebugIndent + 'NPC can walk to cabin slot ' + this.$destinationslot + ' and will wait for the doors to close'" chance="$DebugChance"/>
                <set_value name="this.$SubTargetDefinition" exact="table[]"/>
                <set_value name="this.$SubTargetDefinition.$context" exact="this.$destinationslot.component"/>
                <set_value name="this.$SubTargetDefinition.$targetslot" exact="this.$destinationslot"/>
                <set_value name="this.$SubTargetDefinition.$closingcabin" exact="true"/>
                <set_value name="this.$SubTargetVariables.$previousdefinition.$subdefinition" exact="this.$SubTargetDefinition"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$lockingtransporter">
                <debug_text text="$DebugIndent + 'NPC can walk to transporter slot ' + this.$destinationslot + ' and will wait for the doors to close'" chance="$DebugChance"/>
                <set_value name="this.$SubTargetDefinition" exact="table[]"/>
                <set_value name="this.$SubTargetDefinition.$context" exact="this.$destinationslot.component"/>
                <set_value name="this.$SubTargetDefinition.$targetslot" exact="this.$destinationslot"/>
                <set_value name="this.$SubTargetDefinition.$lockingtransporter" exact="true"/>
                <set_value name="this.$SubTargetVariables.$previousdefinition.$subdefinition" exact="this.$SubTargetDefinition"/>
              </do_elseif>
              <do_elseif value="@this.$SubTargetVariables.$waypoints.count">
                <assert value="this.$SubTargetVariables.$waypoints.count == 1 or not @this.$SubTargetVariables.$perform_chair_action" text="'chair related actions should only have 1 waypoint, the chair slot [Owen]'" break="1"/>
                <do_all chance="$DebugChance">
                  <do_if value="@this.$SubTargetVariables.$perform_chair_action">
                    <debug_text text="$DebugIndent + 'Has a chair action to perform on ' + this.$SubTargetVariables.$waypoints.{1}"/>
                  </do_if>
                  <do_else>
                    <debug_text text="$DebugIndent + 'Has ' + this.$SubTargetVariables.$waypoints.count + if @this.$SubTargetVariables.$direct_walk then ' potential walkable waypoints. ' else ' potential waypoints. ' + this.$SubTargetVariables.$waypoints"/>
                  </do_else>
                </do_all>
                <set_value name="this.$SubTargetVariables.$tempstartslot" exact="null"/>
                <do_if value="@this.$SubTargetVariables.$previousdefinition.$chair_leave">
                  <set_value name="this.$SubTargetVariables.$tempstartslot" exact="@this.$SubTargetVariables.$previousdefinition.$targetslot.component.chairapproachslot.{this.$SubTargetVariables.$previousdefinition.$targetslot}"/>
                </do_if>
                <do_if value="not this.$SubTargetVariables.$tempstartslot">
                  <set_value name="this.$SubTargetVariables.$tempstartslot" exact="this.$SubTargetVariables.$previousdefinition.$targetslot"/>
                </do_if>
                <do_while value="this.$SubTargetVariables.$waypoints.count">
                  <do_if value="typeof this.$SubTargetVariables.$waypoints.{1} != datatype.componentslot">
                    <debug_text text="$DebugIndent + 'invalid slot ' + this.$SubTargetVariables.$waypoints.{1}" chance="$DebugChance"/>
                    <remove_value name="this.$SubTargetVariables.$waypoints.{1}"/>
                    <continue/>
                  </do_if>
                  <do_if value="not @this.$SubTargetVariables.$postwarp and not @this.$SubTargetVariables.$perform_chair_action and not @this.$SubTargetVariables.$enteringcabin and not @this.$SubTargetVariables.$appearincabin and not @this.$SubTargetVariables.$exitingcabin and not @this.$SubTargetVariables.$approachingcabin and this.$SubTargetVariables.$waypoints.{1} != this.$destinationslot and this.$TempSlotStorer.indexof.{this.$SubTargetVariables.$waypoints.{1}}">
                    <debug_text text="$DebugIndent + 'Evaluated slot ' + this.$SubTargetVariables.$waypoints.{1} + ' was already in this path. Disregarding.'" chance="$DebugChance"/>
                    <remove_value name="this.$SubTargetVariables.$waypoints.{1}"/>
                    <continue/>
                  </do_if>
                  <do_if value="@this.$SubTargetVariables.$direct_walk">
                    <do_if value="this.$SubTargetVariables.$tempstartslot">
                      <check_walk_path result="this.$SubTargetVariables.$canwalkwaypoint" actor="$NPC" start="this.$SubTargetVariables.$tempstartslot" end="this.$SubTargetVariables.$waypoints.{1}" checkstate="false"/>
                      <do_all chance="$DebugChance">
                        <do_if value="this.$SubTargetVariables.$canwalkwaypoint">
                          <debug_text text="$DebugIndent + 'NPC can walk from ' + this.$SubTargetVariables.$tempstartslot + ' to ' + this.$SubTargetVariables.$waypoints.{1}"/>
                        </do_if>
                        <do_else>
                          <debug_text text="$DebugIndent + 'NPC can not walk from ' + this.$SubTargetVariables.$tempstartslot + ' to ' + this.$SubTargetVariables.$waypoints.{1} + ' on ' + this.$SubTargetVariables.$waypoints.{1}.component.knownname"/>
                        </do_else>
                      </do_all>
                    </do_if>
                    <do_else>
                      <check_walk_path result="this.$SubTargetVariables.$canwalkwaypoint" actor="$NPC" end="this.$SubTargetVariables.$waypoints.{1}" checkstate="false"/>
                      <do_all chance="$DebugChance">
                        <do_if value="this.$SubTargetVariables.$canwalkwaypoint">
                          <debug_text text="$DebugIndent + 'NPC can walk to ' + this.$SubTargetVariables.$waypoints.{1}"/>
                        </do_if>
                        <do_else>
                          <debug_text text="$DebugIndent + 'NPC can not walk to ' + this.$SubTargetVariables.$waypoints.{1}"/>
                        </do_else>
                      </do_all>
                    </do_else>
                    <do_if value="not this.$SubTargetVariables.$canwalkwaypoint">
                      <remove_value name="this.$SubTargetVariables.$waypoints.{1}"/>
                      <continue/>
                    </do_if>
                  </do_if>
                  <!--Create next path using $waypoints.{1} and call the GetNextSubTargetPoint library again to evaluate it-->
                  <set_value name="this.$SubTargetDefinition" exact="table[]"/>
                  <set_value name="this.$SubTargetDefinition.$context" exact="this.$SubTargetVariables.$waypoints.{1}.component"/>
                  <set_value name="this.$SubTargetDefinition.$targetslot" exact="this.$SubTargetVariables.$waypoints.{1}"/>
                  <do_if value="@this.$SubTargetVariables.$perform_chair_action">
                    <!--The related waypoint is paired with an animated chair-->

                    <!--WALKING TO CHAIR-->
                    <do_if value="@this.$SubTargetVariables.$chair_approaching">
                      <!--initial state: walk to the chair-->
                      <set_value name="this.$SubTargetDefinition.$chair_walkto" exact="true"/>
                    </do_if>
                    <do_elseif value="@this.$SubTargetVariables.$chair_sitdown">
                      <!--after walking to the chair, sit down-->
                      <set_value name="this.$SubTargetDefinition.$chair_sitdown" exact="true"/>
                    </do_elseif>
                    <do_elseif value="@this.$SubTargetVariables.$chair_rotateforward">
                      <!--after sitting down, rotate the chair forward-->
                      <set_value name="this.$SubTargetDefinition.$chair_rotateforward" exact="true"/>
                    </do_elseif>
                    <do_elseif value="@this.$SubTargetVariables.$chair_facingforward">
                      <!--after rotating the chair forward, finish-->
                      <set_value name="this.$SubTargetDefinition.$chair_facingforward" exact="true"/>
                    </do_elseif>

                    <!--GETTING UP FROM CHAIR-->
                    <do_elseif value="@this.$SubTargetVariables.$chair_disembarking">
                      <!--initial state: rotate chair to allow leaving-->
                      <set_value name="this.$SubTargetDefinition.$chair_rotatebackward" exact="true"/>
                    </do_elseif>
                    <do_elseif value="@this.$SubTargetVariables.$chair_getup">
                      <!--after rotating the chair backwards, get up-->
                      <set_value name="this.$SubTargetDefinition.$chair_getup" exact="true"/>
                    </do_elseif>
                    <do_elseif value="@this.$SubTargetVariables.$chair_leave">
                      <!--after getting up, finish-->
                      <set_value name="this.$SubTargetDefinition.$chair_leave" exact="true"/>
                    </do_elseif>

                    <do_else>
                      <assert value="false" text="'There was no valid chair action for ' + this.$SubTargetDefinition.$targetslot + ' in ' + this.$SubTargetVariables + ' [Owen]'" break="1"/>
                    </do_else>
                  </do_if>
                  <do_elseif value="@this.$SubTargetVariables.$appearincabin">
                    <debug_text text="$DebugIndent + 'NPC at cabin slot ' + this.$destinationslot + ' and will wait for the doors to close'" chance="$DebugChance"/>
                    <set_value name="this.$SubTargetDefinition.$appearincabin" exact="true"/>
                  </do_elseif>
                  <do_elseif value="@this.$SubTargetVariables.$exitingcabin">
                    <debug_text text="$DebugIndent + 'NPC appear at cabin slot ' + this.$destinationslot + ' and prepare to walk out'" chance="$DebugChance"/>
                    <set_value name="this.$SubTargetDefinition.$exitingcabin" exact="true"/>
                  </do_elseif>
                  <do_elseif value="this.$SubTargetDefinition.$targetslot">
                    <do_if value="this.$SubTargetDefinition.$targetslot.tags.indexof.{tag.npctransport}">
                      <!--The related waypoint is a npctransport-->
                      <debug_text text="$DebugIndent + 'the related waypoint is a npctransport'" chance="$DebugChance"/>

                      <do_if value="this.$SubTargetDefinition.$targetslot.group == tag.cabin_01">
                        <set_value name="this.$SubTargetDefinition.$enteringcabin" exact="true"/>
                      </do_if>
                      <do_else>
                        <do_if value="@this.$SubTargetVariables.$exitingtransporter">
                          <set_value name="this.$SubTargetDefinition.$exitingtransporter" exact="true"/>
                        </do_if>
                        <do_elseif value="@this.$SubTargetVariables.$approachingtransporter">
                          <set_value name="this.$SubTargetDefinition.$approachingtransporter" exact="true"/>
                        </do_elseif>
                        <do_else>
                          <set_value name="this.$SubTargetDefinition.$enteringtransporter" exact="true"/>
                        </do_else>
                      </do_else>
                    </do_if>
                    <do_elseif value="this.$SubTargetDefinition.$targetslot.tags.indexof.{tag.ladder_top}">
                      <!--The related waypoint is the top of a ladder-->
                      <do_if value="@this.$SubTargetVariables.$climbedladder_attop">
                        <set_value name="this.$SubTargetDefinition.$climbedladder_attop" exact="true"/>
                      </do_if>
                      <do_else>
                        <set_value name="this.$SubTargetDefinition.$climbingladder_down" exact="true"/>
                      </do_else>
                    </do_elseif>
                    <do_elseif value="this.$SubTargetDefinition.$targetslot.tags.indexof.{tag.ladder_bottom}">
                      <!--The related waypoint is the bottom of a ladder-->
                      <do_if value="@this.$SubTargetVariables.$climbedladder_atbottom">
                        <set_value name="this.$SubTargetDefinition.$climbedladder_atbottom" exact="true"/>
                      </do_if>
                      <do_else>
                        <set_value name="this.$SubTargetDefinition.$climbingladder_up" exact="true"/>
                      </do_else>
                    </do_elseif>
                  </do_elseif>
                  <set_value name="this.$SubTargetVariables.$definition" exact="this.$SubTargetDefinition"/>
                  <do_if value="this.$SubTargetDefinition.$targetslot">
                    <append_to_list name="this.$TempSlotStorer" exact="this.$SubTargetDefinition.$targetslot"/>
                  </do_if>
                  <do_all chance="$DebugChance">
                    <set_value name="$DebugIndent" exact="''"/>
                    <do_all exact="this.$TempSlotStorer.count">
                      <set_value name="$DebugIndent" operation="add" exact="' '"/>
                    </do_all>
                  </do_all>
                  <debug_text text="$DebugIndent + 'Checking sub waypoint: ' + this.$TempSlotStorer" chance="$DebugChance"/>
                  <!--Recursive call of GetNextSubTargetPoint-->
                  <include_actions ref="GetNextSubTargetPoint"/>
                  <remove_value name="this.$TempSlotStorer.{this.$TempSlotStorer.count}" comment="Pop back of this.$TempSlotStorer"/>
                  <do_all chance="$DebugChance">
                    <set_value name="$DebugIndent" exact="''"/>
                    <do_all exact="this.$TempSlotStorer.count">
                      <set_value name="$DebugIndent" operation="add" exact="' '"/>
                    </do_all>
                  </do_all>
                  <set_value name="this.$SubTargetVariables" exact="this.$SubTargetVariableList.{this.$SubTargetVariableList.count}"/>
                  <debug_text text="$DebugIndent + 'this.$SubTargetVariables.{$waypoints} has ' + this.$SubTargetVariables.$waypoints.count" chance="$DebugChance"/>
                  <do_if value="this.$SubTargetVariables.$definition.$subdefinition?">
                    <set_value name="this.$SubTargetVariables.$previousdefinition.$subdefinition" exact="this.$SubTargetVariables.$definition"/>
                    <debug_text text="$DebugIndent + 'Sub definition was successful. Setting this definition to be the sub definition of the previous definition.'" chance="$DebugChance"/>
                    <debug_text text="$DebugIndent + 'Previous def: ' + this.$SubTargetVariables.$previousdefinition" chance="$DebugChance"/>
                    <break/>
                  </do_if>
                  <remove_value name="this.$SubTargetVariables.$waypoints.{1}"/>
                </do_while>
                <remove_value name="this.$SubTargetVariables.$tempstartslot"/>
              </do_elseif>
              <remove_value name="this.$SubTargetVariableList.{this.$SubTargetVariableList.count}"/>
              <debug_text text="$DebugIndent + '$SubTargetVariableList now has ' + this.$SubTargetVariableList.count" chance="$DebugChance"/>
            </do_if>
            <do_else>
              <assert value="false" text="'neither this.$destinationslot nor this.$destoffsetlist was not valid or $SubTargetLists does not have a valid entry [Owen]'" break="1"/>
            </do_else>
            <do_if value="this.$SubTargetDefinition?">
              <remove_value name="this.$SubTargetDefinition"/>
            </do_if>
          </actions>
        </library>

        <library name="PerformPath" namespace="this">
          <params>
            <param name="NPC"/>
            <param name="pathtable"/>
            <param name="signalcue"/>
            <param name="DebugChance" default="0"/>
          </params>
          <actions>
            <set_value name="$NPC.$state_machine_critical" exact="false"/>
          </actions>
          <cues>
            <cue name="PerformPath_Evaluate" checkinterval="1ms">
              <conditions>
                <check_value value="$NPC != player.conversationactor"/>
              </conditions>
              <actions>
                <debug_text text="'into PerformPath_Evaluate'" chance="$DebugChance"/>

                <set_value name="$nextpath" exact="null"/>
                <set_value name="$finished" exact="false"/>
                <set_value name="$waitforwalk" exact="false"/>
                <set_value name="$endanimation" exact="null"/>
                <set_value name="$NPC.$state_machine_critical" exact="false"/>
                <do_if value="$pathtable and $pathtable.$subdefinition?">
                  <do_if value="@$pathtable.$speed gt 0">
                    <do_if value="$pathtable.$speed gt $NPC.walkspeed and not $NPC.room.parent.isclass.walkablemodule">
                      <set_value name="$speed" exact="$NPC.walkspeed"/>
                      <debug_text text="'reducing $speed from ' + $pathtable.$speed + ' to walkspeed' + $speed + ' roomparent ' + $NPC.room.parent.name" chance="$DebugChance"/>
                    </do_if>
                    <do_else>
                      <set_value name="$speed" exact="$pathtable.$speed"/>
                      <debug_text text="'keeping $speed ' + $speed + ' roomparent ' + $NPC.room.parent.name" chance="$DebugChance"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <set_value name="$speed" exact="2.0f"/>
                    <debug_text text="'setting $speed to ' + $speed + ' roomparent ' + $NPC.room.parent.name" chance="$DebugChance"/>
                  </do_else>
                  <!--$pathtable can be the first movement definition if the NPC is to warp to the start e.g. when starting from an elevator.-->
                  <set_value name="$subdefinition" exact="$pathtable"/>
                  <do_while value="$subdefinition">
                    <debug_text text="'Checking subdefinition ' + $subdefinition" chance="$DebugChance"/>
                    <do_if value="not @$subdefinition.$targetslot and not @$subdefinition.$targetoffset">
                      <set_value name="$subdefinition.$finished" exact="true"/>
                    </do_if>

                    <do_if value="not @$subdefinition.$finished">
                      <set_entity_traits entity="$NPC" intransit="true"/>
                      <!--this point has not been done yet-->
                      <debug_text text="'Performing subdefinition'" chance="$DebugChance"/>
                      <!--
                      #########
                      TRANSPORTER
                      #########-->
                      <do_if value="@$subdefinition.$enteringtransporter">
                        <do_if value="@$subdefinition.$walkdone">
                          <!--walk was done-->
                          <debug_text text="player.age + ' walked to transporter ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <set_triggers_locked room="$subdefinition.$targetslot.component" group="tag.transporter_01" locked="true" duration="2.5s" />
                          <!-- set_value name="$subdefinition.$finished" exact="true"/ -->
                          <!-- wait for the door to close before continuing with next state (exitingtransporter) -->
                          <signal_cue_instantly cue="PerformPath__Force_Next" param="2s"/>
                        </do_if>
                        <do_else>
                          <!--walk to the transporter-->
                          <debug_text text="player.age + ' walk to transporter ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed">
                            <rotation yaw="180deg"/>
                          </start_actor_walk>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_if>
                      <do_elseif value="@$subdefinition.$lockingtransporter">
                        <set_entity_traits entity="$NPC" hidden="true"/>
                        <debug_text text="player.age + ' is now hidden in transporter ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$exitingtransporter">
                        <debug_text text="player.age + ' teleported to ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$approachingtransporter">
                        <do_if value="@$subdefinition.$walkdone">
                          <!--walk was done-->
                          <debug_text text="player.age + ' walked to transporter ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <set_triggers_locked room="$subdefinition.$targetslot.component" group="tag.transporter_01" locked="true" duration="2.5s" />
                          <!-- wait for the door to close before hiding the NPC -->
                          <signal_cue_instantly cue="PerformPath__Force_Next" param="2s"/>
                        </do_if>
                        <do_else>
                          <!--walk into the cabin-->
                          <debug_text text="player.age + ' walk to transporter ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed">
                            <rotation yaw="180deg"/>
                          </start_actor_walk>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <!--
                      #########
                      CABIN
                      #########-->
                      <do_elseif value="@$subdefinition.$enteringcabin">
                        <do_if value="@$subdefinition.$walkdone">
                          <!--walk was done-->
                          <debug_text text="player.age + ' walked to cabin ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <trigger_animation object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="close_doors"/>
                          <trigger_animation delay="2s" object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="open_doors"/>
                          <!-- wait for the door to close before hiding the NPC -->
                          <signal_cue_instantly cue="PerformPath__Force_Next" param="2s"/>
                        </do_if>
                        <do_else>
                          <!--walk into the cabin-->
                          <debug_text text="player.age + ' walk to cabin ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed">
                            <rotation yaw="180deg"/>
                          </start_actor_walk>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$closingcabin">
                        <!-- open the door again -->
                        <!-- trigger_animation object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="open_doors"/ -->
                        <set_entity_traits entity="$NPC" hidden="true"/>
                        <debug_text text="player.age + ' opening cabin door ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$appearincabin">
                        <!-- close cabin before spawning in NPC -->
                        <debug_text text="player.age + ' closing cabin for NPC to appear ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                        <trigger_animation object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="close_doors"/>
                        <trigger_animation delay="2s" object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="open_doors"/>
                        <!-- wait for the door to close -->
                        <signal_cue_instantly cue="PerformPath__Force_Next" param="2s"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$exitingcabin">
                        <!-- unhide NPC in teleporter cabin -->
                        <debug_text text="player.age + ' unhide NPC in cabin and open door ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                        <set_entity_traits entity="$NPC" hidden="false"/>
                        <start_actor_sequence type="'idle'" behavior="'stand'" actor="$NPC" result="this.$animationstarted" />
                        <!-- cabin door is starting to open now -->
                        <!-- wait for the door to open a bit before start walking -->
                        <signal_cue_instantly cue="PerformPath__Force_Next" param="1s"/>
                      </do_elseif>
                      <!--
                      #########
                      LADDER
                      #########-->
                      <do_elseif value="@$subdefinition.$climbingladder_down">
                        <!--Movement down ladder-->
                        <do_if value="@$subdefinition.$walkdone">
                          <!--Climb down ladder-->
                          <do_if value="$NPC.attention ge attention.nearby">
                            <!--High attention - play climb down animation-->
                            <debug_text text="player.age + ' start climb down animation'" chance="$DebugChance"/>
                            <set_value name="$NPC.$state_machine_critical" exact="true"/>
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                            <!--Calculate ladder height-->
                            <set_value name="$height" exact="$subdefinition.$targetslot.distanceto.{$subdefinition.$subdefinition.$targetslot}"/>
                            <do_if value="$height gt 4.0">
                              <start_actor_sequence actor="$NPC" type="'climbingdown13'" behavior="'generic'" transition="false" result="this.$animationstarted"/>
                            </do_if>
                            <do_else>
                              <start_actor_sequence actor="$NPC" type="'climbingdown'" behavior="'generic'" transition="false" result="this.$animationstarted"/>
                            </do_else>
                            <do_if value="this.$animationstarted">
                              <set_value name="$endanimation" exact="'anim_stand_conversation_01'"/>
                            </do_if>
                            <do_else>
                              <debug_text text="'failed to start animation \'climbingdown\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                              <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                            </do_else>
                          </do_if>
                          <do_else>
                            <!--Low attention - skip animation. Will be connected at bottom of ladder in the next definition-->
                            <debug_text text="'attention is ' + $NPC.attention + ' - skipping climbing animation'" chance="$DebugChance"/>
                            <set_value name="$subdefinition.$finished" exact="true"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <!--Walk to top of ladder-->
                          <debug_text text="player.age + ' walk to top of ladder ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <!--Walk to a position relative to the top of the ladder. The exact position may be different per character depending on the start position of their climbdown animation. Adjust positions below.-->
                          <do_if value="$NPC.race == race.argon and $NPC.isfemale">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot">
                              <position z="0.5m"/>
                              <rotation yaw="180deg"/>
                            </start_actor_walk>
                          </do_if>
                          <do_elseif value="$NPC.race == race.argon and not $NPC.isfemale">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot">
                              <position z="0.5m"/>
                              <rotation yaw="180deg"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_elseif value="$NPC.race == race.split and $NPC.isfemale">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot">
                              <position z="0.5m"/>
                              <rotation yaw="180deg"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_elseif value="$NPC.race == race.split and not $NPC.isfemale">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot">
                              <position z="0.5m"/>
                              <rotation yaw="180deg"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_elseif value="$NPC.race == race.teladi">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot">
                              <position z="0.5m"/>
                              <rotation yaw="180deg"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_elseif value="$NPC.race == race.paranid">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot">
                              <position z="0.6m"/>
                              <rotation yaw="180deg"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_else>
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot">
                              <position z="0.5m"/>
                              <rotation yaw="180deg"/>
                            </start_actor_walk>
                          </do_else>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$climbingladder_up">
                        <!--Movement up ladder-->
                        <do_if value="@$subdefinition.$walkdone">
                          <!--Climb up ladder-->
                          <do_if value="$NPC.attention ge attention.nearby">
                            <!--High attention - play climb up animation-->
                            <debug_text text="player.age + ' climb up ladder'" chance="$DebugChance"/>
                            <set_value name="$NPC.$state_machine_critical" exact="true"/>
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                            <!--Calculate ladder height-->
                            <set_value name="$height" exact="$subdefinition.$targetslot.distanceto.{$subdefinition.$subdefinition.$targetslot}"/>
                            <do_if value="$height gt 4.0">
                              <start_actor_sequence actor="$NPC" type="'climbingup13'" behavior="'generic'" transition="false" result="this.$animationstarted"/>
                            </do_if>
                            <do_else>
                              <start_actor_sequence actor="$NPC" type="'climbingup'" behavior="'generic'" transition="false" result="this.$animationstarted"/>
                            </do_else>
                            <do_if value="this.$animationstarted">
                              <set_value name="$endanimation" exact="'climbuptop'"/>
                            </do_if>
                            <do_else>
                              <debug_text text="'failed to start animation \'climbingup\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                              <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                            </do_else>
                          </do_if>
                          <do_else>
                            <!--Low attention - skip animation. Will be connected at top of ladder in the next definition-->
                            <debug_text text="'attention is ' + $NPC.attention + ' - skipping climbing animation'" chance="$DebugChance"/>
                            <set_value name="$subdefinition.$finished" exact="true"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <!--Walk to bottom of ladder-->
                          <debug_text text="player.age + ' walk to bottom of ladder ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed"/>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$climbedladder_attop or @$subdefinition.$climbedladder_atbottom">
                        <!--Connect to top or bottom of ladder-->
                        <debug_text text="player.age + ' ladder animation finished. connecting to ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false"/>
                        <!--This is not a state_machine_critical moment as it happens instantly-->
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <!--
                      #########
                      CHAIRS
                      #########-->
                      <do_elseif value="@$subdefinition.$chair_walkto">
                        <do_if value="@$subdefinition.$walkdone">
                          <set_value name="$subdefinition.$finished" exact="true"/>
                          <debug_text text="player.age + ' walk to chair was done'" chance="$DebugChance"/>
                        </do_if>
                        <do_else>
                          <!--Walk to the chair-->
                          <debug_text text="player.age + ' walk to chair ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                          <!--Walk to a position relative to the base of the chair. The exact position may be different per character depending on the start position of their sitdown animation. Adjust positions below.-->
                          <!--TODO @Owen - if the chair is very close, don't walk. Wait for the chair to turn, and then walk-->
                          <do_if value="$NPC.race == race.argon and $NPC.isfemale">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot.component.chairbaseslot.{$subdefinition.$targetslot}" roomslot="@$pathtable.$roomslot" speed="$NPC.walkspeed">
                              <position z="-0.45m"/>
                            </start_actor_walk>
                          </do_if>
                          <do_elseif value="$NPC.race == race.argon and not $NPC.isfemale">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot.component.chairbaseslot.{$subdefinition.$targetslot}" roomslot="@$pathtable.$roomslot" speed="$NPC.walkspeed">
                              <position z="-0.45m"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_elseif value="$NPC.race == race.split and $NPC.isfemale">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot.component.chairbaseslot.{$subdefinition.$targetslot}" roomslot="@$pathtable.$roomslot" speed="$NPC.walkspeed">
                              <position z="-0.45m"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_elseif value="$NPC.race == race.split and not $NPC.isfemale">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot.component.chairbaseslot.{$subdefinition.$targetslot}" roomslot="@$pathtable.$roomslot" speed="$NPC.walkspeed">
                              <position z="-0.45m"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_elseif value="$NPC.race == race.teladi">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot.component.chairbaseslot.{$subdefinition.$targetslot}" roomslot="@$pathtable.$roomslot" speed="$NPC.walkspeed">
                              <position z="-0.45m"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_elseif value="$NPC.race == race.paranid">
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot.component.chairbaseslot.{$subdefinition.$targetslot}" roomslot="@$pathtable.$roomslot" speed="$NPC.walkspeed">
                              <position z="-0.54m"/>
                            </start_actor_walk>
                          </do_elseif>
                          <do_else>
                            <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot.component.chairbaseslot.{$subdefinition.$targetslot}" roomslot="@$pathtable.$roomslot" speed="$NPC.walkspeed">
                              <position z="-0.45m"/>
                            </start_actor_walk>
                          </do_else>
                          <signal_cue_instantly cue="PerformPath__Approach_Chair_Listener" param="$subdefinition.$targetslot"/>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_sitdown">
                        <!--Add actor to seat - start the animation to sit down-->
                        <debug_text text="player.age + ' NPC preparing to sit down.'" chance="$DebugChance"/>
                        <!--The NPC must be moved to the chair in the same frame the sitdown animation starts, which is the next frame. Prevents a frame of jumping into the chair.-->
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <debug_text text="player.age + ' connecting NPC to the chair'" chance="$DebugChance"/>
                        <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot" triggeranimation="false" chairtrigger="invalid"/>
                        <!--Only start sitdown animation in high attention-->
                        <do_if value="$NPC.attention ge attention.nearby">
                          <debug_text text="'Starting sitdown animation'" chance="$DebugChance"/>
                          <start_actor_sequence actor="$NPC" type="'sitdown'" behavior="'generic'" transition="false" immediate="true" result="this.$animationstarted"/>
                          <do_if value="this.$animationstarted">
                            <set_value name="$endanimation" exact="'tran_stand_sit_01'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="'failed to start animation \'sitdown\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                            <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'attention is ' + $NPC.attention + ' - skipping sitdown animation'" chance="$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_rotateforward">
                        <!--Turn the chair forward-->
                        <debug_text text="player.age + ' turning chair forwards'" chance="$DebugChance"/>
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <animate_chair slot="$subdefinition.$targetslot" actor="$NPC" chairtrigger="activate_chair"/>
                        <!--TODO @Owen animation callback event for the chair turning?-->
                        <signal_cue_instantly cue="PerformPath__Force_Next" param="1.2s"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_facingforward">
                        <!--Chair facing forward-->
                        <debug_text text="player.age + ' chair facing forward.'" chance="$DebugChance"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$finishedchair">
                        <!--Chair facing forward-->
                        <debug_text text="player.age + ' finished sitting on chair.'" chance="$DebugChance"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_rotatebackward">
                        <!--Turn the chair backwards-->
                        <debug_text text="player.age + ' turning chair backwards'" chance="$DebugChance"/>
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <animate_chair slot="$subdefinition.$targetslot" actor="$NPC" chairtrigger="deactivate_chair"/>
                        <!--TODO @Owen animation callback event for the chair turning?-->
                        <signal_cue_instantly cue="PerformPath__Force_Next" param="1.2s"/>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_getup">
                        <!--Start the animation to get up-->
                        <debug_text text="player.age + ' get out of chair'" chance="$DebugChance"/>
                        <set_value name="$NPC.$state_machine_critical" exact="true"/>
                        <set_actor_current_chair actor="$NPC" roomslot="$subdefinition.$targetslot"/>
                        <do_if value="$NPC.attention ge attention.nearby">
                          <debug_text text="'Starting standup animation'" chance="$DebugChance"/>
                          <start_actor_sequence actor="$NPC" type="'standup'" behavior="'generic'" transition="false" result="this.$animationstarted"/>
                          <do_if value="this.$animationstarted">
                            <set_value name="$endanimation" exact="'tran_sit_stand_01'"/>
                          </do_if>
                          <do_else>
                            <debug_text text="'failed to start animation \'standup\' on NPC ' + $NPC.knownname + ' ' + $NPC"/>
                            <set_value name="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <debug_text text="'attention is ' + $NPC.attention + ' - skipping standup animation'" chance="$DebugChance"/>
                          <set_value name="$subdefinition.$finished" exact="true"/>
                        </do_else>
                      </do_elseif>
                      <do_elseif value="@$subdefinition.$chair_leave">
                        <!--Turn the chair forward-->
                        <debug_text text="player.age + ' character left the chair. Rotate chair to the forward position after a delay.'" chance="$DebugChance"/>
                        <!--At the end of the standup animation, the character's offset (which is currently at the seat) will be set to the visible position of the character-->
                        <clear_actor_current_chair actor="$NPC"/>
                        <animate_chair slot="$subdefinition.$targetslot" chairtrigger="activate_chair" delay="1s"/>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>

                      <!--Warp to destination-->
                      <do_elseif value="@$subdefinition.$warp">
                        <!--Warp to the destination (probably due to low attention)-->
                        <!--Unset hidden flag first so that the adding of the NPC to the room can trigger the correct animations on them-->
                        <set_entity_traits entity="$NPC" hidden="false"/>
                        <do_if value="$subdefinition.$targetslot">
                          <do_if value="@$subdefinition.$targetposition and @$subdefinition.$targetrotation">
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot">
                              <position value="$subdefinition.$targetposition"/>
                              <rotation value="$subdefinition.$targetrotation"/>
                            </add_actor_to_room>
                          </do_if>
                          <do_elseif value="@$subdefinition.$targetposition">
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot">
                              <position value="$subdefinition.$targetposition"/>
                            </add_actor_to_room>
                          </do_elseif>
                          <do_elseif value="@$subdefinition.$targetrotation">
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot">
                              <rotation value="$subdefinition.$targetrotation"/>
                            </add_actor_to_room>
                          </do_elseif>
                          <do_else>
                            <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot"/>
                          </do_else>
                        </do_if>
                        <do_else>
                          <do_if value="@$subdefinition.$targetrotation">
                            <add_actor_to_room actor="$NPC" object="$subdefinition.$targetroom">
                              <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                              <rotation value="$subdefinition.$targetrotation"/>
                            </add_actor_to_room>
                          </do_if>
                          <do_else>
                            <add_actor_to_room actor="$NPC" object="$subdefinition.$targetroom">
                              <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                            </add_actor_to_room>
                          </do_else>
                        </do_else>
                        <set_value name="$subdefinition.$finished" exact="true"/>
                      </do_elseif>
                      <do_else>
                        <do_if value="@$subdefinition.$walkdone">
                          <!--Walk was already completed-->
                          <do_if value="@$subdefinition.$finished">
                            <!--already finished - potentially due to the chair animation-->
                            <do_all chance="$DebugChance">
                              <do_if value="@$subdefinition.$targetslot">
                                <debug_text text="player.age + ' already walked to ' + $subdefinition.$targetslot"/>
                              </do_if>
                              <do_else>
                                <debug_text text="player.age + ' already walked to ' + $subdefinition.$context + ' ' + $subdefinition.$targetoffset"/>
                              </do_else>
                            </do_all>
                          </do_if>
                          <do_else>
                            <!--walk was done-->
                            <do_all chance="$DebugChance">
                              <do_if value="@$subdefinition.$targetslot">
                                <debug_text text="player.age + ' walked to ' + $subdefinition.$targetslot"/>
                              </do_if>
                              <do_else>
                                <debug_text text="player.age + ' walked to ' + $subdefinition.$context + ' ' + $subdefinition.$targetoffset"/>
                              </do_else>
                            </do_all>
                            <set_value name="$subdefinition.$finished" exact="true"/>
                          </do_else>
                        </do_if>
                        <do_elseif value="@$subdefinition.$targetslot">
                          <do_if value="$subdefinition.$targetslot.component">
                            <!--walk to the next point which is a slot-->
                            <debug_text text="player.age + ' walk to ' + $subdefinition.$targetslot" chance="$DebugChance"/>
                            <do_if value="$subdefinition.$targetslot.tags.indexof.{tag.npctransport}">
                              <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed">
                                <rotation yaw="180deg"/>
                              </start_actor_walk>
                              <set_value name="$waitforwalk" exact="true"/>
                            </do_if>
                            <do_else>
                              <do_if value ="@$subdefinition.$targetoffset">
                                <!-- final walk to a specified targetoffset -->
                                <debug_text text="'start_actor_walk with $subdefinition.$targetoffset ' + $subdefinition.$targetoffset" chance="$DebugChance"/>
                                <do_if value="@$subdefinition.$targetrotation">
                                  <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed">
                                    <position value="$subdefinition.$targetoffset"/>
                                    <rotation value="$subdefinition.$targetrotation"/>
                                  </start_actor_walk>
                                </do_if>
                                <do_else>
                                  <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed">
                                    <position value="$subdefinition.$targetoffset"/>
                                  </start_actor_walk>
                                </do_else>
                              </do_if>
                              <do_else>
                                <debug_text text="'start_actor_walk without offset'" chance="$DebugChance"/>
                                <start_actor_walk actor="$NPC" target="$subdefinition.$targetslot" roomslot="@$pathtable.$roomslot" speed="$speed"/>
                              </do_else>
                              <set_value name="$waitforwalk" exact="true"/>
                            </do_else>
                          </do_if>
                          <do_else>
                            <debug_text text="'$subdefinition.$targetslot is no longer valid. Component may have been destroyed or removed. NPC will not walk and will perform the next path action.'" filter="error"/>
                            <set_value name="$waitforwalk" exact="true"/>
                          </do_else>
                        </do_elseif>
                        <do_else>
                          <!--walk to the next point which is a non-slot position-->
                          <debug_text text="player.age + ' walk to ' + $subdefinition.$context + ' ' + $subdefinition.$context.knownname + ' ' + $subdefinition.$targetoffset" chance="$DebugChance"/>
                          <do_if value ="@$subdefinition.$targetoffset">
                            <!-- final walk to a specified targetoffset -->
                            <debug_text text="'start_actor_walk with $subdefinition.$targetoffset ' + $subdefinition.$targetoffset" chance="$DebugChance"/>
                            <do_if value="@$subdefinition.$targetrotation">
                              <start_actor_walk actor="$NPC" target="$subdefinition.$targetroom" speed="$speed">
                                <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                                <rotation value="$subdefinition.$targetrotation"/>
                              </start_actor_walk>
                            </do_if>
                            <do_else>
                              <start_actor_walk actor="$NPC" target="$subdefinition.$targetroom" speed="$speed">
                                <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                              </start_actor_walk>
                            </do_else>
                          </do_if>
                          <set_value name="$waitforwalk" exact="true"/>
                        </do_else>
                      </do_else>

                      <do_if value="@$subdefinition.$finished">
                        <do_if value="@$subdefinition.$subdefinition">
                          <!--continue to next point-->
                          <set_value name="$subdefinition" exact="@$subdefinition.$subdefinition"/>
                        </do_if>
                        <do_else>
                          <!--done-->
                          <debug_text text="'Movement is done'" chance="$DebugChance"/>
                          <do_if value="@$subdefinition.$targetslot">
                            <do_if value="$subdefinition.$targetslot.component">
                              <do_if value="$subdefinition.$targetslot.tags.indexof.{tag.npctransport}">
                                <set_entity_traits entity="$NPC" hidden="true"/>
                              </do_if>
                              <do_if value="@$subdefinition.$closingcabin">
                                <debug_text text="'npctransport slot reached ' + $subdefinition.$targetslot.group" chance="$DebugChance"/>
                                <!--TODO @Owen handle elevators. Pushing the button, waiting for the doors to close, other NPCs using it e.t.c-->
                                <!-- trigger_animation object="$subdefinition.$targetslot.component" group="'transporter_01'" trigger="deactivate"/ -->
                                <!--<trigger_animation object="$subdefinition.$targetslot.component" group="'cabin_01'" trigger="open_doors"/>-->
                                <!--<set_entity_traits entity="$NPC" hidden="true"/>-->
                              </do_if>
                              <do_if value="@$subdefinition.$targetoffset">
                                <do_if value="@$subdefinition.$targetrotation">
                                  <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot">
                                    <position value="$subdefinition.$targetoffset"/>
                                    <rotation value="$subdefinition.$targetrotation"/>
                                  </add_actor_to_room>
                                </do_if>
                                <do_else>
                                  <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot">
                                    <position value="$subdefinition.$targetoffset"/>
                                  </add_actor_to_room>
                                </do_else>
                              </do_if>
                              <do_else>
                                <add_actor_to_room actor="$NPC" slot="$subdefinition.$targetslot"/>
                              </do_else>
                            </do_if>
                            <do_else>
                              <debug_text text="'Final $subdefinition.$targetslot is no longer valid. Component may have been destroyed or removed. NPC may not end up where they were intended.'" filter="error"/>
                            </do_else>
                          </do_if>
                          <do_else>
                            <do_if value="@$subdefinition.$targetrotation">
                              <add_actor_to_room actor="$NPC" object="$subdefinition.$targetroom">
                                <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                                <rotation value="$subdefinition.$targetrotation"/>
                              </add_actor_to_room>
                            </do_if>
                            <do_else>
                              <add_actor_to_room actor="$NPC" object="$subdefinition.$targetroom">
                                <position value="$subdefinition.$targetoffset" object="$subdefinition.$context" space="$subdefinition.$targetroom"/>
                              </add_actor_to_room>
                            </do_else>
                          </do_else>
                          <set_entity_traits entity="$NPC" intransit="false"/>
                          <remove_value name="$NPC.$state_machine_critical"/>
                          <signal_cue_instantly cue="$signalcue"/>
                          <cancel_cue cue="PerformPath"/>
                          <break/>
                        </do_else>
                      </do_if>
                      <do_else>
                        <!--Must wait for walk or animation to finish-->
                        <set_value name="$nextpath" exact="$subdefinition"/>
                        <break/>
                      </do_else>
                    </do_if>
                    <do_else>
                      <debug_text text="'subdef was already performed. Skipping'" chance="$DebugChance"/>
                      <set_value name="$subdefinition" exact="@$subdefinition.$subdefinition"/>
                    </do_else>
                  </do_while>
                </do_if>
              </actions>
              <cues>
                <cue name="PerformPath_KeepAlive">
                  <conditions>
                    <event_cue_signalled/>
                  </conditions>
                </cue>

                <cue name="PerformPath_Animation_Failed" onfail="cancel">
                  <conditions>
                    <check_value value="$endanimation" exact="'ERROR_ANIMATION_FAILED'"/>
                  </conditions>
                  <actions>
                    <debug_text text="player.age + ' animation failed' + $NPC" chance="$DebugChance"/>
                    <set_value name="$nextpath.$finished" exact="true"/>
                    <reset_cue cue="PerformPath_Evaluate"/>
                  </actions>
                </cue>

                <cue name="PerformPath_Animation_Timeout" onfail="cancel">
                  <conditions>
                    <check_value value="$endanimation"/>
                  </conditions>
                  <!--TODO @Owen @Martin - find out why animations do not send finish events once they are started. Change of attention?-->
                  <delay exact="15s"/>
                  <actions>
                    <debug_text text="player.age + ' animation timeout' + $NPC" chance="$DebugChance"/>
                    <set_value name="$nextpath.$finished" exact="true"/>
                    <reset_cue cue="PerformPath_Evaluate"/>
                  </actions>
                </cue>

                <cue name="PerformPath_Walk_Timeout" onfail="cancel" version="2">
                  <conditions>
                    <check_value value="$waitforwalk"/>
                  </conditions>
                  <patch sinceversion="2" state="complete">
                    <debug_text text="player.age + ' ' + $NPC + ' Resetting walk timeout checks after loading.'" filter="savegame"/>
                    <set_value name="$Patch_IgnoreGameLoad" exact="true"/>
                    <reset_cue cue="PerformPath_Walk_Timeout"/>
                  </patch>
                  <cues>
                    <!--Check that walking starts after a certain amount of time. Otherwise skip walking.-->
                    <cue name="PerformPath_Walk_Check" checkinterval="1ms">
                      <conditions>
                        <!--TODO @Owen event_npc_walk_started-->
                        <check_value value="$NPC.iswalking"/>
                      </conditions>
                      <actions>
                        <cancel_cue cue="PerformPath_Walk_Conv_Wait"/>
                        <debug_text text="player.age + ' NPC ' + $NPC + ' ' + $NPC.knownname + ' started walking'" chance="$DebugChance"/>
                        <set_value name="PerformPath_Walk_Timeout.$LastWalkTime" exact="player.age"/>
                      </actions>
                      <cues>
                        <!--Check that a walking NPC is actually moving-->
                        <cue name="PerformPath_Walk_Stuck_Check" checkinterval="1s">
                          <conditions>
                            <check_value value="$NPC.iswalking and player.age gt PerformPath_Walk_Timeout.$LastWalkTime + 5s and $NPC.relspeed lt 0.01m"/>
                          </conditions>
                          <!--Give an additional 5 seconds for the zero speed walking NPC to sort themselves out-->
                          <delay exact="5s"/>
                          <actions>
                            <do_if value="$NPC.relspeed lt 0.01m">
                              <debug_text text="player.age + ' NPC was stuck while walking ' + $NPC + ' on ' + $NPC.parent.macro.name" filter="error"/>
                              <set_value name="$nextpath.$walkdone" exact="true"/>
                              <stop_actor_walk actor="$NPC"/>
                              <reset_cue cue="PerformPath_Evaluate"/>
                            </do_if>
                            <do_else>
                              <set_value name="PerformPath_Walk_Timeout.$LastWalkTime" exact="player.age"/>
                              <reset_cue cue="PerformPath_Walk_Stuck_Check"/>
                            </do_else>
                          </actions>
                        </cue>
                      </cues>
                    </cue>
                    <cue name="PerformPath_Walk_Conv_Wait" checkinterval="1ms">
                      <conditions>
                        <check_value value="not $NPC.isinconversation"/>
                      </conditions>
                      <cues>
                        <cue name="PerformPath_Walk_Start_Timeout" checktime="parent.time + 3s">
                          <actions>
                            <debug_text text="player.age + ' walk timeout ' + $NPC" chance="$DebugChance"/>
                            <set_value name="$nextpath.$walkdone" exact="true"/>
                            <stop_actor_walk actor="$NPC"/>
                            <reset_cue cue="PerformPath_Evaluate"/>
                          </actions>
                        </cue>
                      </cues>
                    </cue>
                    <cue name="PerformPath_Walk_Timeout_GameLoaded">
                      <conditions>
                        <event_game_loaded/>
                        <check_value value="not @$Patch_IgnoreGameLoad"/>
                      </conditions>
                      <actions>
                        <do_if value="PerformPath_Walk_Check.state != cuestate.cancelled and PerformPath_Walk_Check.state != cuestate.disabled">
                          <cancel_cue cue="PerformPath_Walk_Check"/>
                        </do_if>
                        <do_if value="PerformPath_Walk_Conv_Wait.state != cuestate.cancelled and PerformPath_Walk_Conv_Wait.state != cuestate.disabled">
                          <cancel_cue cue="PerformPath_Walk_Conv_Wait"/>
                        </do_if>
                      </actions>
                      <delay exact="5s"/>
                      <actions>
                        <reset_cue cue="PerformPath_Walk_Timeout"/>
                      </actions>
                    </cue>
                  </cues>
                </cue>
              </cues>
            </cue>

            <cue name="PerformPath_Walk_Finished" instantiate="true">
              <conditions>
                <event_npc_walk_finished object="$NPC"/>
                <check_value value="$waitforwalk"/>
              </conditions>
              <actions>
                <debug_text text="player.age + ' walk finished'" chance="$DebugChance"/>
                <set_value name="$nextpath.$walkdone" exact="true"/>
                <reset_cue cue="PerformPath_Evaluate"/>
              </actions>
            </cue>

            <cue name="PerformPath__Animation_Finished" instantiate="true">
              <conditions>
                <event_character_animation_finished object="$NPC" id="$endanimation"/>
              </conditions>
              <actions>
                <debug_text text="player.age + ' animation finished: ' + $endanimation" chance="$DebugChance"/>
                <set_value name="$nextpath.$finished" exact="true"/>
                <reset_cue cue="PerformPath_Evaluate"/>
              </actions>
            </cue>

            <!--event.param == delay-->
            <cue name="PerformPath__Force_Next" instantiate="true">
              <conditions>
                <event_cue_signalled/>
              </conditions>
              <delay exact="event.param"/>
              <actions>
                <debug_text text="player.age + ' forcing current path to be finished: ' + $nextpath" chance="$DebugChance"/>
                <set_value name="$nextpath.$finished" exact="true"/>
                <reset_cue cue="PerformPath_Evaluate"/>
              </actions>
            </cue>

            <!--event.param == NPC slot related to the chair-->
            <cue name="PerformPath__Approach_Chair_Listener">
              <conditions>
                <event_cue_signalled/>
                <check_value value="typeof event.param == datatype.componentslot"/>
              </conditions>
              <actions>
                <set_value name="$ChairSlot" exact="event.param"/>
                <debug_text text="player.age + ' setting up chair approach listener for ' + $ChairSlot" chance="$DebugChance"/>
              </actions>
              <cues>
                <cue name="PerformPath__Approach_Chair_Listener_Near" checkinterval="1ms">
                  <conditions>
                    <check_value value="$NPC.attention ge attention.nearby and $NPC.distanceto.{$ChairSlot} lt 3m"/>
                  </conditions>
                  <actions>
                    <debug_text text="player.age + ' triggering chair deactivation state for ' + $ChairSlot" chance="$DebugChance"/>
                    <animate_chair slot="$ChairSlot" actor="$NPC" chairtrigger="deactivate_chair"/>
                    <!--Precaching the sitdown animation is important as it has a start offset. Waiting for it to load may lead to the character visibly being in the wrong postion until it is loaded.-->
                    <precache_actor_animation_hint actor="$NPC" type="'sitdown'" behavior="'generic'"/>
                  </actions>
                </cue>
              </cues>
            </cue>

            <!--The NPC must be moved to the chair in the same frame the sitdown animation starts, which is the next frame. Prevents a frame of jumping into the chair.
            We will probably have to do this with any character animation with a start offset which is not 0,0,0-->
            <!-- This cue only remains for savegame compatibility reasons! -->
            <cue name="PerformPath__Delayed_Chair_Connection">
              <conditions>
                <event_cue_signalled/>
                <check_value value="typeof event.param == datatype.componentslot"/>
              </conditions>
              <delay exact="1ms"/>
              <actions>
                <debug_text text="player.age + ' connecting NPC to the chair'" chance="$DebugChance"/>
                <add_actor_to_room actor="$NPC" slot="event.param" triggeranimation="false" chairtrigger="invalid"/>
              </actions>
            </cue>
          </cues>
        </library>
      </cues>
    </cue>
  </cues>
</mdscript>
