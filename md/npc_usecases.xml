<?xml version="1.0" encoding="utf-8"?>
<mdscript name="NPC_UseCases" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>

    <cue name="UseCaseManager">
      <actions>
        <!-- Note: Even with $DebugChance == 0, you can enable debug text with $debugchance (lower case) in a usecase definition table and/or on a usecase trigger table -->
        <set_value name="$DebugChance" exact="0" />

        <!-- Use case definitions, filled below by UpdateUseCaseDefs -->
        <set_value name="$UseCaseDefs" exact="table[]" />
        <!-- Table for persistent usecase data, e.g. the last time a usecase was active -->
        <set_value name="$UseCaseSettings" exact="table[]" />
        <!-- List of instances of the UseCase cue -->
        <set_value name="$ActiveUseCases" exact="[]" />

        <!-- EXAMPLE CODE for triggering a usecase -->
        <do_all chance="0">
          <!-- Note: $actors and $locations are both optional, as long as every required actor can be found.
          If the trigger does not provide an actor, at least the location has to be known so a suitable actor can be found. However, the location
          can also be inferred from the slot context (room or controllable) of a previously provided actor, so if a usecase requires multiple actors
          in the same location, the trigger only has to provide the first required actor, and all further actors will be found in the same location.
          Note that, if an NPC requires a controlposition and the location is provided, the controlposition must be a slot of the location. -->
          <set_value name="$triggerparam" exact="table[
                     $name = '$UseCase1',
                     $locations = table[ $Bridge = player.room.slotcontext ],
                     $actors = table[ $Manager = player.entity ]
              ]" />
          <!-- Additional optional parameters that can be provided in the table: -->
          <!-- <set_value name="$triggerparam.$priority" exact="42" /> -->
          <!--      Overrides $priority defined in usecase -->
          <!-- <set_value name="$triggerparam.$debugchance" exact="100" /> -->
          <!--      Enables debug output for the triggered usecase -->
          <!-- <set_value name="$triggerparam.$keeplookat" exact="true" /> -->
          <!--      Set to true to prevent last $lookat state of involved NPCs being reset when the usecase ends - user has to perform <clear_actor_lookat> manually (default is false) -->
          <!-- <set_value name="$triggerparam.$keepemotion" exact="true" /> -->
          <!--      Set to true to prevent last $emotion state of involved NPCs being reset when the usecase ends - user has to perform <clear_actor_emotion> manually (default is false) -->
          <signal_cue_instantly cue="UseCase" param="$triggerparam" />
        </do_all>
        <!-- END OF EXAMPLE -->
      </actions>
      <cues>

        <!-- ===== Usecases loading and validation ===== -->

        <cue name="UpdateUseCaseDefs" instantiate="true">
          <conditions>
            <check_any>
              <event_game_started />
              <event_game_loaded />
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'Updating NPC usecases'" chance="$DebugChance" />

            <!-- In case of an update during the game, keep all active usecases, unless they have become incompatible (old version < minimal compatible version). -->
            <!-- We can safely clear $UseCaseDefs. Any still active usecase continues using a reference to the old usecasedef. -->
            <!-- Cleanup of incompatible active usecases is done at the end. -->
            <clear_table table="$UseCaseDefs" />

            <include_actions ref="md.NPC_UseCase_Definitions.AddUseCaseDefs" />

            <!-- Enabling debug output for specific usecases -->
            <!-- <set_value name="$UseCaseDefs.$UseCase1.$debugchance" exact="100" /> -->

            <!-- Identify and clean up incompatible usecases -->
            <do_all exact="$ActiveUseCases.count" counter="$i" reverse="true">
              <set_value name="$cue" exact="$ActiveUseCases.{$i}" />
              <do_if value="not $UseCaseDefs.{$cue.$UseCaseDef.$name}? or @$cue.$UseCaseDef.$version lt @$UseCaseDefs.{$cue.$UseCaseDef.$name}.$mincompatibleversion">
                <debug_text text="'Active usecase %s (version %s) was invalidated, aborting'.[$cue.$UseCaseDef.$name, (@$cue.$UseCaseDef.$version)i]" chance="[$DebugChance, $cue.$DebugChance].max" />
                <signal_cue_instantly cue="$cue" param="'cleanup'" />
                <!-- Remove again just in case the signal didn't work -->
                <do_if value="@$ActiveUseCases.{$i} == $cue">
                  <remove_value name="$ActiveUseCases.{$i}" />
                </do_if>
              </do_if>
            </do_all>
            <remove_value name="$cue" />

            <!-- Remove settings of usecases that don't exist any more -->
            <set_value name="$settingusecases" exact="$UseCaseSettings.keys.list" />
            <do_all exact="$settingusecases.count" counter="$i">
              <do_if value="not $UseCaseDefs.{$settingusecases.{$i}}?">
                <remove_value name="$UseCaseSettings.{$settingusecases.{$i}}" />
              </do_if>
            </do_all>
            <remove_value name="$settingusecases" />

          </actions>
          <force name="Reload NPC UseCases" />
        </cue>

        <!-- Only used by UpdateUseCaseDefs -->
        <cue name="AddUseCaseDef" instantiate="true" namespace="this">
          <conditions>
            <event_cue_signalled />
          </conditions>
          <actions>
            <!-- Example for demonstration purposes -->
            <set_value name="$UseCaseDef" exact="event.param" />
            <set_value name="$Error" exact="false" />
            <!-- TODO: Validate $name, $locations, $selectscript, $script using $actor, $lookat, $filter keys; remove $comment from scripts -->
            <!-- TODO: Validate or even automatically determine $passive flags? -->

            <do_if value="not $Error">
              <set_value name="UseCaseManager.$UseCaseDefs.{$UseCaseDef.$name}" exact="$UseCaseDef" />
            </do_if>
          </actions>
        </cue>

        <!-- ===== Usecase instantiation and initialisation ===== -->

        <!-- Helper library to check if an actor is assigned as active actor to an active usecase -->
        <!-- Input variable: $actor -->
        <!-- Output variable: $actorcue (the UseCase cue instance to which $actor NPC is assigned, null if not assigned or actor is the player) -->
        <!-- Note: An actor can be assigned to multiple use cases using $passive=true, but may be active (non-passive) in only one usecase. The player is also considered passive. -->
        <library name="GetAssignedActorCue">
          <actions>
            <set_value name="$actorcue" exact="null" />
            <do_if value="$actor != player.entity">
              <do_all exact="UseCaseManager.$ActiveUseCases.count" counter="$usecasecount">
                <do_if value="UseCaseManager.$ActiveUseCases.{$usecasecount}.$ActiveActorGroup.indexof.{$actor}">
                  <set_value name="$actorcue" exact="UseCaseManager.$ActiveUseCases.{$usecasecount}" />
                  <break />
                </do_if>
              </do_all>
            </do_if>
          </actions>
        </library>

        <!-- Helper library to check if an actor slot (componentslot) is reserved by an active usecase -->
        <!-- Input variable: $actorslot -->
        <!-- Output variable: $actorslotcue (analogous to GetAssignedActorCue) -->
        <library name="GetReservedActorSlotCue">
          <actions>
            <set_value name="$actorslotcue" exact="null" />
            <do_all exact="UseCaseManager.$ActiveUseCases.count" counter="$usecasecount">
              <do_if value="UseCaseManager.$ActiveUseCases.{$usecasecount}.$ReservedSlots.indexof.{$actorslot}">
                <set_value name="$actorslotcue" exact="UseCaseManager.$ActiveUseCases.{$usecasecount}" />
                <break />
              </do_if>
            </do_all>
          </actions>
        </library>

        <!-- Helper cue to check filter criteria for a given actor -->
        <!-- Input: event.param = table[ $actor = actor to be checked, $location = usecase location of actor, $criteria = list, $allow_player = boolean, $allow_walk_to_position = boolean, $exclude = boolean ] -->
        <!-- Output: event.param.$met = boolean, possibly event.param.$error = erroneous criterion -->
        <cue name="CheckFilterCriteria" instantiate="true" namespace="this">
          <conditions>
            <event_cue_signalled />
          </conditions>
          <actions>
            <set_value name="event.param.$met" exact="true" />
            <remove_value name="event.param.$error" />

            <set_value name="$actor" exact="event.param.$actor" />
            <set_value name="$playercase" exact="event.param.$allow_player and $actor.isclass.player" />
            <do_all exact="event.param.$criteria.count" counter="$criterionidx">
              <set_value name="$criterion" exact="event.param.$criteria.{$criterionidx}" />
              <do_if value="typeof $criterion" exact="datatype.entityrole">
                <set_value name="$met" exact="$actor.role == $criterion" />
              </do_if>
              <do_elseif value="typeof $criterion" exact="datatype.controlpost">
                <do_if value="$criterion" exact="controlpost.aipilot">
                  <!-- Also detect player if $allow_player is set, and don't detect aipilot that isn't actually piloting! -->
                  <set_value name="$met" exact="$actor == @$actor.ship.pilot" />
                </do_if>
                <do_else>
                  <set_value name="$met" exact="$actor.controlpost == $criterion" />
                </do_else>
              </do_elseif>
              <do_elseif value="typeof $criterion" exact="datatype.race">
                <set_value name="$met" exact="$actor.race == $criterion" />
              </do_elseif>
              <do_elseif value="typeof $criterion" exact="datatype.faction">
                <set_value name="$met" exact="$actor.owner == $criterion" />
              </do_elseif>
              <do_elseif value="typeof $criterion" exact="datatype.class">
                <do_if value="[class.entity, class.player, class.nonplayer, class.npc, class.computer].indexof.{$criterion}">
                  <set_value name="$met" exact="$actor.isclass.{$criterion}" />
                </do_if>
                <do_else>
                  <set_value name="$met" exact="$actor.object.isclass.{$criterion}" />
                </do_else>
              </do_elseif>
              <do_elseif value="typeof $criterion" exact="datatype.attention">
                <set_value name="$met" exact="$actor.attention ge $criterion" />
              </do_elseif>
              <do_elseif value="(typeof $criterion).isstring">
                <do_if value="$criterion" exact="'iscapitalship'">
                  <set_value name="$met" exact="@$actor.object.iscapitalship" />
                </do_if>
                <do_elseif value="$criterion" exact="'cantalk'">
                  <set_value name="$met" exact="$actor.page != 0 or $playercase" />
                </do_elseif>
                <do_elseif value="$criterion" list="['isfemale', 'isintransit', 'isbusy', 'ismissionactor']">
                  <assert value="typeof $criterion" exact="datatype.keyword" text="'$criterion=%s is of type %s, only a keyword is supported! [Klaus]'.[$criterion, typeof $criterion]" />
                  <set_value name="$met" exact="$actor.{$criterion}" />
                </do_elseif>
              </do_elseif>
              <do_elseif value="typeof $criterion" exact="datatype.controlposition">
                <set_value name="$curpositionentity" exact="@event.param.$location.controlposition.{$criterion}.entity" />
                <set_value name="$met" exact="$curpositionentity == $actor" />
                <do_if value="not event.param.$exclude and not $met and $curpositionentity == null and event.param.$location and event.param.$allow_walk_to_position">
                  <!-- Actor is not assigned to controlposition slot, but with $allow_walk_to_position, accept anyway. Requirements: NPC can walk over to the controlposition, and the controlposition is not reserved already. -->
                  <!-- TODO: Check if actor is available for walking over to the controlposition -->
                  <set_value name="$actorslot" exact="event.param.$location.controlposition.{$criterion}.roomslot" />
                  <do_if value="$actorslot">
                    <!-- Check if $actorslot is already reserved by another usecase that we cannot abort -->
                    <include_actions ref="GetReservedActorSlotCue" />
                    <do_if value="not $actorslotcue or $Priority gt $actorslotcue.$Priority">
                      <set_value name="$met" exact="true" />
                    </do_if>
                  </do_if>
                </do_if>
              </do_elseif>
              <do_else>
                <set_value name="event.param.$met" exact="false" />
                <set_value name="event.param.$error" exact="$criterion" />
                <break />
              </do_else>
              <!-- If $criterion was not met and $exclude = false, or if $criterion was met and $exclude = true, overall the criteria were not met -->
              <do_if value="$met == event.param.$exclude">
                <set_value name="event.param.$met" exact="false" />
                <break />
              </do_if>
            </do_all>
          </actions>
        </cue>

        <!-- Helper cue to find and assign usecase actors. Fills $Actors, $ReservedSlots and $AbortingUseCases in provided UseCase cue instance -->
        <cue name="FindUseCaseActors" instantiate="true" namespace="this">
          <conditions>
            <event_cue_signalled />
          </conditions>
          <actions>
            <set_value name="$UseCaseDef" exact="event.param.$UseCaseDef" />
            <set_value name="$Locations" exact="event.param.$Locations" />
            <set_value name="$Actors" exact="event.param.$Actors" />
            <set_value name="$ReservedSlots" exact="event.param.$ReservedSlots" />
            <set_value name="$AbortingUseCases" exact="event.param.$AbortingUseCases" />
            <set_value name="$Priority" exact="event.param.$Priority" />
            <set_value name="$DebugChance" exact="event.param.$DebugChance" />

            <!-- Try to assign all actors to the usecase as defined in the usecase definition -->
            <set_value name="$actordefs" exact="$UseCaseDef.$actors" />

            <!-- Step 1: Assign actors explicitly provided by usecase trigger -->
            <set_value name="$providedactors" exact="@event.param.$TriggerParam.$actors" />
            <do_all exact="$actordefs.count" counter="$i">
              <set_value name="$actorkey" exact="$actordefs.{$i}.$name" />
              <set_value name="$actor" exact="@$providedactors.{$actorkey}" />
              <do_if value="$actor">
                <set_value name="$Actors.{$actorkey}" exact="$actor" />
              </do_if>
            </do_all>

            <!-- Find remaining actors (two passes: find required actors in pass 1, optional ones in pass 2) -->
            <do_all exact="2" counter="$pass">
              <do_if value="event.param.$Error">
                <break />
              </do_if>
              <do_all exact="$actordefs.count" counter="$i">
                <set_value name="$actordef" exact="$actordefs.{$i}" />
                <do_if value="$pass == 1 and @$actordef.$optional">
                  <continue />
                </do_if>
                <set_value name="$actorkey" exact="$actordef.$name" />
                <set_value name="$locationkey" exact="$actordef.$location" />
                <set_value name="$location" exact="@$Locations.{$locationkey}" />
                <do_if value="$pass == 1 and player.age lt 1min and $Priority lt 100 and not @$UseCaseDef.$voiceover">
                  <do_if value="($location and $location != player.room.slotcontext) or ($Actors.{$actorkey}? and not $Actors.{$actorkey}.isinspeakrange)">
                    <debug_text text="'Ignoring NPC usecase %s with distant actor %s shortly after gamestart'.[$UseCaseDef.$name, $actorkey]" chance="$DebugChance" />
                    <set_value name="event.param.$Error" exact="true" />
                    <break />
                  </do_if>
                </do_if>
                <do_if value="$Actors.{$actorkey}?">
                  <!-- Actor already assigned -->
                  <do_if value="not $location">
                    <!-- Actor location was not provided by trigger, infer from actor room -->
                    <set_value name="$Locations.{$locationkey}" exact="@$Actors.{$actorkey}.room.slotcontext" />
                  </do_if>
                  <continue />
                </do_if>
                <!-- Find actor based on $actordef criteria -->
                <set_value name="$actor" exact="null" />
                <do_if value="not $location.isoperational">
                  <do_if value="$pass == 1">
                    <!-- Show error only if actor was not provided by trigger (otherwise a null value was provided as actor - abort silently) -->
                    <do_if value="not $providedactors.{$actorkey}?">
                      <debug_text text="'Trigger for NPC usecase %s %s location %s for required actor %s'.[$UseCaseDef.$name, (if $location then 'provided invalid' else 'did not provide'), $locationkey, $actorkey]" filter="error" />
                    </do_if>
                    <set_value name="event.param.$Error" exact="true" />
                    <break />
                  </do_if>
                  <debug_text text="'Skipping optional actor %s in usecase %s since trigger %s location %s'.[$actorkey, $UseCaseDef.$name, (if $location then 'provided invalid' else 'did not provide'), $locationkey]" chance="$DebugChance" />
                  <continue />
                </do_if>
                <find_object_component name="$actorcandidates" object="$location" class="class.entity" multiple="true" />
                <do_all exact="$actorcandidates.count" counter="$j" reverse="true">
                  <set_value name="$actor" exact="$actorcandidates.{$j}" />
                  <!-- If $actor is not an NPC, check if that's allowed ($allow_player for player, or $allow_computer for computer) -->
                  <do_if value="not $actor.isclass.npc">
                    <do_if value="not (($actor.isclass.player and @$actordef.$allow_player) or ($actor.isclass.computer and @$actordef.$allow_computer))">
                      <remove_value name="$actorcandidates.{$j}" />
                      <continue />
                    </do_if>
                  </do_if>
                  <!-- Check if $actor is already assigned in another usecase that we cannot abort -->
                  <include_actions ref="GetAssignedActorCue" />
                  <do_if value="$actorcue and $Priority le $actorcue.$Priority">
                    <remove_value name="$actorcandidates.{$j}" />
                    <continue />
                  </do_if>
                  <!-- TODO: Make sure that $actor is available in suitable state machine state - check with Owen -->
                  <!-- Check if $actor is already assigned in current usecase -->
                  <do_if value="not @$actordef.$allow_duplicate_actor">
                    <do_all exact="$actordefs.count" counter="$actordefidx">
                      <do_if value="$actor" exact="@$Actors.{$actordefs.{$actordefidx}.$name}">
                        <!-- Mark $actor for removal from candidates -->
                        <set_value name="$actor" exact="null" />
                        <break />
                      </do_if>
                    </do_all>
                  </do_if>

                  <!-- Check criteria in two passes: $filter in pass 1, $excludefilter in pass 2 -->
                  <do_if value="$actor">
                    <do_all exact="2" counter="$criteriapass">
                      <set_value name="$filtertable" exact="table[
                                 $actor = $actor,
                                 $location = $location,
                                 $criteria = (if $criteriapass == 2 then @$actordef.$excludefilter else @$actordef.$filter),
                                 $exclude = ($criteriapass == 2),
                                 $allow_player = @$actordef.$allow_player,
                                 $allow_walk_to_position = @$actordef.$allow_walk_to_position]" />
                      <do_if value="$filtertable.$criteria">
                        <signal_cue_instantly cue="CheckFilterCriteria" param="$filtertable" />
                        <do_if value="not $filtertable.$met">
                          <do_if value="$filtertable.$error? and not $criterionerror?">
                            <debug_text text="'NPC usecase %s specifies invalid filter criterion %s for actor %s'.[$UseCaseDef.$name, $filtertable.$error, $actorkey]" filter="error" />
                            <set_value name="$criterionerror" />
                          </do_if>
                          <set_value name="$actor" exact="null" />
                          <break />
                        </do_if>
                      </do_if>
                    </do_all>
                  </do_if>
                  <!-- After all filter/exclude checks, check if candidate is still valid. If invalid, remove from candidates -->
                  <do_if value="not $actor">
                    <remove_value name="$actorcandidates.{$j}" />
                  </do_if>
                </do_all>
                <!-- Assign actor, or abort if required actor was not found -->
                <do_if value="$actorcandidates.count">
                  <set_value name="$Actors.{$actorkey}" exact="$actorcandidates.random" />
                  <debug_text text="'For usecase %s, selected actor %s = %s %s at location %s (%s %s) - picked from %s candidate(s): %s'.[$UseCaseDef.$name, $actorkey, $Actors.{$actorkey}, $Actors.{$actorkey}.knownname, $locationkey, $location, $location.knownname, $actorcandidates.count, $actorcandidates]" chance="$DebugChance" />
                </do_if>
                <do_elseif value="$pass == 1">
                  <debug_text text="'Cannot start usecase %s, required actor %s is not present at location %s (%s %s) or already assigned to another usecase'.[$UseCaseDef.$name, $actorkey, $locationkey, $location, $location.knownname]" chance="$DebugChance" />
                  <set_value name="event.param.$Error" exact="true" />
                  <break />
                </do_elseif>
                <do_else>
                  <debug_text text="'For usecase %s, optional actor %s is not present at location %s (%s %s) or already assigned to another usecase'.[$UseCaseDef.$name, $actorkey, $locationkey, $location, $location.knownname]" chance="$DebugChance" />
                </do_else>
              </do_all>
            </do_all>

            <!-- Fill $AbortingUseCases: If any actor was already assigned to an existing UseCase, the old UseCase must be aborted -->
            <do_if value="event.param.$Error" negate="true">
              <do_all exact="$actordefs.count" counter="$i">
                <set_value name="$actordef" exact="$actordefs.{$i}" />
                <set_value name="$actorkey" exact="$actordef.$name" />
                <set_value name="$actor" exact="@$Actors.{$actorkey}" />
                <do_if value="$actor">
                  <include_actions ref="GetAssignedActorCue" />
                  <do_if value="$actorcue and not $AbortingUseCases.indexof.{$actorcue}">
                    <!-- Actor is assigned to an old UseCase, which is not marked as aborting yet -->
                    <do_if value="$Priority le $actorcue.$Priority">
                      <debug_text text="'Cannot start usecase %s with priority %s, actor %s (%s %s) is already assigned in existing usecase %s with priority %s'.[$UseCaseDef.$name, $Priority, $actorkey, $actor, $actor.knownname, $actorcue.$UseCaseDef.$name, $actorcue.$Priority]" chance="$DebugChance" />
                      <set_value name="event.param.$Error" exact="true" />
                      <break />
                    </do_if>
                    <append_to_list name="$AbortingUseCases" exact="$actorcue" />
                  </do_if>
                  <!-- If the actor's $filter has a controlposition, we have to reserve it for this usecase -->
                  <set_value name="$location" exact="@$Locations.{$actordef.$location}" />
                  <do_if value="$location">
                    <do_all exact="@$actordef.$filter.count" counter="$criterionidx">
                      <set_value name="$criterion" exact="$actordef.$filter.{$criterionidx}" />
                      <do_if value="typeof $criterion == datatype.controlposition">
                        <set_value name="$actorslot" exact="$location.controlposition.{$criterion}.roomslot" />
                        <include_actions ref="GetReservedActorSlotCue" />
                        <do_if value="$actorslotcue and not $AbortingUseCases.indexof.{$actorslotcue}">
                          <!-- Slot is reserved by an old UseCase, which is not marked as aborting yet -->
                          <do_if value="$Priority le $actorslotcue.$Priority">
                            <debug_text text="'Cannot start usecase %s with priority %s, controlposition %s (%s) is reserved by existing usecase %s with priority %s'.[$UseCaseDef.$name, $Priority, $criterion, $actorslot, $actorslotcue.$UseCaseDef.$name, $actorslotcue.$Priority]" chance="$DebugChance" />
                            <set_value name="event.param.$Error" exact="true" />
                            <break />
                          </do_if>
                          <append_to_list name="$AbortingUseCases" exact="$actorslotcue" />
                        </do_if>
                        <do_if value="not $ReservedSlots.indexof.{$actorslot}">
                          <append_to_list name="$ReservedSlots" exact="$actorslot" />
                        </do_if>
                      </do_if>
                    </do_all>
                    <do_if value="event.param.$Error">
                      <break />
                    </do_if>
                  </do_if>
                </do_if>
              </do_all>
            </do_if>

          </actions>
        </cue>

        <cue name="UseCase" instantiate="true" namespace="this">
          <conditions>
            <check_any>
              <!-- Instantiating cue gets signalled with a trigger parameter (note that signals to the UseCase instance have a different meaning and are not caught here) -->
              <event_cue_signalled />
              <!-- or player gets signalled with 'npc_usecase' and trigger parameter (providing usecase access to AI scripts) -->
              <event_object_signalled object="player.entity" param="'npc_usecase'" />
            </check_any>
          </conditions>
          <actions>
            <!-- NOTE: This cue instance gets registered and the cue variables will be accessible by UseCaseManager, other use cases, and helper cues. -->
            <!-- The following variables must be externally available (using CamelCase, unlike "private" variables in lowercase): -->
            <set_value name="$TriggerParam" exact="if event.name == 'event_cue_signalled' then event.param else event.param2" comment="Param provided by trigger through signal" />
            <set_value name="$UseCaseDef" exact="@UseCaseManager.$UseCaseDefs.{@$TriggerParam.$name}" comment="Usecase definition" />
            <set_value name="$Locations" exact="if @$TriggerParam.$locations then $TriggerParam.$locations.clone else table[]" comment="Table of usecase locations provided by trigger, named according to $UseCaseDef" />
            <set_value name="$Actors" exact="table[]"                     comment="Table of assigned actors, named according to $UseCaseDef" />
            <create_group groupname="$ActorGroup"                         comment="Group of assigned actors, matching $Actors, for quick lookup and group event handling" />
            <create_group groupname="$ActiveActorGroup"                   comment="Group of assigned non-passive actors, a subset of $ActorGroup" />
            <set_value name="$ActorLookat" exact="table[]"                comment="Table of actor entities with a currently applied lookat actor name, also used to determine who the actor speaks to" />
            <set_value name="$ReservedSlots" exact="[]"                   comment="List of control position slots that may not be used by other UseCases or state machines" />
            <set_value name="$AbortingUseCases" exact="[]"                comment="List of UseCase cue instances that have to be aborted when this UseCase starts" />
            <set_value name="$Priority" exact="if $TriggerParam.$priority? then $TriggerParam.$priority else @$UseCaseDef.$priority" comment="UseCase priority" />
            <set_value name="$ScriptEntries" exact="@$UseCaseDef.$script" comment="Usecase script (provided by definition through either $script or $selectscript)" />
            <set_value name="$ScriptEntryIndex" exact="0"                 comment="Current entry index in usecase script" />
            <set_value name="$ScriptEntry" exact="null"                   comment="Current entry in usecase script (after resolving $select)" />
            <set_value name="$ScriptEntryActor" exact="null"              comment="Actor used in current script entry, can be null if entry is not actor-specific or actor is missing" />
            <set_value name="$ScriptEntryTasksRemaining" exact="table[]"  comment="Table of cues that are still processing tasks for the current script entry" />
            <set_value name="$DebugChance" exact="[UseCaseManager.$DebugChance, @$TriggerParam.$debugchance, @$UseCaseDef.$debugchance].max" comment="Debug chance" />
            <set_value name="$Error" exact="false"                        comment="Set to true on error during initialisation to skip further processing" />

            <debug_text text="'Attempting to activate usecase ' + @$TriggerParam.$name" chance="$DebugChance"/>
            <do_if value="not $UseCaseDef">
              <debug_text text="'Unknown NPC usecase triggered: ' + @$TriggerParam.$name" filter="error" />
              <set_value name="$Error" exact="true" />
            </do_if>
            <!-- Check usecase chance -->
            <do_if value="not $Error and $UseCaseDef.$chance?" chance="100 - @$UseCaseDef.$chance">
              <!-- <debug_text text="'Skipping NPC usecase %s because of chance=%s%%'.[$UseCaseDef.$name, $UseCaseDef.$chance]" chance="$DebugChance" /> -->
              <set_value name="$Error" exact="true" />
            </do_if>
            <!-- Check usecase timing -->
            <do_if value="not $Error and $UseCaseDef.$repeattimeout?">
              <set_value name="$lasttime" exact="@UseCaseManager.$UseCaseSettings.{$UseCaseDef.$name}.$lasttime" />
              <do_if value="(typeof $lasttime == datatype.time) and (player.age lt $lasttime + $UseCaseDef.$repeattimeout)">
                <!-- <debug_text text="'Skipping NPC usecase %s because of repeattimeout=%ss (timeout reached in %ss)'.[$UseCaseDef.$name, $UseCaseDef.$repeattimeout, $lasttime + $UseCaseDef.$repeattimeout - player.age]" chance="$DebugChance" /> -->
                <set_value name="$Error" exact="true" />
              </do_if>
            </do_if>
            <do_if value="not $Error">
              <!-- Fill $Actors, $ReservedSlots and $AbortingUseCases -->
              <signal_cue_instantly cue="FindUseCaseActors" param="this" />
            </do_if>

            <!-- Error detection finished, no new errors after this point! -->
            <do_if value="$Error">
              <cancel_cue cue="this" />
            </do_if>
            <do_else>
              <debug_text text="'Starting NPC usecase %s with priority %s, assigned actors: %s'.[$UseCaseDef.$name, $Priority, $Actors]" chance="$DebugChance" />
              <!-- Init usecase settings and remember usecase start time as $lasttime -->
              <do_if value="not UseCaseManager.$UseCaseSettings.{$UseCaseDef.$name}?">
                <set_value name="UseCaseManager.$UseCaseSettings.{$UseCaseDef.$name}" exact="table[]" />
              </do_if>
              <set_value name="UseCaseManager.$UseCaseSettings.{$UseCaseDef.$name}.$lasttime" exact="player.age" />
              <!-- Fill $ActorGroup based on $Actors -->
              <do_all exact="$Actors.keys.count" counter="$i">
                <add_to_group groupname="$ActorGroup" object="$Actors.{$Actors.keys.{$i}}" />
              </do_all>
              <!-- Fill $ActiveActorGroup, subset of $ActorGroup (exclude the player and all actors with $passive flag) -->
              <do_all exact="$UseCaseDef.$actors.count" counter="$i">
                <set_value name="$actordef" exact="$UseCaseDef.$actors.{$i}" />
                <do_if value="not @$actordef.$passive and @$Actors.{$actordef.$name}.isclass.[class.npc, class.computer]">
                  <add_to_group groupname="$ActiveActorGroup" object="$Actors.{$actordef.$name}" />
                </do_if>
              </do_all>
              <remove_value name="$actordef" />
              <!-- Abort conflicting use cases -->
              <do_all exact="$AbortingUseCases.count" counter="$i">
                <debug_text text="'  Aborting conflicting NPC usecase %s with priority %s'.[$AbortingUseCases.{$i}.$UseCaseDef.$name, $AbortingUseCases.{$i}.$Priority]" chance="$DebugChance" />
                <signal_cue_instantly cue="$AbortingUseCases.{$i}" param="'cleanup'" />
              </do_all>
              <!-- Register UseCase instance cue -->
              <append_to_list name="UseCaseManager.$ActiveUseCases" exact="this" />
              <!-- TODO: Make sure NPC state machines don't change states unexpectedly during usecase - check with Owen -->
              <!-- TODO: Make sure NPC state machines don't pick reserved NPC slots during usecase - check with Owen -->
            </do_else>
          </actions>
          <cues>

            <cue name="UseCaseStart">
              <!-- Small initial delay to allow cleanup of previous usecases, and set up of all UseCase sub-cues -->
              <delay exact="1ms" />
              <actions>
                <do_if value="$UseCaseDef.$selectscript?">
                  <!-- Select usecase script (using same selection routine as for script entries) -->
                  <set_value name="$select" exact="$UseCaseDef.$selectscript" />
                  <include_actions ref="SelectWeightedSubEntry" comment="input = $select, output = $entry" />
                  <do_if value="$entry.$script?">
                    <set_value name="$ScriptEntries" exact="$entry.$script" />
                  </do_if>
                </do_if>
                <signal_cue cue="ProcessUseCaseScript" />
              </actions>
            </cue>

            <!-- ===== Usecase script processing ===== -->

            <!-- Helper cue to determine the script entry, including chance check, requirement checks and random $select resolution, possibly recursively -->
            <!-- Signal param == signalling cue (instance of ProcessUseCaseScript or, in case of recursion, this instance) -->
            <!-- Input and output: event.param.$entry -->
            <cue name="DetermineScriptEntry" instantiate="true" namespace="this">
              <conditions>
                <event_cue_signalled />
                <check_value value="typeof event.param.$entry == datatype.table" comment="Leave non-table entries unchanged" />
              </conditions>
              <actions>
                <set_value name="$entry" exact="event.param.$entry" />

                <!-- Check $chance -->
                <do_if value="$entry.$chance?">
                  <set_value name="$entry" exact="null" chance="100 - @$entry.$chance" />
                </do_if>

                <!-- If $actor provided, check if assigned -->
                <set_value name="$actor" exact="null" />
                <do_if value="$entry.$actor?">
                  <set_value name="$actor" exact="@parent.$Actors.{$entry.$actor}" />
                  <do_if value="not $actor">
                    <set_value name="$entry" exact="null" />
                  </do_if>
                </do_if>

                <!-- $require_actor -->
                <do_if value="$entry.$require_actor?">
                  <!-- $require_actor = actor key string, or table of actor key strings mapped to true|false -->
                  <do_if value="typeof $entry.$require_actor == datatype.table">
                    <do_all exact="$entry.$require_actor.keys.count" counter="$i">
                      <set_value name="$actorkey" exact="$entry.$require_actor.keys.{$i}" />
                      <!-- Fail if existence of assigned actor (true|false) does not match the requirement (Negating to ensure comparison of two Boolean values) -->
                      <do_if value="parent.$Actors.{$actorkey}? == not $entry.$require_actor.{$actorkey}">
                        <set_value name="$entry" exact="null" />
                        <break />
                      </do_if>
                    </do_all>
                  </do_if>
                  <do_elseif value="not parent.$Actors.{$entry.$require_actor}?">
                    <set_value name="$entry" exact="null" />
                  </do_elseif>
                </do_if>

                <!-- $require_inroom -->
                <do_if value="$entry.$require_inroom? and $actor">
                  <!-- Fail if attention being inroom does not match the requirement -->
                  <do_if value="($actor.attention ge attention.inroom) == not $entry.$require_inroom">
                    <set_value name="$entry" exact="null" />
                  </do_if>
                </do_if>

                <!-- $filter / $excludefilter -->
                <do_if value="$entry.$filter? or $entry.$excludefilter?">
                  <!-- $filter/$excludefilter = table[ $ActorName1 = [ criteria... ] or true, $ActorName2 = ... ] -->
                  <do_all exact="2" counter="$criteriapass">
                    <!-- Note: $entry can be null in pass 2, but nothing will happen then -->
                    <set_value name="$filteractors" exact="if $criteriapass == 2 then @$entry.$excludefilter else @$entry.$filter" />
                    <do_if value="$filteractors">
                      <!-- <debug_text text="'Checking filter pass %s, actors = %s'.[$criteriapass, $filteractors]" chance="parent.$DebugChance" /> -->
                      <do_all exact="parent.$UseCaseDef.$actors.count" counter="$i">
                        <set_value name="$filteractorkey" exact="parent.$UseCaseDef.$actors.{$i}.$name" />
                        <set_value name="$criteria" exact="@$filteractors.{$filteractorkey}" />
                        <do_if value="$criteria">
                          <set_value name="$filteractor" exact="@parent.$Actors.{$filteractorkey}" />
                          <!-- <debug_text text="'  Found filter actor, key = %s, entity = %s'.[$filteractorkey, $filteractor]" chance="parent.$DebugChance" /> -->
                          <!-- Handle case where actor exists and criteria are defined in a list -->
                          <do_if value="$filteractor and typeof $criteria == datatype.list">
                            <set_value name="$filtertable" exact="table[
                                       $actor = $filteractor,
                                       $location = @parent.$Locations.{parent.$UseCaseDef.$actors.{$i}.$location},
                                       $criteria = $criteria,
                                       $exclude = ($criteriapass == 2),
                                       $allow_player = true,
                                       $allow_walk_to_position = false ]" />
                            <signal_cue_instantly cue="CheckFilterCriteria" param="$filtertable" />
                            <!-- <debug_text text="'  $filtertable met=%s, full=%s'.[$filtertable.$met, $filtertable]" chance="parent.$DebugChance" /> -->
                            <do_if value="not $filtertable.$met">
                              <do_if value="$filtertable.$error?">
                                <debug_text text="'NPC usecase %s script entry specifies invalid filter criterion %s for actor %s'.[parent.$UseCaseDef.$name, $filtertable.$error, $filteractorkey]" filter="error" />
                              </do_if>
                              <set_value name="$entry" exact="null" />
                              <break />
                            </do_if>
                          </do_if>
                          <!-- Otherwise handle case that in pass 1 $filter actor does not exist, or in pass 2 $excludefilter actor exists (without list of criteria) -->
                          <do_elseif value="($criteriapass == 1) == (not $filteractor)">
                            <!-- <debug_text text="'  invalid without filtertable check'" chance="parent.$DebugChance" /> -->
                            <set_value name="$entry" exact="null" />
                            <break />
                          </do_elseif>
                          <!-- In all other cases everything is fine -->
                        </do_if>
                        <!-- End actor def loop -->
                      </do_all>
                    </do_if>
                    <!-- End criteriapass loop -->
                  </do_all>
                </do_if>

                <!-- $select (do this last, so we only look at sub-entries if the parent meets the requirements) -->
                <do_if value="$entry.$select?">
                  <set_value name="$select" exact="$entry.$select" />
                  <include_actions ref="SelectWeightedSubEntry" comment="input = $select, output = $entry" />
                </do_if>

                <!-- Write back result -->
                <set_value name="event.param.$entry" exact="$entry" />
              </actions>
            </cue>

            <!-- Input: $select, Output: $entry -->
            <library name="SelectWeightedSubEntry">
              <actions>
                <!-- Select weighted entry from $select list, including recursive entry evaluation (if the result is null, the weight will be considered as 0) -->
                <set_value name="$selectentries" exact="[]" />
                <set_value name="$selectweights" exact="[]" />
                <!-- Enforce floating point weight precision even if all weights are integers -->
                <set_value name="$totalweight" exact="0.0" />
                <do_all exact="$select.count" counter="$selectidx">
                  <set_value name="$entry" exact="$select.{$selectidx}" />
                  <set_value name="$weight" exact="if $entry.$weight? then $entry.$weight else 1.0" />
                  <!-- Determine script entry recursively, to support nested $select and chance/filter support on all nesting levels -->
                  <!-- NOTE: Normally "DetermineScriptEntry" refers to the instantiating cue, but it refers to the instantiated cue if we are already in it -->
                  <signal_cue_instantly cue="if this == DetermineScriptEntry then static else DetermineScriptEntry" param="namespace" comment="Input and output = $entry" />
                  <!-- Only valid entries can be selected -->
                  <do_if value="$entry and $weight > 0.0">
                    <append_to_list name="$selectentries" exact="$entry" />
                    <append_to_list name="$selectweights" exact="$weight" />
                    <set_value name="$totalweight" exact="$weight" operation="add" />
                  </do_if>
                </do_all>
                <set_value name="$rnd" min="0.0" max="$totalweight" />
                <set_value name="$entry" exact="@$selectentries.last" comment="Fallback: Last entry, or null if there are no entries" />
                <do_all exact="$selectentries.count" counter="$selectidx">
                  <set_value name="$rnd" exact="$selectweights.{$selectidx}" operation="subtract" />
                  <do_if value="$rnd lt 0.0">
                    <set_value name="$entry" exact="$selectentries.{$selectidx}" />
                    <break />
                  </do_if>
                </do_all>
              </actions>
            </library>

            <!-- Keep reading and processing entries in the usecase script until there are incomplete tasks remaining -->
            <cue name="ProcessUseCaseScript" instantiate="true">
              <conditions>
                <event_cue_signalled />
                <check_value value="$ScriptEntryTasksRemaining.keys.count == 0" comment="Early out" />
              </conditions>
              <actions>
                <!-- Process script entries until one of them cannot be completed instantly -->
                <do_while value="$ScriptEntryTasksRemaining.keys.count == 0">
                  <!-- Finish previous script entry and reset actor -->
                  <do_if value="$ScriptEntryActor.isclass.npc">
                    <do_if value="$ScriptEntry.$templookat?">
                      <debug_text text="'NPC usecase %s: Clearing actor %s templookat'.[$UseCaseDef.$name, $ScriptEntry.$actor]" chance="$DebugChance" />
                      <remove_value name="$ActorLookat.{$ScriptEntryActor}" />
                      <clear_actor_lookat actor="$ScriptEntryActor" />
                    </do_if>
                    <do_if value="$ScriptEntry.$tempemotion?">
                      <debug_text text="'NPC usecase %s: Clearing actor %s tempemotion'.[$UseCaseDef.$name, $ScriptEntry.$actor]" chance="$DebugChance" />
                      <clear_actor_emotion actor="$ScriptEntryActor" />
                    </do_if>
                  </do_if>
                  <set_value name="$ScriptEntryActor" exact="null" />
                  <!-- Proceed to next step in the usecase script -->
                  <set_value name="$ScriptEntryIndex" operation="add" />
                  <!-- Clean up if we reached the end of the script -->
                  <do_if value="$ScriptEntryIndex gt $ScriptEntries.count">
                    <debug_text text="'NPC usecase %s done'.[$UseCaseDef.$name]" chance="$DebugChance" />
                    <signal_cue_instantly cue="UseCase" param="'cleanup'" />
                    <break />
                  </do_if>
                  <!-- Determine $ScriptEntry, including $chance evaluation, random $select resolution, and requirement checks -->
                  <set_value name="this.$entry" exact="$ScriptEntries.{$ScriptEntryIndex}" />
                  <signal_cue_instantly cue="DetermineScriptEntry" param="this" comment="Input and output = this.$entry" />
                  <set_value name="$ScriptEntry" exact="this.$entry" />
                  <!-- If entry is just a time value, use this as delay -->
                  <do_if value="typeof $ScriptEntry" exact="datatype.time">
                    <debug_text text="'NPC usecase %s step %s: Delay of %ss'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry]" chance="$DebugChance" />
                    <signal_cue_instantly cue="Delay" param="[$ScriptEntry, 1ms].max" />
                  </do_if>
                  <!-- If entry is a table with $actor, process actor instructions -->
                  <do_elseif value="$ScriptEntry.$actor?">
                    <set_value name="$ScriptEntryActor" exact="@$Actors.{$ScriptEntry.$actor}" />
                    <do_if value="$ScriptEntryActor.isclass.npc" comment="Skip if actor is missing or if actor is the player or a computer">
                      <!-- $lookat / $templookat -->
                      <do_if value="$ScriptEntry.$lookat? or $ScriptEntry.$templookat?">
                        <set_value name="$lookat" exact="if @$ScriptEntry.$templookat then @$ScriptEntry.$templookat else @$ScriptEntry.$lookat" />
                        <debug_text text="'NPC usecase %s step %s: Setting actor %s lookat = %s'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry.$actor, $lookat]" chance="$DebugChance" />
                        <!-- Store lookat name in $ActorLookat -->
                        <do_if value="$lookat">
                          <set_value name="$ActorLookat.{$ScriptEntryActor}" exact="$lookat" />
                        </do_if>
                        <do_else>
                          <remove_value name="$ActorLookat.{$ScriptEntryActor}" />
                        </do_else>
                        <!-- Apply lookat actor (Sanity check: Process lookat only if entity is actually nearby on the same object) -->
                        <set_value name="$lookat" exact="if $lookat == 'player' then player.entity else @$Actors.{$lookat}" />
                        <do_if value="$lookat and $ScriptEntryActor != $lookat and $ScriptEntryActor.object == $lookat.object and $lookat.isclass.[class.npc, class.player] and $ScriptEntryActor.distanceto.{$lookat} lt 40m">
                          <set_actor_lookat actor="$ScriptEntryActor" component="$lookat" />
                        </do_if>
                        <do_else>
                          <clear_actor_lookat actor="$ScriptEntryActor" />
                        </do_else>
                      </do_if>
                      <!-- $emotion / $tempemotion -->
                      <do_if value="$ScriptEntry.$emotion? or $ScriptEntry.$tempemotion?">
                        <set_value name="$emotion" exact="if @$ScriptEntry.$tempemotion then @$ScriptEntry.$tempemotion else @$ScriptEntry.$emotion" />
                        <debug_text text="'NPC usecase %s step %s: Setting actor %s emotion = %s'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry.$actor, $emotion]" chance="$DebugChance" />
                        <do_if value="$emotion">
                          <set_actor_emotion actor="$ScriptEntryActor" emotion="$emotion" />
                        </do_if>
                        <do_else>
                          <clear_actor_emotion actor="$ScriptEntryActor" />
                        </do_else>
                      </do_if>
                      <!-- $speak / $selectspeak (must be after $lookat / $templookat, so we can determine who the NPC is speaking to (can be overridden with $recipient) -->
                      <do_if value="$ScriptEntry.$speak? or $ScriptEntry.$selectspeak?">
                        <set_value name="$speakline" exact="if $ScriptEntry.$speak? then $ScriptEntry.$speak else $ScriptEntry.$selectspeak.random" />
                        <debug_text text="'NPC usecase %s step %s: Actor %s speaking line %s'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry.$actor, $speakline]" chance="$DebugChance" />
                        <signal_cue_instantly cue="Speak" param="$speakline" />
                      </do_if>
                      <do_elseif value="($ScriptEntry.$speak_to_male? or $ScriptEntry.$selectspeak_to_male?) and ($ScriptEntry.$speak_to_female? or $ScriptEntry.$selectspeak_to_female?)">
                        <set_value name="$speakline" exact="table[
                                   $to_male = (if $ScriptEntry.$speak_to_male? then $ScriptEntry.$speak_to_male else $ScriptEntry.$selectspeak_to_male.random),
                                   $to_female = (if $ScriptEntry.$speak_to_female? then $ScriptEntry.$speak_to_female else $ScriptEntry.$selectspeak_to_female.random) ]" />
                        <debug_text text="'NPC usecase %s step %s: Actor %s speaking line %s (male) / %s (female)'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry.$actor, $speakline.$to_male, $speakline.$to_female]" chance="$DebugChance" />
                        <signal_cue_instantly cue="Speak" param="$speakline" />
                      </do_elseif>
                      <!-- $walkto / $runto -->
                      <do_if value="$ScriptEntry.$runto?">
                        <debug_text text="'NPC usecase %s step %s: Actor %s running to %s'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry.$actor, $ScriptEntry.$runto]" chance="$DebugChance" />
                        <signal_cue_instantly cue="Walk" param="[ $ScriptEntry.$runto, true ]" />
                      </do_if>
                      <do_elseif value="$ScriptEntry.$walkto?">
                        <debug_text text="'NPC usecase %s step %s: Actor %s walking to %s'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry.$actor, $ScriptEntry.$walkto]" chance="$DebugChance" />
                        <signal_cue_instantly cue="Walk" param="[ $ScriptEntry.$walkto, false ]" />
                      </do_elseif>
                    </do_if>
                  </do_elseif>
                  <!-- If entry is a table without $actor, allow resetting $lookat and/or $emotion for all actors -->
                  <do_else>
                    <do_if value="$ScriptEntry.$lookat? and $ScriptEntry.$lookat == null">
                      <debug_text text="'NPC usecase %s step %s: Reset all lookats'.[$UseCaseDef.$name, $ScriptEntryIndex]" chance="$DebugChance" />
                      <do_all exact="$ActorGroup.count" counter="$actoridx">
                        <do_if value="$ActorGroup.{$actoridx}.isclass.npc">
                          <clear_actor_lookat actor="$ActorGroup.{$actoridx}" />
                        </do_if>
                      </do_all>
                      <clear_table table="$ActorLookat" />
                    </do_if>
                    <do_if value="$ScriptEntry.$emotion? and $ScriptEntry.$emotion == null">
                      <debug_text text="'NPC usecase %s step %s: Reset all emotions'.[$UseCaseDef.$name, $ScriptEntryIndex]" chance="$DebugChance" />
                      <do_all exact="$ActorGroup.count" counter="$actoridx">
                        <do_if value="$ActorGroup.{$actoridx}.isclass.npc">
                          <clear_actor_emotion actor="$ActorGroup.{$actoridx}" />
                        </do_if>
                      </do_all>
                    </do_if>
                  </do_else>
                  <!-- $skipafter / $abortafter (used in combination with $speak / $selectspeak / $walkto, allow continuing with the next instruction in parallel after a delay) -->
                  <do_if value="$ScriptEntry.$skipafter?">
                    <debug_text text="'NPC usecase %s step %s: Will skip any blocking instructions in this step after %ss'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry.$skipafter]" chance="$DebugChance" />
                    <signal_cue_instantly cue="SkipAfterDelay" param="[[$ScriptEntry.$skipafter, 1ms].max, false]" />
                  </do_if>
                  <do_elseif value="$ScriptEntry.$abortafter?">
                    <debug_text text="'NPC usecase %s step %s: Will abort usecase if this step is not completed after %ss'.[$UseCaseDef.$name, $ScriptEntryIndex, $ScriptEntry.$abortafter]" chance="$DebugChance" />
                    <signal_cue_instantly cue="SkipAfterDelay" param="[[$ScriptEntry.$abortafter, 1ms].max, true]" />
                  </do_elseif>
                </do_while>
              </actions>
            </cue>

            <cue name="Delay" instantiate="true">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <actions>
                <set_value name="$ScriptEntryTasksRemaining.{Delay}" />
                <set_value name="Delay.$delaytime" exact="event.param" />
              </actions>
              <cues>
                <cue name="DoDelay">
                  <delay exact="Delay.$delaytime" />
                </cue>
                <cue name="OnDelayFinished">
                  <conditions>
                    <check_any>
                      <event_cue_completed cue="DoDelay" />
                      <event_cue_signalled cue="SkipRemainingTasks" />
                    </check_any>
                  </conditions>
                  <actions>
                    <remove_value name="$ScriptEntryTasksRemaining.{Delay}" />
                    <cancel_cue cue="Delay" />
                    <signal_cue cue="ProcessUseCaseScript" />
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="Speak" instantiate="true">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <actions>
                <do_if value="typeof event.param == datatype.list">
                  <set_value name="Speak.$page" exact="event.param.{1}" />
                  <set_value name="Speak.$line" exact="event.param.{2}" />
                </do_if>
                <do_else>
                  <set_value name="Speak.$page" exact="$ScriptEntryActor.page" />
                  <set_value name="Speak.$line" exact="event.param" />
                </do_else>
                <!-- Determine who the speaker is talking to. If undefined and not explicitly talking to or looking at the player, consider it as a monologue, so it will be treated as a background speak. -->
                <set_value name="Speak.$backgroundcomm" exact="@$ScriptEntry.$allow_comm_chatter" />
                <set_value name="$recipientname" exact="if $ScriptEntry.$recipient? then $ScriptEntry.$recipient else @$ActorLookat.{$ScriptEntryActor}" />
                <do_if value="$recipientname == 'player'">
                  <set_value name="Speak.$recipient" exact="player.entity" />
                </do_if>
                <do_elseif value="@$Actors.{$recipientname}">
                  <set_value name="Speak.$recipient" exact="@$Actors.{$recipientname}" />
                </do_elseif>
                <do_else>
                  <!-- Fallback: Monologue (speak to self), but enable backgroundcomm if we were *supposed* to speak to an actor at another location, even though the designated recipient is not assigned to the usecase -->
                  <set_value name="Speak.$recipient" exact="$ScriptEntryActor" />
                  <do_if value="$recipientname and not $ScriptEntry.$allow_comm_chatter?">
                    <do_all exact="$UseCaseDef.$actors.count" counter="$i">
                      <do_if value="not Speak.$speakerlocation? and @$Actors.{$UseCaseDef.$actors.{$i}.$name} == $ScriptEntryActor">
                        <set_value name="Speak.$speakerlocation" exact="$UseCaseDef.$actors.{$i}.$location" />
                      </do_if>
                      <do_elseif value="not Speak.$recipientlocation? and $UseCaseDef.$actors.{$i}.$name == $recipientname">
                        <set_value name="Speak.$recipientlocation" exact="$UseCaseDef.$actors.{$i}.$location" />
                      </do_elseif>
                    </do_all>
                    <set_value name="Speak.$backgroundcomm" exact="Speak.$speakerlocation? and Speak.$recipientlocation? and (Speak.$speakerlocation != Speak.$recipientlocation)" />
                  </do_if>
                </do_else>

                <!-- If gender-specific lines were provided, select correct line -->
                <do_if value="typeof Speak.$line == datatype.table">
                  <set_value name="Speak.$line" exact="if @Speak.$recipient.isfemale then Speak.$line.$to_female else Speak.$line.$to_male" />
                </do_if>
                <!-- If line is a gender-specific honorific, adjust based on gender of recipient -->
                <do_elseif value="@Speak.$recipient.isfemale and Speak.$page == $ScriptEntryActor.page and param.voice.female_honorifics.{Speak.$line}?">
                  <set_value name="Speak.$line" exact="param.voice.female_honorifics.{Speak.$line}" />
                </do_elseif>

                <set_value name="Speak.$broadcast" exact="@$ScriptEntry.$broadcast" />
                <set_value name="Speak.$voiceover" exact="@$UseCaseDef.$voiceover" />
                <set_value name="Speak.$priority" exact="if Speak.$voiceover then 99 else (@$UseCaseDef.$speakpriority)i" />
                <set_value name="Speak.$actor" exact="$ScriptEntryActor" />

                <do_if value="not Speak.$page">
                  <!-- Speaking not supported -->
                  <debug_text text="'NPC usecase %s, actor %s: Invalid speaker page %s, skipping instruction'.[$UseCaseDef.$name, $ScriptEntry.$actor, Speak.$page]" chance="$DebugChance" />
                  <cancel_cue cue="Speak" />
                </do_if>
                <do_else>
                  <set_value name="$ScriptEntryTasksRemaining.{Speak}" />
                  <speak actor="Speak.$actor" page="Speak.$page" line="Speak.$line" recipient="Speak.$recipient" backgroundcomm="Speak.$backgroundcomm" broadcast="Speak.$broadcast" voiceover="Speak.$voiceover" priority="Speak.$priority" />
                </do_else>
              </actions>
              <cues>
                <cue name="OnSpeakFinished">
                  <conditions>
                    <check_any>
                      <event_speak_finished actor="$ScriptEntryActor" page="Speak.$page" line="Speak.$line" />
                      <event_cue_signalled cue="SkipRemainingTasks" />
                    </check_any>
                  </conditions>
                  <actions>
                    <!-- Note: If this task is skipped, the speak can continue. The usecase script can intentionally interrupt the task to let other things happen in parallel. -->
                    <remove_value name="$ScriptEntryTasksRemaining.{Speak}" />
                    <cancel_cue cue="Speak" />
                    <signal_cue cue="ProcessUseCaseScript" />
                  </actions>
                </cue>
              </cues>
            </cue>

            <cue name="Walk" instantiate="true">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <actions>
                <set_value name="Walk.$controlposition" exact="event.param.{1}" />
                <set_value name="Walk.$running" exact="event.param.{2}" />
                <!-- Determine destination slot -->
                <set_value name="Walk.$location" exact="$ScriptEntryActor.room.slotcontext" />
                <set_value name="Walk.$destslot" exact="@Walk.$location.controlposition.{Walk.$controlposition}.roomslot" />
                <set_value name="Walk.$destnpc" exact="@Walk.$location.controlposition.{Walk.$controlposition}.entity" />
                <do_if value="not Walk.$destslot">
                  <!-- Invalid walk destination -->
                  <debug_text text="'NPC usecase %s, actor %s: Invalid walking destination %s, skipping instruction'.[$UseCaseDef.$name, $ScriptEntry.$actor, Walk.$controlposition]" chance="$DebugChance" />
                  <cancel_cue cue="Walk" />
                </do_if>
                <do_elseif value="Walk.$destnpc and Walk.$destnpc != $ScriptEntryActor">
                  <!-- Slot already in use by another NPC -->
                  <debug_text text="'NPC usecase %s, actor %s: Destination %s already assigned to %s %s, skipping instruction'.[$UseCaseDef.$name, $ScriptEntry.$actor, Walk.$controlposition, Walk.$destnpc, Walk.$destnpc.knownname]" chance="$DebugChance" />
                  <cancel_cue cue="Walk" />
                </do_elseif>
                <do_elseif value="Walk.$destnpc == $ScriptEntryActor and not $ScriptEntryActor.isintransit and not $ScriptEntryActor.isbusy">
                  <!-- Actor is already at the destination -->
                  <debug_text text="'NPC usecase %s, actor %s: Already at destination %s, skipping instruction'.[$UseCaseDef.$name, $ScriptEntry.$actor, Walk.$controlposition]" chance="$DebugChance" />
                  <cancel_cue cue="Walk" />
                </do_elseif>
                <do_else>
                  <debug_text text="'NPC usecase %s, actor %s: Starting movement to room slot %s (%s)'.[$UseCaseDef.$name, $ScriptEntry.$actor, Walk.$destslot, Walk.$controlposition]" chance="$DebugChance" />
                  <set_value name="$ScriptEntryTasksRemaining.{Walk}" />
                  <!-- TODO: Pass running flag / run speed -->
                  <signal_objects object="$ScriptEntryActor" param="'npc_to_post'" param2="table[ $NPCSlot = Walk.$destslot ]" />
                  <!--TODO @Owen - the slot is not yet reserved! Figure out how to do this well.-->
                </do_else>
              </actions>
              <cues>
                <!-- TODO: Replace this workaround, there should be a proper event in OnWalkFinished -->
                <cue name="CheckWalkFinished" checkinterval="1s">
                  <conditions>
                    <check_any>
                      <check_value value="$ScriptEntryActor.roomslot == Walk.$destslot and not $ScriptEntryActor.isintransit and not $ScriptEntryActor.isbusy" />
                      <check_age min="Walk.time + 20s" comment="Prevent getting stuck forever" />
                    </check_any>
                  </conditions>
                </cue>
                <cue name="OnWalkFinished">
                  <conditions>
                    <check_any>
                      <event_cue_completed cue="CheckWalkFinished" />
                      <event_cue_signalled cue="SkipRemainingTasks" />
                    </check_any>
                  </conditions>
                  <actions>
                    <remove_value name="$ScriptEntryTasksRemaining.{Walk}" />
                    <cancel_cue cue="Walk" />
                    <signal_cue cue="ProcessUseCaseScript" />
                  </actions>
                </cue>
              </cues>
            </cue>

            <!-- Signalled to skip all remaining tasks for current script entry after a delay, or even abort the usecase
            (but this is not an actual task, so the processing cue doesn't have to wait for the $skipafter delay itself) -->
            <cue name="SkipAfterDelay" instantiate="true">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <actions>
                <set_value name="SkipAfterDelay.$curindex" exact="$ScriptEntryIndex" />
                <set_value name="SkipAfterDelay.$delaytime" exact="event.param.{1}" />
                <set_value name="SkipAfterDelay.$abort" exact="event.param.{2}" />
              </actions>
              <cues>
                <cue name="DoDelayAndSkip">
                  <delay exact="SkipAfterDelay.$delaytime" />
                  <actions>
                    <!-- Only skip remaining tasks if the script processing hasn't already moved on in the meantime -->
                    <do_if value="SkipAfterDelay.$curindex" exact="$ScriptEntryIndex">
                      <do_if value="SkipAfterDelay.$abort">
                        <debug_text text="'NPC usecase %s step %s timeout reached - aborting'.[$UseCaseDef.$name, $ScriptEntryIndex]" chance="$DebugChance" />
                        <signal_cue_instantly cue="UseCase" param="'cleanup'" />
                      </do_if>
                      <do_else>
                        <debug_text text="'NPC usecase %s step %s timeout reached - continuing with next step'.[$UseCaseDef.$name, $ScriptEntryIndex]" chance="$DebugChance" />
                        <signal_cue cue="SkipRemainingTasks" />
                      </do_else>
                    </do_if>
                  </actions>
                </cue>
              </cues>
            </cue>

            <!-- Cue to be signalled when remaining tasks should be skipped (listeners for the event are elsewhere) -->
            <cue name="SkipRemainingTasks" instantiate="true">
              <conditions>
                <!-- Use event condition just to keep cue alive within the UseCase instance tree -->
                <event_cue_signalled />
                <check_value value="false" comment="Optimisation, no need to instantiate" />
              </conditions>
            </cue>

            <!-- ===== Abort triggers ===== -->

            <!-- Handle a usecase actor getting killed (abort in case of active actor, clean up and continue in case of passive actor) -->
            <cue name="AbortedByKilledActor" instantiate="true">
              <conditions>
                <event_object_destroyed group="$ActorGroup" />
              </conditions>
              <actions>
                <debug_text text="'Actor %s of NPC usecase %s was killed'.[event.object, $UseCaseDef.$name]" chance="$DebugChance" />
                <do_if value="$ActiveActorGroup.indexof.{event.object} or $ScriptEntryActor == event.object">
                  <signal_cue_instantly cue="UseCase" param="'cleanup'" />
                </do_if>
                <do_else>
                  <!-- Remove actor from usecase and continue without it -->
                  <do_all exact="$Actors.keys.count" counter="$i" reverse="true">
                    <do_if value="$Actors.{$Actors.keys.{$i}}" exact="event.object">
                      <remove_value name="$Actors.{$Actors.keys.{$i}}" />
                      <!-- Don't break because actor could be assigned multiple times with $allow_duplicate_actor -->
                    </do_if>
                  </do_all>
                  <remove_value name="$ActorLookat.{event.object}" />
                </do_else>
              </actions>
            </cue>

            <!-- Abort if conversation is started with one of the active usecase actors -->
            <cue name="AbortedByConversation">
              <conditions>
                <event_conversation_started />
                <check_value value="$ActiveActorGroup.indexof.{event.object}" />
              </conditions>
              <actions>
                <debug_text text="'Conversation started with actor %s of NPC usecase %s'.[event.object, $UseCaseDef.$name]" chance="$DebugChance" />
                <signal_cue_instantly cue="UseCase" param="'cleanup'" />
              </actions>
            </cue>

            <!-- ===== Cleanup ===== -->

            <cue name="Cleanup">
              <conditions>
                <!-- NOTE: At this point UseCase is the instance, not the instantiating cue -->
                <event_cue_signalled cue="UseCase" />
                <check_value value="event.param" exact="'cleanup'" />
              </conditions>
              <actions>
                <debug_text text="'Cleaning up NPC usecase %s'.[$UseCaseDef.$name]" chance="$DebugChance" />
                <set_value name="$ScriptEntryTasksRemaining.{Cleanup}" comment="Just to prevent ProcessUseCaseScript from running again" />
                <do_if value="not $Error">
                  <!-- Do these cleanup tasks only if usecase was actually started -->
                  <do_all exact="$ActorGroup.count" counter="$actoridx">
                    <do_if value="$ActorGroup.{$actoridx}.isclass.npc">
                      <do_if value="not @$TriggerParam.$keeplookat">
                        <clear_actor_lookat actor="$ActorGroup.{$actoridx}" />
                      </do_if>
                      <do_if value="not @$TriggerParam.$keepemotion">
                        <clear_actor_emotion actor="$ActorGroup.{$actoridx}" />
                      </do_if>
                    </do_if>
                  </do_all>
                  <!-- TODO: Reset other temporary states (NPC state machine states, reserved slots?) -->
                </do_if>
                <!-- Unregister UseCase instance cue -->
                <remove_value name="UseCaseManager.$ActiveUseCases.{UseCaseManager.$ActiveUseCases.indexof.{UseCase}}" />
                <cancel_cue cue="UseCase" />
              </actions>
            </cue>

          </cues>
          <!-- End of UseCase cue -->
        </cue>

      </cues>
    </cue>

    <!-- Special usecase triggers that are not integrated in other scripts -->
    <cue name="Triggers">
      <conditions>
        <event_cue_signalled cue="md.Setup.Start" />
      </conditions>
      <cues>

        <cue name="OnShipInDistress" instantiate="true" namespace="this">
          <conditions>
            <event_object_signalled object="player.galaxy" param="'ship_in_distress'"/>
            <!-- param2="defending ship" param3="attacking ship" -->
            <check_value value="event.param2.attention" min="attention.visible" />
            <check_value value="@event.param2.pilot.controlled == event.param2" />
            <check_value value="player.room.isclass.cockpit" />
          </conditions>
          <actions>
            <do_if value="event.param2.isclass.[class.ship_m, class.ship_l, class.ship_xl]">
              <signal_cue_instantly cue="UseCase" param="table[ $name = '$Combat_Large_Attacked_CallingForHelp', $actors = table[ $Captain = event.param2.pilot ] ]" />
            </do_if>
            <do_else>
              <signal_cue_instantly cue="UseCase" param="table[ $name = '$Combat_Small_Attacked_CallingForHelp', $actors = table[ $Attacked = event.param2.pilot ] ]" />
            </do_else>
          </actions>
        </cue>

        <cue name="OnPlayerShipFriendlyFire" instantiate="true" namespace="this">
          <conditions>
            <event_object_attacked group="global.$PlayerOccupiedShipGroup" />
            <check_value value="@event.param.pilot.isclass.npc and event.param.pilot.page" />
            <check_value value="not event.param.hasrelation.enemy.{faction.player}" />
          </conditions>
          <actions>
            <!-- Make the attacker apologise (complaint by attacked pilot is skipped because it's the player) -->
            <signal_cue_instantly cue="UseCase" param="table[ $name = '$Combat_Small_Attacked_FriendlyFire', $actors = table[ $Attacked = player.entity, $Attacker = event.param.pilot ], $priority = 30 ]" />
          </actions>
        </cue>

      </cues>
    </cue>


  </cues>
</mdscript>
