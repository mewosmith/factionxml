<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="move.generic" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="10">
  <!--

  Move to Script
  by Michael
  
  Generic routine for moving to a specific location.

  -->
  <order id="MoveGeneric" name="{1041, 541}" description="{1041, 542}" category="internal">
    <params>
      <param name="destination" type="object" text="{1041, 10027}" comment="Destination. can be a space or an object in a zone. Providing Sector and Cluster will attempt to find the nearest zone"/>
      <param name="position" default="null" type="internal" text="{1041, 10085}" comment="Position. position is treated as an offset to destination. Default: safe position on [0,0,0] of destination"/>
      <param name="rotation" default="null" type="internal" comment="Rotation. rotation the ship should have - overrides lookat"/>
      <param name="lookat" default="null" type="internal" text="{1041, 10050}" comment="Look at. position the ship should point to - overridden by rotation"/>
      <param name="noboost" default="false" type="internal" text="{1041, 10077}" comment="No boosting. set true to prevent ships boosting"/>
      <param name="disablecollisionavoidance" type="internal" default="false" text="{1041, 10028}" comment="Disable collision avoidance. HACK - disable collision-avoidance for this ship"/>
      <param name="abortpath" default="true" type="internal" text="{1041, 10000}" comment="Abort path. disable aborting existing path"/>
      <param name="forcesteering" default="false" type="internal" text="{1041, 10154}" comment="Force steering. force steering flight control model"/>
      <param name="endintargetzone" default="false" type="internal" text="{1041, 10035}" comment="End in target zone. complete this script if we are in the correct zone, no matter where"/>
      <param name="activepatrol" default="false" type="internal" text="{1041, 10002}" comment="Active patrol. Should subordinates actively engage any targets at the target location?"/>
      <param name="recallsubordinates" default="true" type="internal" comment="recall subordinates and cancel the recall of subordinates. disabled in the move.generic call from move.gate"/>
      <param name="strictblacklist" default="false" type="internal" comment="Enforce sector blacklist even if no path is possible. Should only be true if the ship does an order that results from an automated behavior."/>
      <param name="precise" default="false" type="internal" comment="Move only to the position specified as long as it is safe. Do not use if moving multiple ships to the same position"/>
      <param name="waitforatgate" default="null" type="internal" comment="Wait for object with this component ID after crossing every gate to the destination. Passed to move.gate. Only works if at least one gate is crossed."/>
      <param name="uselocalhighways" default="not this.ship.iscapitalship" type="internal" comment="Allow usage of local highways as appropriate. Note that L and XL ships will still not use local highways. Do not set to false when destination is a local highway or in a local highway.">
        <patch value="not this.ship.iscapitalship" sinceversion="10" early="true"/>
      </param>

      <param name="radius" default="null" type="internal" comment="do not engage if target is beyond this distance relative to radiusanchorpos in radiusanchorspace. only used with activepatrol."/>
      <param name="radiusanchorpos" default="null" type="internal"/>
      <param name="radiusanchorspace" default="null" type="internal"/>

      <param name="debugchance" type="bool" default="0" advanced="true" text="{1041, 10086}" comment="Print debug output">
        <input_param name="truevalue" value="100"/>
      </param>
    </params>
    <requires>
      <match shiptype="shiptype.lasertower" negate="true"/>
    </requires>
    <location object="$destination" />
  </order>
  <interrupts>
    <library>
      <actions name="CheckCanUseLocalHighways">
        <remove_value name="$resetsignalled"/>
        <set_value name="$canuselocalhighways" exact="false"/>
        <!-- we only need to make sure that no one's in formation with us at the moment that we start movement. if anyone joins our formation after we've already started moving through a highway, the follower should handle that. -->
        <do_if value="$uselocalhighways and not $bigship and not this.assignedcontrolled.isformationleader">
          <set_value name="$canuselocalhighways" exact="true"/>
        </do_if>
        <do_if value="not $locinit? and not $canuselocalhighways and (@$destination.zone.islocalhighway or @$destination.islocalhighway)">
          <debug_text text="'%s %s %s currently cannot use local highways and has orders to go in a highway. reinitializing.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
          <set_value name="$resetsignalled"/>
          <remove_value name="$endzone"/>
          <signal_objects object="this.assignedcontrolled" param="'move.generic_reinitialize'"/>
        </do_if>
      </actions>
    </library>
    <handler>
      <conditions>
        <check_any>
          <event_object_target_invalid object="this.ship"/>
          <event_object_signalled object="this.assignedcontrolled" param="'move.generic_reinitialize'"/>
        </check_any>
      </conditions>
      <actions>
        <debug_text text="'%4: %1: param=%2, param2=%3 resuming at \'check\''.[event.name, @event.param, @event.param2, player.age]" chance="$debugchance"/>
        <remove_value name="$endzone"/>
        <abort_called_scripts resume="check"/>
      </actions>
    </handler>
    <handler consume="false">
      <conditions>
        <event_object_destroyed object="$destination"/>
      </conditions>
      <actions>
        <debug_text text="'destination %s %s %s %s was destroyed. aborting movement.'.[@$destination.class, @$destination.idcode, @$destination.knownname, @$destination]" chance="$debugchance"/>
        <abort_called_scripts resume="cleanup"/>
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_gravidar_has_scanned object="if $activepatrol then this.assignedcontrolled else null" check="false"/>
        <check_value value="this.sector and not this.zone.isclass.highway"/>
        <check_value value="this.assignedcontrolled.order and this.assignedcontrolled.order.state != orderstate.critical"/>
        <check_any>
          <check_all>
            <check_value value="not this.isplayerowned or not $radius or not $radiusanchorpos or not $radiusanchorspace"/>
            <count_gravidar_contacts result="$attacktarget" object="this.assignedcontrolled" maybeattackedby="this.assignedcontrolled" class="class.defensible" checkoperational="false" docked="false" min="1" multiple="false">
              <match_context macro="this.sector.macro"/>
              <match_context class="class.highway" negate="true"/>
              <match state="componentstate.wreck" negate="true"/>
              <match class="[class.collectable, class.buildstorage, class.asteroid]" negate="true"/>
            </count_gravidar_contacts>
          </check_all>
          <check_all>
            <check_value value="$radius and $radiusanchorpos and $radiusanchorspace"/>
            <count_gravidar_contacts result="$attacktarget" object="this.assignedcontrolled" maybeattackedby="this.assignedcontrolled" class="class.defensible" checkoperational="false" docked="false" min="1" multiple="false">
              <match_context macro="this.sector.macro"/>
              <match_context class="class.highway" negate="true"/>
              <match state="componentstate.wreck" negate="true"/>
              <match class="[class.collectable, class.buildstorage, class.asteroid]" negate="true"/>
              <match_distance value="$radiusanchorpos" space="$radiusanchorspace" max="$radius"/>
            </count_gravidar_contacts>
          </check_all>
        </check_any>
        <check_value value="this.assignedcontrolled.order.id != 'Flee'"/>
        <check_value value="this.assignedcontrolled.order.id != 'Attack' or (this.assignedcontrolled.order.$allowothertargets and this.assignedcontrolled.order.$primarytarget != $attacktarget)"/>
        <check_value value="this.assignedcontrolled.order.id != 'Board'" comment="adding an attack order with the boarding target as target will lead to us attacking the target without launching marines"/>
      </conditions>
      <actions>
        <debug_text text="'radius: %s, radiusanchorpos: %s, radiusanchorspace: %s'.[@$radius, @$radiusanchorpos, @$radiusanchorspace]" chance="0"/>
        <do_if value="$attacktarget.sector and ($attacktarget.sector == this.sector) and (this.assignedcontrolled.distanceto.{$attacktarget} le this.assignedcontrolled.maxradarrange)">
          <debug_text text="'%s %s %s in sector %s %s found hostile target %s %s %s in zone %s, sector %s %s. attacking.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, @this.sector.knownname, @this.sector, $attacktarget.idcode, $attacktarget.knownname, $attacktarget, $attacktarget.zone, @$attacktarget.sector.knownname, @$attacktarget.sector]" chance="$debugchance"/>
          <debug_text text="'move.generic about to create an Attack order. target: %s %s %s current order: %s'.[$attacktarget.idcode, $attacktarget.knownname, $attacktarget, this.assignedcontrolled.order.id]" chance="0"/>
          <create_order object="this.assignedcontrolled" id="'Attack'" immediate="true">
            <param name="primarytarget" value="$attacktarget"/>
            <param name="pursuetargets" value="false"/>
            <param name="radius" value="$radius"/>
            <param name="radiusanchorpos" value="$radiusanchorpos"/>
            <param name="radiusanchorspace" value="$radiusanchorspace"/>
            <param name="internalorder" value="true"/>
            <param name="debugchance" value="$debugchance"/>
          </create_order>
        </do_if>
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_changed_zone object="$destination"/>
      </conditions>
      <actions>
        <debug_text text="'destination: %s %s %s changed zones. adjusting course.'.[@$destination.idcode, @$destination.knownname, $destination]" chance="$debugchance"/>
        <remove_value name="$endzone"/>
        <abort_called_scripts resume="check"/>
      </actions>
    </handler>
    <!-- NB: SectorChangeHandler in move.generic is to prevent the event being handled in other scripts if we moved to a new sector on purpose. -->
    <handler ref="SectorChangeHandler"/>
  </interrupts>
  <patch sinceversion="1">
    <set_value name="$recallsubordinates" exact="true"/>
  </patch>
  <patch sinceversion="2">
    <set_value name="$radius" exact="null"/>
    <set_value name="$radiusanchorpos" exact="null"/>
    <set_value name="$radiusanchorspace" exact="null"/>
    <do_if value="(@this.assignedcontrolled.order.id == 'Escort') or (@this.assignedcontrolled.order.id == 'ProtectShip')">
      <set_value name="$activepatrol" exact="false"/>
    </do_if>
  </patch>
  <patch sinceversion="3">
    <include_interrupt_actions ref="GetBlacklistgroup"/>

    <set_value name="$returnvalue" exact="false"/>
    <!-- when patching in, initially set strictblacklist to true since that is safer. if it fails to find a path, this script should be called again with the proper flag set. -->
    <set_value name="$strictblacklist" exact="this.isplayerowned"/>
    <set_value name="$locblacklistgroup" exact="null"/>
  </patch>
  <patch sinceversion="5">
    <do_if value="@this.zone.issuperhighway and not $targetsector and @$targetzone.issuperhighway">
      <signal_objects object="this.assignedcontrolled" param="'move.generic_reinitialize'"/>
      <debug_text text="'PATCH: I and my destination are both in superhighways. reinitializing'" filter="savegame"/>
    </do_if>
  </patch>
  <patch sinceversion="6">
    <do_if value="not $waitforatgate?">
      <set_value name="$waitforatgate" exact="null"/>
    </do_if>
    <do_if value="not $canuselocalhighways?">
      <set_value name="$locinit"/>
      <include_interrupt_actions ref="CheckCanUseLocalHighways"/>
      <remove_value name="$locinit"/>
    </do_if>
  </patch>
  <patch sinceversion="7">
    <do_if value="@this.assignedcontrolled.order.id == 'Attack'">
      <set_value name="$endintargetzone" exact="true"/>
      <do_if value="$endintargetzone_input?">
        <set_value name="$endintargetzone_input" exact="true"/>
      </do_if>
      <signal_objects object="this.assignedcontrolled" param="'move.generic_reinitialize'"/>
      <debug_text text="'PATCH: reinitializing long-distance attack movement with endintargetzone set.'" filter="savegame"/>
    </do_if>
  </patch>
  <patch sinceversion="10" early="true">
    <set_value name="$uselocalhighways" exact="not this.assignedcontrolled.iscapitalship"/>
  </patch>
  <attention min="unknown">
    <actions>

      <!-- return value will be set to true if the script gets to label finish -->
      <set_value name="$returnvalue" exact="false"/>

      <include_interrupt_actions ref="GetBlacklistgroup"/>

      <set_value name="$pos_input" exact="$position" comment="can be null if position parameter is not supplied"/>

      <label name="start"/>

      <debug_text text="'start'" chance="$debugchance"/>
      <do_if value="$disablecollisionavoidance">
        <set_avoid_collisions object="this.assignedcontrolled" bigobjects="false" smallobjects="false" />
      </do_if>
      <set_value name="$bigship" exact="this.assignedcontrolled.iscapitalship"/>
      <set_value name="$locinit"/>
      <!-- this sets $canuselocalhighways. this needs to be re-evaluated every time we are about to do a move_to that might use local highways since ships may have joined formation in the meantime. -->
      <include_interrupt_actions ref="CheckCanUseLocalHighways"/>
      <remove_value name="$locinit"/>

      <do_if value="@$precise">
        <debug_text text="'Warning: move.generic called with precise parameter. This will skip all safepos checks. Make sure that the specified position is safe and will remain safe for the duration of the movement.'"/>
      </do_if>

      <label name="check" />

      <wait exact="1ms" sinceversion="7"/>

      <do_if value="(not $destination.exists) or $destination.iswreck">
        <debug_text text="'ERROR: destination does not exist! destination is: %1 CHECK 1'.[$destination]" filter="error" comment="could be a valid case because if it's an object or a tempzone" chance="$debugchance"/>
        <resume label="cleanup"/>
      </do_if>

      <debug_text text="'%1 (%2) was given coordinates: %3 relative to %4 %5 (%6), %7'.[this.ship.knownname, this.ship, $position, $destination.class, $destination.knownname, $destination.macro, @$destination.cluster.knownname]" chance="$debugchance"/>

      <!-- INPUT CASE 1: if $destination is a zone, -->
      <do_if value="$destination.isclass.zone">
        <!-- and it is a highway, -->
        <do_if value="$destination.isclass.highway">
          <debug_text text="'%1(%2) has been told to fly into highway %3(%4).'.[this.ship.knownname, this.ship, $destination.knownname, $destination]" chance="$debugchance"/>
          <!-- and we are in a big ship, and we are going to a local highway. (big ships can go in superhighways now) -->
          <do_if value="not $canuselocalhighways and $destination.islocalhighway">
            <!-- fail and throw an error. -->
            <debug_text text="'%s %s %s cannot use local highways and has been told to go into a local highway. it cannot do so.'.[this.ship.knownname, this.ship, this.ship.idcode]" filter="error"/>
            <resume label="cleanup"/>
          </do_if>
          <!-- and we are in something that can go in a highway, -->
          <do_else>
            <!-- move into the highway and end when we're inside
              note: superhighways are not in sectors -->
            <set_value name="$targetsector" exact="$destination.destination.sector"/>
            <!-- the highway itself is a zone -->
            <set_value name="$targetzone" exact="$destination"/>
            <!-- we will have to override endintargetzone to enable it since we cannot use positions in highways. -->
            <set_value name="$endintargetzone"/>
            <set_value name="$position" exact="null"/>
            <set_value name="$positionspace" exact="$targetzone"/>
          </do_else>
        </do_if>
        <!-- if $destination is not a highway, -->
        <do_else>
          <set_value name="$targetsector" exact="$destination.sector"/>
          <!-- but is a temp zone, -->
          <do_if value="$destination.istempzone">
            <!-- move relative to the sector. -->
            <set_value name="$targetzone" exact="null"/>
            <!-- when the targetzone is not set, we cannot use endintargetzone or the long distance move check will keep triggering -->
            <set_value name="$endintargetzone" exact="null"/>
            <do_if value="not $positionspace?">
              <do_if value="$position">
                <!-- Input: $position relative to $destination. Output: $position relative to $targetsector. -->
                <create_position name="$position" space="$targetsector" value="$position" object="$destination"/>
              </do_if>
              <do_else>
                <create_position name="$position" space="$targetsector" object="$destination"/>
              </do_else>
            </do_if>
            <set_value name="$positionspace" exact="$targetsector"/>
            <debug_text text="'%1 %2 is at %3 relative to %4 %5'.[$destination.class, $destination, $position, $positionspace.class, $positionspace]" chance="$debugchance"/>
          </do_if>
          <!-- if it is not a temp zone -->
          <do_else>
            <!-- we're fine. use input as is. -->
            <set_value name="$targetzone" exact="$destination"/>
            <set_value name="$positionspace" exact="$targetzone"/>
          </do_else>
        </do_else>
      </do_if>
      <!-- INPUT CASE 2: if $destination is a sector or cluster, -->
      <do_elseif value="$destination.isclass.sector or $destination.isclass.cluster">

        <!-- and we want to go somewhere specific in that sector, -->
        <do_if value="$pos_input and $destination.isclass.sector">
          <!-- stick to sector coordinates. we'll be checking for obstructions when we get close. -->
          <set_value name="$targetsector" exact="$destination"/>
          <set_value name="$targetzone" exact="null"/>
          <!-- when the targetzone is not set, we cannot use endintargetzone or the long distance move check will keep triggering -->
          <set_value name="$endintargetzone" exact="null"/>
          <set_value name="$positionspace" exact="$targetsector"/>
          <set_value name="$position" exact="$pos_input"/>
          <resume label="move"/>
        </do_if>

        <!-- if no position is supplied, we just want to get to the sector or cluster.
              Is the ship already there? -->
        <do_elseif value="this.ship.hascontext.{$destination}">
          <debug_text text="'destination is %1 %2, and the ship is already in that context'.[$destination.class, $destination.knownname]" chance="$debugchance" />
          <resume label="cleanup"/>
        </do_elseif>

        <!-- input in this case: $destination is a sector with no position, or $destination is a cluster, and we need to get there. -->
        <do_else>
          <do_if value="$pos_input and $destination.isclass.cluster">
            <!-- reset position and throw an error. -->
            <set_value name="$position" exact="position.[0, 0, 0]"/>
            <debug_text text="'ERROR: Passing in a cluster with cluster coordinates is not supported. Resetting position.'"/>
          </do_if>

          <set_value name="$endsector" exact="$destination"/>
          <do_if value="$destination.isclass.cluster">
            <debug_text text="'Attempting to find sector within : %s %s %s'.[$destination.class, $destination.knownname, $destination]" chance="$debugchance"/>
            <find_sector name="$endsector" space="$destination"/>
          </do_if>

          <do_if value="not $endsector or not $endsector.isclass.sector">
            <debug_text text="'Destination: %s %s %s is not a sector and no sector can be found in destination. Cannot get to destination.'.[$destination.class, $destination.knownname, $destination]" filter="error"/>
            <resume label="cleanup"/>
          </do_if>
          <debug_text text="'destination: %s %s %s, endsector: %s %s %s'.[$destination.class, $destination.knownname, $destination, $endsector.class, $endsector.knownname, $endsector]" chance="$debugchance"/>
          <do_if value="$canuselocalhighways">
            <get_global_path component="$pathcomponents" uselocalhighways="true" multiple="true">
              <start object="this.ship"/>
              <end object="$endsector"/>
            </get_global_path>
          </do_if>
          <do_else>
            <get_global_path component="$pathcomponents" uselocalhighways="false" multiple="true">
              <start object="this.ship"/>
              <end object="$endsector"/>
            </get_global_path>
          </do_else>
          <debug_text text="'path has %1 components. pathcomponents:'.[$pathcomponents.count]" chance="$debugchance"/>
          <do_all exact="$pathcomponents.count" counter="$Counter">
            <debug_text text="'%1 evaluated. in destination? %2. zone? %3. priority? %4. object? %5'.[$pathcomponents.{$Counter}.knownname, $pathcomponents.{$Counter}.hascontext.{$destination}, $pathcomponents.{$Counter}.isclass.zone, @$pathcomponents.{$Counter}.haspriority, $pathcomponents.{$Counter}.isclass.object]" chance="$debugchance"/>
            <do_if value="$pathcomponents.{$Counter}.hascontext.{$destination}">
              <do_if value="$pathcomponents.{$Counter}.isclass.highway">
                <continue/>
              </do_if>
              <do_elseif value="$pathcomponents.{$Counter}.isclass.zone and @$pathcomponents.{$Counter}.haspriority">
                <set_value name="$targetzone" exact="$pathcomponents.{$Counter}"/>
                <debug_text text="'%1 set. CHECK 1'.[$pathcomponents.{$Counter}.knownname]" chance="$debugchance"/>
                <break/>
              </do_elseif>
              <do_elseif value="$pathcomponents.{$Counter}.isclass.object">
                <set_value name="$targetzone" exact="$pathcomponents.{$Counter}.zone"/>
                <debug_text text="'%1 set. CHECK 2'.[$pathcomponents.{$Counter}.knownname]" chance="$debugchance"/>
                <break/>
              </do_elseif>
            </do_if>
          </do_all>
          <do_if value="@$targetzone">
            <set_value name="$targetsector" exact="$targetzone.sector"/>
            <set_value name="$positionspace" exact="$targetzone"/>
          </do_if>
          <do_else>
            <set_value name="$targetsector" exact="$endsector"/>
            <set_value name="$targetzone" exact="null"/>
            <!-- when the targetzone is not set, we cannot use endintargetzone or the long distance move check will keep triggering -->
            <set_value name="$endintargetzone" exact="null"/>
            <set_value name="$positionspace" exact="$targetsector"/>
          </do_else>
          <remove_value name="$endsector"/>
          <remove_value name="$pathcomponents"/>
        </do_else>
      </do_elseif>
      <!-- INPUT CASE 3: if $destination is an object,
            position, if given, is assumed to be relative to the object. -->
      <do_else>
        <!-- that is in a highway, enter the highway. -->
        <do_if value="$destination.zone.isclass.highway">
          <debug_text text="'%1 (%2) has been told to follow %3 (%4) which is in a highway. Moving to the highway.'.[this.ship.knownname, this.ship, $destination.knownname, $destination]" chance="$debugchance"/>
          <do_if value="$canuselocalhighways or not $destination.zone.sector">
            <set_value name="$targetsector" exact="null"/>
            <set_value name="$targetzone" exact="$destination.zone"/>
            <!-- we cannot move to coordinates inside highways. so if moving to something that is currently in a highway, we need to temporarily end the movement in the target zone. keep initial value of $endintargetzone to reset in case we move to an object that was in a highway but no longer is. -->
            <do_if value="not $endintargetzone_input?">
              <set_value name="$endintargetzone_input" exact="$endintargetzone"/>
            </do_if>
            <set_value name="$endintargetzone"/>
            <set_value name="$positionspace" exact="$targetzone"/>
            <set_value name="$position" exact="null"/>
          </do_if>
          <do_else>
            <debug_text text="'we are in a capital ship and are supposed to go to an object that is in a local highway which we cannot enter. waiting for destination to leave the highway.'" chance="$debugchance"/>
            <wait min="45s" max="60s" >
              <interrupt>
                <conditions>
                  <check_any>
                    <check_all>
                      <event_object_changed_zone object="$destination"/>
                      <check_value value="not $destination.zone.isclass.highway"/>
                    </check_all>
                    <event_object_destroyed object="$destination"/>
                  </check_any>
                </conditions>
              </interrupt>
            </wait>
            <resume label="check"/>
          </do_else>
        </do_if>
        <!-- if $destination is not in a highway, we move to the target's last known location and adjust if it changes. -->
        <do_else>
          <!-- move relative to the sector since that is much more reliable. -->
          <set_value name="$targetzone" exact="$destination.zone"/>
          <set_value name="$targetsector" exact="$destination.sector"/>
          <set_value name="$positionspace" exact="$targetsector"/>
          <!-- if we have a position relative to $destination, -->
          <do_if value="$pos_input">
            <!-- we translate that position to our positionspace. -->
            <create_position name="$position" space="$positionspace" value="$pos_input" object="$destination"/>
          </do_if>
          <!-- if we do not have an input position, -->
          <do_else>
            <!-- set the position to 0,0,0 relative to the destination object. -->
            <create_position name="$position" space="$positionspace" object="$destination"/>
          </do_else>
          <do_if value="$endintargetzone_input?">
            <!-- $endintargetzone is overridden if $destination was in a highway. if $destination is no longer in a highway, restore the input value. -->
            <set_value name="$endintargetzone" exact="$endintargetzone_input"/>
          </do_if>
        </do_else>
      </do_else>

      <label name="move" />

      <do_if value="(not $destination.exists) or $destination.iswreck">
        <debug_text text="'ERROR: destination does not exist! destination is: %1 CHECK 2'.[$destination]" filter="error" comment="could be a valid case because if it's an object or a tempzone" chance="$debugchance"/>
        <resume label="cleanup"/>
      </do_if>

      <do_if value="not @$targetsector">
        <debug_text text="'$targetsector not defined. present location: %1, %2. positionspace: %3'.[this.ship.zone.knownname, @this.ship.sector.knownname, $positionspace]" chance="$debugchance"/>
      </do_if>

      <!-- command action calculating -->
      <set_command_action commandaction="commandaction.calculating" />

      <!-- check offset position. If there is not, set a safepos on a random direction -->
      <do_if value="not $position">
        <do_if value="not $pos_initial?">
          <set_value name="$pos_initial" exact="null"/>
        </do_if>
        <do_if value="$positionspace.isclass.zone">
          <!-- if we are going to a highway, do not set a position. -->
          <do_if value="not $positionspace.isclass.highway">
            <do_if value="$destination.hascontext.{$positionspace}">
              <get_safe_pos result="$position" zone="$positionspace" object="$destination" radius="this.ship.size * 2" max="this.ship.size * 3" ignored="this.ship"/>
            </do_if>
            <do_else>
              <get_safe_pos result="$position" zone="$positionspace" radius="this.ship.size * 2" ignored="this.ship"/>
            </do_else>
            <debug_text text="'moving to a zone with no input position. new position: %s'.[$position]" chance="$debugchance"/>
          </do_if>
          <do_else>
            <debug_text text="'we are going to a highway. position is null.'" chance="$debugchance"/>
          </do_else>
        </do_if>
        <do_elseif value="$positionspace.isclass.sector">
          <do_if value="$destination.hascontext.{$positionspace}">
            <get_safe_pos result="$position" sector="$positionspace" object="$destination" radius="this.ship.size * 2" max="this.ship.size * 3" ignored="this.ship"/>
          </do_if>
          <do_else>
            <get_safe_pos result="$position" sector="$positionspace" radius="this.ship.size * 2" max="this.ship.size * 3" ignored="this.ship"/>
          </do_else>
          <debug_text text="'moving to sector with no input position. new position: %s.'.[$position]" chance="$debugchance"/>
        </do_elseif>
        <do_else>
          <debug_text text="'unhandled case. positionspace %s %s %s is neither a sector nor a zone.'.[@$positionspace.class, @$positionspace.knownname, $positionspace]" filter="error"/>
        </do_else>
      </do_if>
      <do_else>
        <!-- we have a position that might not be safe -->
        <do_if value="not $pos_initial?">
          <set_value name="$pos_initial" exact="$position"/>
        </do_if>
        <do_if value="$positionspace.isclass.sector">
          <do_if value="not @$precise">
            <get_safe_pos result="$position" sector="$positionspace" value="$position" radius="this.ship.size / 2" max="this.ship.size * 3" ignored="this.ship"/>
          </do_if>
        </do_if>
        <do_elseif value="$positionspace.isclass.zone">
          <do_if value="not @$precise">
            <get_safe_pos result="$position" zone="$positionspace" value="$position" radius="this.ship.size / 2" max="this.ship.size * 3" ignored="this.ship"/>
          </do_if>
        </do_elseif>
        <do_else>
          <debug_text text="'unhandled case. positionspace %s %s %s is neither a sector nor a zone.'.[@$positionspace.class, @$positionspace.knownname, $positionspace]" filter="error"/>
        </do_else>
        <do_if value="$position != $pos_initial">
          <debug_text text="player.age + ': warning: input position was not safe and we are now going to a new position. Ignore if this appears after short-distance movement as positionspace has likely changed.\ninput pos: %s\nnew pos: %s'.[$pos_initial, $position]" chance="$debugchance"/>
        </do_if>
      </do_else>

      <debug_text text="'initialized: \n position: %3, \n position context: %1 %2, \n distance to target position: %4'.[$positionspace.class, $positionspace.knownname, $position, @this.ship.distanceto.[$positionspace, $position]]" chance="$debugchance"/>

      <do_if value="not this.sector">
        <debug_text text="'%1 (%2) is not in a sector.\n location: %3 %4\n Order: %5\n Default Order: %6'.[this.ship.knownname, this.ship, this.ship.parent.class, this.ship.parent.knownname, this.ship.order.id, this.ship.defaultorder.id]" chance="$debugchance"/>
      </do_if>

      <debug_text text="'long-distance checks:\n this sector: %1, target sector: %2\n this sector == target sector: %3\n this zone: %4, target zone: %5 (can be null)\n this zone == target zone: %6\n distance to target position: %7\n dist le 10km? %8'.[this.sector, $targetsector, this.sector == $targetsector, this.zone, @$targetzone, this.zone == @$targetzone, @this.ship.distanceto.[$positionspace, $position], @this.ship.bboxdistanceto.[$positionspace, $position, $destination] le 10km]" chance="$debugchance"/>

      <!-- long distance -->
      <!-- NB: sometimes, tempzones are not generated in low attention even if this.ship is there (overlapping zones?) thus looping infinitely at this point.
                added check to see if our distance to where we are going (could be temp for this particular step) is more than the distance we can travel in 1 minute.
                  should be maxspeed * 60s. changed below to simplify since proper notation would be ((this.ship.maxspeed)s * 60s)m -->
      <do_if value="this.sector != $targetsector or (this.zone != $targetzone and (not @$endzone or this.zone != $endzone) and ($endintargetzone or @$targetzone.isclass.highway or this.ship.bboxdistanceto.[$positionspace, $position, $destination] gt 10km))">
        <debug_text text="'moving long distance.\n this zone: %1,\n targetzone: %2,\n endzone: %9,\n positionspace: %3 %4 (%5),\n target sector: %6 (%7),\n distance to target position: %8'.[this.zone, $targetzone, $positionspace.class, $positionspace.knownname, $positionspace, @$targetsector.knownname, $targetsector, @this.ship.bboxdistanceto.[$positionspace, $position, $destination], @$endzone]" chance="$debugchance"/>
        <do_if value="(this.sector == $targetsector) and $endintargetzone and @$endzone.exists and (this.zone == @$endzone)">
          <debug_text text="'endintargetzone is set and we are in endzone, but we are still about to move to endzone. this movement should be skipped!'" filter="error"/>
        </do_if>

        <!-- clear $intersector in case script loops back before it could be cleaned up. it will be re-evaluated. -->
        <remove_value name="$intersector"/>

        <do_if value="$targetsector and this.sector and (this.sector != $targetsector)">
          <!-- reset or clean up variables first in case earlier movement was interrupted and we are re-evaluating. -->
          <do_if value="$resetstrictblacklist?">
            <set_value name="$strictblacklist" exact="not $strictblacklist"/>
            <remove_value name="$resetstrictblacklist"/>
          </do_if>
          <remove_value name="$blacklistoverride"/>

          <set_value name="$intersector"/>

          <do_if value="$strictblacklist and this.assignedcontrolled.commander and ($targetsector == @this.assignedcontrolled.commander.sector)">
            <!-- NB: subordinates are always allowed to operate in their commander's current sector. -->
            <set_value name="$strictblacklist" exact="false"/>
            <set_value name="$resetstrictblacklist"/>
          </do_if>

          <!-- determine if we have a path to the destination. if not and the order is explicit, plot another path ignoring the sector blacklist. -->
          <get_jump_path component="$jumppath" start="this.sector" end="$targetsector" multiple="true" useblacklist="$blacklistgroup" refobject="this.assignedcontrolled"/>

          <do_if value="$jumppath.count lt 2">
            <!-- if strict blacklist enforcement is active, only exception is to leave a blacklisted sector. -->
            <do_if value="not $strictblacklist or (this.sector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled} and not $targetsector.isblacklisted.{blacklisttype.sectortravel}.{$blacklistgroup}.{this.assignedcontrolled})">
              <debug_text text="'no path found from %s %s to %s %s and order was explicit or we are leaving a blacklisted sector for one that is not. overriding blacklist. current order: %s'.[this.sector.class, this.sector.knownname, $targetsector.class, $targetsector.knownname, this.assignedcontrolled.order.id]" chance="$debugchance"/>
              <get_jump_path component="$jumppath" start="this.sector" end="$targetsector" multiple="true"/>
              <set_value name="$blacklistoverride" comment="used in the smallship case"/>
            </do_if>
            <do_else>
              <debug_text text="'no path found from %s %s to %s %s and order was not explicit. possible that all paths are covered by a blacklist. current order: %s'.[this.sector.class, this.sector.knownname, $targetsector.class, $targetsector.knownname, this.assignedcontrolled.order.id]" chance="$debugchance"/>
              <resume label="cleanup"/>
            </do_else>
          </do_if>
        </do_if>

        <!-- Inform subordinates of long distance travel (use this.$recalling_subordinates to avoid repetitions on nested calls to move.generic)
              Ordering subordinates to go on ahead is deprecated as of 3.0. lib.recall.subordinates will call in all drones, and will call in any subordinates that can dock. -->
        <do_if value="$recallsubordinates and this.assignedcontrolled.subordinates.count and not this.$recalling_subordinates?">
          <!-- There are cases where all subordinates are already docked but dock orders didn't come from RecallSubordinates. Without the handling below, this case will result in an infinite loop. -->
          <do_all exact="this.assignedcontrolled.subordinates.count" counter="$i">
            <do_if value="not this.assignedcontrolled.subordinates.{$i}.dock or not this.assignedcontrolled.subordinates.{$i}.hascontext.{this.assignedcontrolled}">
              <set_value name="$recall"/>
              <break/>
            </do_if>
          </do_all>
          <do_if value="$recall?">
            <set_value name="$locdest" exact="$destination"/>
            <set_value name="$locpos" exact="$pos_input"/>
            <do_if value="$destination.isclass.cluster">
              <set_value name="$locdest" exact="$positionspace"/>
              <set_value name="$locpos" exact="$position"/>
            </do_if>
            <do_elseif value="not $locpos">
              <set_value name="$locpos" exact="position.[0, 0, 0]"/>
            </do_elseif>

            <debug_text text="'recalling subordinates. subordinateorders: %s, recalling_subordinates: %s'.[$subordinateorders?, this.$recalling_subordinates?]" chance="$debugchance"/>
            <create_order id="'RecallSubordinates'" object="this.ship" immediate="true">
              <!--<param name="timeout" value="20s"/>-->
              <param name="destination" value="[$locdest, $locpos]"/>
              <param name="activepatrol" value="$activepatrol"/>
              <param name="debugchance" value="$debugchance"/>
            </create_order>
            <wait exact="1s" sinceversion="8"/>
            <remove_value name="$locpos"/>
            <remove_value name="$locdest"/>
            <remove_value name="$recall"/>
          </do_if>
        </do_if>

        <do_if value="(not $destination.exists) or $destination.iswreck">
          <debug_text text="'ERROR: destination does not exist! destination is: %1 CHECK 3'.[$destination]" filter="error" comment="could be a valid case because if it's an object or a tempzone" chance="$debugchance"/>
          <resume label="cleanup"/>
        </do_if>

        <!-- Determine if we have to wait for subordinates -->
        <do_for_each name="$locship" in="this.assignedcontrolled.subordinates">
          <do_if value="$locship.isoperational and (not $locship.dock or not $locship.hascontext.{this.assignedcontrolled})">
            <set_value name="$waitforsubordinates"/>
            <break/>
          </do_if>
        </do_for_each>

        <!-- in the bigship case, unify inter-sector and inter-cluster movements to move.gate.
              TODO:
                DONE  add reservation system, similar to that of jump gates, to superhighway gates,
                DONE  rename move.jumpgate to move.gate and adapt to two cases: jump gates and superhighway gates (should be largely identical),
                DONE  route to move.gate here, parameters depending on inter-sector or inter-cluster as appropriate if necessary. -->
        <!-- lots and lots of small ships moving at the exact same frame to a distant place causes the game to stutter. -->
        <!-- NB: orders can cancel orders and orders can be interrupted, so this script can validly be started while this.ship is in a highway.
                it not being in a highway is only absolutely necessary within this do_if and, if it already is in a highway, it simply moves to the highway. (caught in the else case) -->
        <do_if value="$intersector? and not @this.zone.isclass.highway and (@$waitforsubordinates or $waitforatgate or this.assignedcontrolled.iscapitalship)">
          <!-- determine where we're going in this step, and how we're getting there. -->
          <do_if value="$jumppath.count lt 2">
            <debug_text text="'ERROR: we are not at the target sector, but no jump path found from %s %s to %s %s. aborting.'.[this.sector.knownname, this.sector, $targetsector.knownname, $targetsector]" filter="error"/>
            <do_all exact="$jumppath.count" counter="$pathindex">
              <debug_text text="'jumppath entry %s: %s %s %s'.[$pathindex, $jumppath.{$pathindex}.class, $jumppath.{$pathindex}.knownname, $jumppath.{$pathindex}]"/>
            </do_all>
            <resume label="cleanup"/>
          </do_if>

          <do_if value="$jumppath.{2}.isclass.gate">
            <set_value name="$gate" exact="$jumppath.{2}"/>
            <set_value name="$gatedestination" exact="$gate.destination"/>
            <set_value name="$exitgate" exact="$gate.exit"/>
          </do_if>
          <do_else>
            <find_highway name="$highways" space="this.cluster" destination="$jumppath.{2}" multiple="true"/>
            <do_all exact="$highways.count" counter="$i">
              <do_if value="$highways.{$i}.issuperhighway and ($highways.{$i}.origin.sector == this.sector)">
                <set_value name="$gate" exact="$highways.{$i}.entry"/>
                <set_value name="$gatedestination" exact="$gate.destination"/>
                <set_value name="$exitgate" exact="$gate.exit"/>
                <break/>
              </do_if>
            </do_all>
            <remove_value name="$highways"/>
          </do_else>

          <do_if value="not @$gate.exists">
            <debug_text text="'no gate or superhighway found from sector %s %s to sector %s %s.'.[@this.sector.knownname, this.sector, $targetsector.knownname, $targetsector]" filter="error"/>
            <resume label="cleanup"/>
          </do_if>

          <debug_text text="'using %1 %2 from %3, %4 to %5, %6.'.[$gate.class, $gate, this.sector.knownname, this.cluster.knownname, $gatedestination.sector.knownname, $gatedestination.cluster.knownname]" chance="$debugchance"/>

          <!-- go there. -->
          <set_value name="$nextsector" exact="$gatedestination.sector"/>
          <debug_text text="'moving through the gate from sector %s to sector %s. waiting for subordinates: %s, waiting for: %s %s %s'.[this.sector.knownname, $nextsector.knownname, $waitforsubordinates?, @$waitforatgate.idcode, @$waitforatgate.knownname, $waitforatgate]" chance="(this.isplayerowned and ($waitforsubordinates? or $waitforatgate)) * 0"/>
          <run_script name="'move.gate'">
            <param name="gate" value="$gate"/>
            <param name="recallsubordinates" value="false" comment="if move.gate calls move.generic, this passes the parameter to the new instance of move.generic"/>
            <param name="waitfor" value="$waitforatgate"/>
            <!--<param name="debugchance" value="($waitforsubordinates? or $waitforatgate) * 100"/>-->
            <param name="debugchance" value="$debugchance"/>
          </run_script>

          <!-- we should have gone through the gate and be in the correct sector now -->
          <do_if value="$gatedestination.sector != this.sector">
            <debug_text text="'failed going through gate!'" filter="error"/>
          </do_if>
          <remove_value name="$nextsector"/>
          <remove_value name="$gatedestination"/>
          <remove_value name="$gate"/>

          <!-- if we waited for someone after crossing the gate, we are no longer blocking the gate or will directly proceed. movement to clear gate exit done in move.gate in this case. -->
          <do_if value="not $waitforsubordinates? and not $waitforatgate.isoperational and not this.zone.isclass.highway">
            <!-- move forward to a safepos to make sure the gate exit area is clear -->
            <get_safe_pos result="$safepos" zone="this.zone" object="this.assignedcontrolled" direction="quadrant.front" radius="this.assignedcontrolled.size" angle="45deg"/>
            <move_to object="this.assignedcontrolled" destination="this.zone" uselocalhighways="false" finishonapproach="true" abortpath="true">
              <position value="$safepos"/>
            </move_to>
            <remove_value name="$safepos"/>
          </do_if>
          <remove_value name="$waitforsubordinates"/>
        </do_if>
        <do_else>
          <set_value name="$locblacklistgroup" exact="if ($intersector? and not $blacklistoverride?) then $blacklistgroup else null"/>

          <wait max="(not $bigship) * (5.1 - (this.ship.pilot.skill.piloting / 3))s"/>

          <include_interrupt_actions ref="CheckCanUseLocalHighways"/>
          <do_if value="$resetsignalled?">
            <remove_value name="$resetsignalled"/>
            <wait exact="1ms" sinceversion="6"/>
          </do_if>

          <do_if value="$debugchance gt 0">
            <do_if value="this.zone.isclass.highway">
              <!-- we are in a highway -->
              <debug_text text="'location info for object=%2 at %1\n highway: %3, position: %4\n enroute to: %5'.[player.age, this.ship, this.zone, this.ship.position, this.zone.destination]"/>
              <debug_text text="'move_to(363) destination=%1 position=%2 distance=%3'.[$positionspace, $position, @this.ship.distanceto.[$positionspace, $position]]"/>
            </do_if>
            <do_else>
              <create_position name="$debug_sector_pos" object="this.ship" space="this.ship.sector"/>
              <debug_text text="'location info for object=%2 at %1\n zone: %3, position: %4\n sector: %5, position: %6'.[player.age, this.ship, this.zone, this.ship.position, this.sector, $debug_sector_pos]"/>
              <debug_text text="'move_to(363) destination=%1 position=%2 distance=%3'.[$positionspace, $position, @this.ship.distanceto.[$positionspace, $position]]"/>
            </do_else>
          </do_if>
          <!-- clear endzone so it can be used for the following check after the move_tos below have run -->
          <remove_value name="$endzone"/>
          <debug_text text="'Long distance trip. Using highways: %s'.[$canuselocalhighways]" chance="$debugchance" />

          <do_if value="$position">
            <move_to endzone="$endzone" object="this.ship" destination="$positionspace" uselocalhighways="$canuselocalhighways" abortpath="$abortpath" forcesteering="(not $bigship) and $forcesteering" forceposition="false" travel="not $noboost" useblacklist="$locblacklistgroup">
              <position value="$position"/>
              <interrupt>
                <conditions>
                  <event_object_changed_zone object="this.ship" zone="$endzone"/>
                  <debug_text text="'%s %s %s changed zones. current zone: %s, endzone: %s. not iszonechangepending: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, this.zone, $endzone, not this.assignedcontrolled.iszonechangepending]" debugchance="$debugchance"/>
                  <check_value value="not this.ship.iszonechangepending"/>
                </conditions>
                <actions>
                  <debug_text text="'interrupting move_to of %1(%2) because we just arrived in endzone %3(%4) in sector %6, $targetzone = %5, previous sector %7'.[this.ship.knownname, this.ship, $endzone.knownname, $endzone, $targetzone, @event.param.sector.macro.id, @event.param2.sector.macro.id]" chance="$debugchance"/>
                </actions>
              </interrupt>
            </move_to>
          </do_if>
          <do_else>
            <!-- if no position is defined, we simply move to $destination and stop when we get to $destination's zone. in the cases now supported:
              $destination is a highway and $destination == zone,
              or $destination is an object and $destination.zone is a highway.
              NB: endzone is a return value! -->
            <move_to endzone="$endzone" object="this.ship" destination="$destination" uselocalhighways="$canuselocalhighways" abortpath="$abortpath" forcesteering="(not $bigship) and $forcesteering" forceposition="false" travel="not $noboost" useblacklist="$locblacklistgroup">
              <interrupt>
                <conditions>
                  <check_any>
                    <check_all>
                      <event_object_changed_zone object="this.ship" zone="$endzone"/>
                      <check_value value="$destination.isclass.highway"/>
                      <check_value value="not this.ship.iszonechangepending"/>
                      <debug_text text="'interrupting move_to of %1(%2) because we just arrived in endzone %3(%4) in sector %6, $targetzone = %5, previous sector %7'.[this.ship.knownname, this.ship, $endzone.knownname, $endzone, $targetzone, @event.param.sector.macro.id, @event.param2.sector.macro.id]" debugchance="$debugchance"/>
                    </check_all>
                    <check_all>
                      <event_object_changed_zone object="this.ship"/>
                      <check_value value="$destination.isclass.object"/>
                      <check_value value="not this.ship.zone.isclass.highway"/>
                      <debug_text text="'was moving long-distance to %s %s %s which was in a highway. no longer in a highway. ending movement and proceeding. attention level: %s'.[$destination.idcode, $destination.knownname, $destination, this.ship.attention]" debugchance="$debugchance"/>
                    </check_all>
                  </check_any>
                </conditions>
              </interrupt>
            </move_to>
          </do_else>
          <remove_value name="$locblacklistgroup"/>
        </do_else>

        <do_if value="$resetstrictblacklist?">
          <set_value name="$strictblacklist" exact="not $strictblacklist"/>
          <remove_value name="$resetstrictblacklist"/>
        </do_if>
        <remove_value name="$blacklistoverride"/>
        <remove_value name="$intersector"/>
        <resume label="check"/>
      </do_if>

      <debug_text text="'Arrived at %1 %2. Moving to final position.\n at %3, %4.\n should be at %5, %6\n distance to last movement position: %7\n distance to initial position: %8'.[$positionspace.class, $positionspace.knownname, this.sector.knownname, this.cluster.knownname, $targetsector.knownname, $targetsector.cluster.knownname, @this.ship.distanceto.[$positionspace, $position], @this.ship.distanceto.[$positionspace, $pos_initial]]" chance="$debugchance"/>

      <!-- check destination -->
      <do_if value="(not $destination.exists) or $destination.iswreck">
        <debug_text text="'ERROR: destination does not exist! destination is: %1 CHECK 4'.[$destination]" filter="error" comment="could be a valid case because if it's an object or a tempzone" chance="$debugchance"/>
        <resume label="cleanup"/>
      </do_if>

      <!-- NB: if $endzone is defined, $endzone is the zone at the end of the long-distance movement. should be valid regardless of issues such as overlapping zones or destinations at the edge of their zones AS LONG AS we are not moving to an object in a highway. -->
      <do_if value="@$endzone.exists and not @$targetzone.isclass.highway">
        <do_if value="$positionspace.isclass.sector">
          <do_if value="$endzone.hascontext.{$positionspace}">
            <debug_text text="'endzone is in positionspace. overriding targetzone with endzone.'" chance="$debugchance"/>
            <set_value name="$targetzone" exact="$endzone"/>
          </do_if>
          <do_else>
            <debug_text text="'endzone is defined and positionspace is a sector but endzone is not in positionspace.'" filter="error"/>
          </do_else>
        </do_if>
      </do_if>

      <do_if value="not $targetzone">
        <do_if value="$positionspace.isclass.sector">
          <get_zone_at_position name="$targetzone" value="$position" sector="$positionspace"/>
        </do_if>
        <do_else>
          <debug_text text="'target zone is not known and position space is not sector.\n positionspace: %1 %2\n destination class: %3\n destination: %4 %5\n distance to last movement position: %6\n distance to last target position: %7'.[$positionspace.class, $positionspace.knownname, $destination.class, $destination.knownname, $destination, this.ship.distanceto.{$destination}, this.ship.distanceto.[$positionspace, $position]]" chance="0"/>
        </do_else>
        <do_if value="$targetzone">
          <debug_text text="'target zone found. \n moving to: %1 %2(%3) \n at: zone %4(%5) \n distance to last movement position: %6'.[$targetzone.class, $targetzone.knownname, $targetzone, this.zone.knownname, this.zone, this.ship.distanceto.[$positionspace, $position]]" chance="$debugchance"/>
          <!--<create_position name="$position" space="$targetzone" value="$position" object="$positionspace"/>
          <set_value name="$positionspace" exact="$targetzone"/>-->
        </do_if>
        <do_else>
          <debug_text text="'there is still no zone at the destination. continuing with present coordinates. \n moving to: %1 %2 \n at: zone %3 \n distance to last movement position: %4'.[$positionspace.class, $positionspace.knownname, this.zone.knownname, this.ship.distanceto.[$positionspace, $position]]" chance="$debugchance"/>
        </do_else>
      </do_if>

      <!-- short distance -->
      <do_if value="$endintargetzone and $targetzone == this.zone">
        <debug_text text="'we are at the target zone and endintargetzone: %1'.[$endintargetzone]" chance="$debugchance"/>
        <!-- no need to move to a safepos now, we're happy just being here -->
        <resume label="finish"/>
      </do_if>

      <reset_avoid_collisions object="this.ship"/>

      <debug_text text="'pos: %1, positionspace: %2 %3 %4'.[$position, $positionspace.class, $positionspace.knownname, $positionspace]" chance="0"/>
      <!-- regular position in space -->
      <do_if value="$targetzone">
        <do_if value="$targetzone.isclass.highway">
          <!-- we should have no position in this case. we are moving to an object that is in a highway. this is as close as we can get. -->
          <debug_text text="'moving to an object in a highway. this is as close as we can get right now. finishing.'" chance="$debugchance"/>
          <resume label="finish"/>
        </do_if>

        <debug_text text="'getting safepos'" chance="0"/>
        <get_safe_pos result="$safepos" zone="$targetzone" value="$position" object="$positionspace" radius="this.ship.size" ignored="this.ship" />
        <do_if value="@$precise">
          <create_position name="$safepos" space="$targetzone" value="$position" object="$positionspace"/>
        </do_if>
        <do_if value="$safepos.x gt 50km or $safepos.y gt 50km or $safepos.z gt 50km or $safepos.x lt -50km or $safepos.y lt -50km or $safepos.z lt -50km">
          <debug_text text="player.age + ': warning: safepos may be beyond zone boundary.\n safepos: %1\n target zone: %2 (%3)\n attention: %4'.[$safepos, $targetzone.knownname, $targetzone, this.ship.attention]" chance="0"/>
        </do_if>
        <do_else>
          <debug_text text="player.age + ':\n safepos: %1\n target zone: %2 (%3)\n attention: %4\n distance to safepos: %s'.[$safepos, $targetzone.knownname, $targetzone, this.ship.attention, this.ship.distanceto.[$positionspace, $position]]" chance="$debugchance"/>
        </do_else>
        <!--<do_if value="$safepos.x gt $targetzone.width / 2 or $safepos.y gt $targetzone.height / 2 or $safepos.z gt $targetzone.length / 2 or $safepos.x lt -$targetzone.width / 2 or $safepos.y lt -$targetzone.height / 2 or $safepos.z lt -$targetzone.length / 2">
          <debug_text text="'warning: safepos may be beyond zone boundary.\n safepos: %1\n target zone dimensions: width: %2m, height: %3m, length: %4m'.[$safepos, $targetzone.width, $targetzone.height, $targetzone.length]" chance="100"/>
        </do_if>-->
        <create_position name="$position" space="$targetzone" value="$position" object="$positionspace"/>
        <set_value name="$positionspace" exact="$targetzone"/>
        <debug_text text="'safepos plotted:\n safepos: %1\n old position: %2'.[$safepos, $position]" chance="$debugchance"/>
      </do_if>
      <do_else>
        <debug_text text="'no safepos'" chance="0"/>
        <!-- if there is still no zone at $position, it is unobstructed, hence safe.
              NB: remember that safepos is still relative to sector in this case! -->
        <set_value name="$safepos" exact="$position"/>
        <!--<set_value name="$positionspace" exact="$targetsector"/>-->
      </do_else>
      <debug_text text="'safepos: %1, positionspace: %2 %3 %4'.[$safepos, $positionspace.class, $positionspace.knownname, $positionspace]" chance="0"/>

      <do_if value="not @$rotation and @$lookat">
        <!-- look at rotation (if rotation does not exists) -->
        <create_orientation name="$rotation" orientation="look_at" refposition="$lookat">
          <position value="$safepos" object="$positionspace"/>
        </create_orientation>
      </do_if>

      <!-- Final safe move with or without rotation -->
      <include_interrupt_actions ref="CheckCanUseLocalHighways"/>
      <do_if value="$resetsignalled?">
        <remove_value name="$resetsignalled"/>
        <wait exact="1ms" sinceversion="6"/>
      </do_if>
      <debug_text text="'Short distance trip to %1 in %2. D=%3, using highways: %4'.[$safepos, $positionspace.knownname, this.ship.distanceto.[$positionspace, $safepos], $canuselocalhighways]" chance="$debugchance" />
      <do_if value="not @$rotation">
        <!-- Only move if is not very close -->
        <do_if value="this.ship.distanceto.[$positionspace, $safepos] gt this.ship.size">
          <move_to object="this.ship" destination="$positionspace" uselocalhighways="$canuselocalhighways" abortpath="$abortpath" forcesteering="(not $bigship) and $forcesteering" forceposition="false" forcerotation="false" finishonapproach="false" >
            <position value="$safepos"/>
          </move_to>
        </do_if>
      </do_if>
      <do_else>
        <move_to object="this.ship" destination="$positionspace" uselocalhighways="$canuselocalhighways" abortpath="$abortpath" forcesteering="(not $bigship) and $forcesteering" forceposition="false" forcerotation="true" finishonapproach="false" >
          <position value="$safepos" />
          <rotation value="$rotation" />
        </move_to>
      </do_else>

      <!-- If it's not yet close enough to the position -->
      <do_if value="not $destination.isclass.ship and not $destination.container.isclass.ship
        and 
          (not $endintargetzone or this.zone != $targetzone) 
        and 
          (this.ship.bboxdistanceto.[$positionspace, $safepos, $destination] gt 10km)">
        <!--<debug_text text="'Not successfully reached the position in context %1 %2!. in highway? %s'.[$positionspace.class, $positionspace.knownname, this.ship.zone.isclass.highway]" filter="error"/>-->
        <debug_text text="player.age + ': %1\n %2'.['Not successfully reached the position in context %1 %2!\n %3 is currently in zone %4 %5,\n target zone: %6 %7\n distance to last movement point: %8m\n distance to destination: %9m'.[$positionspace.class, $positionspace.knownname, this.ship.knownname, this.ship.zone.knownname, this.ship.zone, $targetzone.knownname, $targetzone, this.ship.distanceto.[$positionspace, $safepos], this.ship.distanceto.{$destination}],'this position: %1\n input destination: %2 %3\n input destination class: %4\n attention: %5'.[this.ship.position, $destination.knownname, $destination, $destination.class, this.ship.attention]]" filter="error"/>
        <debug_text text="'Orders:\n ' + this.ship.order.id" filter="general"/>
        <do_all exact="this.ship.orders.count" counter="$i">
          <debug_text text="$i + ': ' + this.ship.orders.{$i}.id" filter="general"/>
        </do_all>
      </do_if>

      <label name="finish"/>

      <!-- Safety check if we are not in the destination's zone yet. Valid case with moving ships.
            NB: moved this here because a ship could have moved after the short distance movement as well. -->
      <do_if value="$destination.isclass.ship or $destination.container.isclass.ship">
        <do_if value="$pos_input">
          <set_value name="$locdist" exact="this.ship.bboxdistanceto.[$destination, $pos_input]"/>
        </do_if>
        <do_else>
          <set_value name="$locdist" exact="this.ship.bboxdistanceto.{$destination}"/>
        </do_else>
        <do_if value="this.zone != $destination.zone and $locdist gt 10km">
          <debug_text text="'Destination is a ship, and it changed zones, so targetzone is outdated. Resume to check again.\n %1 distance to %2: %3m,\n our zone: %4,\n target zone: %5,\n end in target zone? %6.'.[this.ship.knownname, $destination.knownname, this.ship.distanceto.{$destination}, this.zone, $destination.zone, $endintargetzone]" chance="$debugchance"/>
          <remove_value name="$locdist"/>
          <!-- we are moving to a moving object and it is no longer where it was. clear $endzone to re-evaluate long-distance movement. -->
          <remove_value name="$endzone"/>
          <resume label="check"/>
        </do_if>
        <do_else>
          <debug_text text="'Destination is a ship, and we caught up!\n %1 distance to %2: %3m,\n our zone: %4,\n target zone: %5,\n end in target zone? %6.'.[this.ship.knownname, $destination.knownname, this.ship.distanceto.{$destination}, this.zone, $destination.zone, $endintargetzone]" chance="$debugchance"/>
        </do_else>
        <remove_value name="$locdist"/>
      </do_if>

      <set_value name="$returnvalue" exact="true"/>

      <label name="cleanup"/>

      <set_to_default_flight_control_model object="this.ship" />
      <stop_boost object="this.ship" />

      <!-- Tell to subordinates that the movement finished -->
      <do_if value="$recallsubordinates and this.$recalling_subordinates?">
        <debug_text text="'%1 (%2) cancelling wait and dock orders of subordinates.'.[this.ship.knownname, this.ship]" chance="$debugchance"/>
        <do_if value="typeof this.$recalling_subordinates == datatype.list">
          <do_if value="not @$subordinateorders.count">
            <set_value name="$subordinateorders" exact="this.$recalling_subordinates.clone"/>
          </do_if>
          <debug_text text="'%s %s %s cancelling subordinate orders at sector %s %s.\n going to sector %s %s.'.[this.ship.idcode, this.ship.knownname, this.ship, @this.sector.knownname, @this.sector, @$targetsector.knownname, @$targetsector]" chance="$debugchance"/>
          <!-- Script dock for them -->
          <do_all exact="$subordinateorders.count" counter="$i" >
            <!-- If they are waiting, cancel their order so they undock/stop waiting -->
            <cancel_order order="$subordinateorders.{$i}" />
          </do_all>
        </do_if>
        <remove_value name="this.$recalling_subordinates"/>
      </do_if>

      <do_if value="$debugchance gt 0">
        <do_if value="$safepos?">
          <set_value name="$pos_final" exact="$safepos"/>
        </do_if>
        <do_else>
          <set_value name="$pos_final" exact="$position"/>
        </do_else>
        <assert value="$endintargetzone or not $destination.isoperational or $destination.isclass.ship or (this.ship.bboxdistanceto.[$positionspace, $pos_final, $destination] lt 10km)" text="'At the end of move.generic ship is in sector %1, zone %2, destination: %3, zone pos: %4, distance to destination: %5, distance to $pos_final %6 in space %7: %8'.[this.sector, this.zone, $destination, this.ship.position, @this.ship.distanceto.{$destination}, $pos_final, $positionspace, this.ship.distanceto.[$positionspace, $pos_final]]" break="always"/>
      </do_if>

      <return value="$returnvalue"/>

    </actions>
  </attention>
  <on_abort>
    <reset_avoid_collisions object="this.ship"/>
    <set_to_default_flight_control_model object="this.ship" />
    <stop_boost object="this.ship" />
    <stop_moving object="this.ship"/>
    <!-- Tell to subordinates that the movement finished -->
    <do_if value="$recallsubordinates and (@$subordinateorders.count or @this.$recalling_subordinates.count)">
      <do_if value="not @$subordinateorders.count">
        <set_value name="$subordinateorders" exact="this.$recalling_subordinates.clone"/>
      </do_if>
      <debug_text text="'on_abort: %s %s %s cancelling subordinate orders at sector %s %s.\n going to sector %s %s.'.[this.ship.idcode, this.ship.knownname, this.ship, @this.sector.knownname, @this.sector, @$targetsector.knownname, @$targetsector]" chance="$debugchance"/>
      <do_all exact="$subordinateorders.count" counter="$i" >
        <cancel_order order="$subordinateorders.{$i}" />
      </do_all>
    </do_if>
    <remove_value name="this.$recalling_subordinates"/>
  </on_abort>
</aiscript>
