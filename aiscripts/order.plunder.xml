<?xml version="1.0" encoding="utf-8"?>
<!--
$space
  - has to be a space. converted to a space if class.station.
  - used to determine space we operate in ($targetzone).
  - used to determine $sellspaces.
  - used to determine $spacezones if class.sector or class.cluster.
  - used to determine $base if $base is not set and $space is a station or buildstorage.
$base
  - used to determine basket.
  - sole customer, overrides sellspaces if set.
$sellspaces
  - spaces to sell to if $base is not set or is no longer valid.
  - derived from $space.
$range
  - no longer used, used to be the parameter that $space was derived from.
  - only useful for debugging.
$range_internal
  - used to determine space AND base if defined (overrides space, does not override base).
  - primarily used by jobs where it isn't possible to evaluate spaces at the moment the job entry is evaluated.
-->
<aiscript name="order.plunder" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <order id="Plunder" name="{1041, 231}" description="{1041, 232}" category="internal" infinite="true">
    <params>
      <param name="space" default="this.ship.cluster" type="object" text="{1041, 10117}" comment="Space. Space or Station.">
        <input_param name="class" value="[class.cluster, class.sector, class.zone, class.station]"/>
      </param>
      <param name="base" default="null" type="object" text="{1041, 10012}" advanced="true" comment="Base">
        <input_param name="class" value="[class.station]"/>
      </param>
      <param name="returntobase" default="true" type="bool" text="{1041, 10105}" advanced="true" comment="Return wares to base. After filling cargobay, return wares to base? Base can be any trade station of this faction within this cluster."/>
      <param name="basebasket" default="this.ship.warebasket.list" type="list" text="{1041, 10146}" advanced="true" comment="Wares. Base warebasket. Default to that setup in jobs">
        <input_param name="type" value="'ware'"/>
        <input_param name="cancarry" value="true"/>
      </param>
      <param name="deepspace" default="false" type="bool" text="{1041, 10082}" advanced="true" comment="Operate in deep space. Operate only in deep space. Currently defined as 100 +/- 50km from sector core edge"/>
      <param name="checkrelation" default="false" type="internal" text="{1041, 10081}" comment="Only engage hostiles. Check the maybeattackedby status of potential targets. Otherwise, find any which are not of your faction"/>
      <param name="plundermode" default="0" type="internal" text="{1041, 10083}" comment="Plunder, Hack, or Both? 0 = Only Plunder Ships, 1 = Consider Both, 2 = Only Hack Stations"/>
      <param name="range_internal" default="null" type="internal" comment="Range (String). Expects 'cluster', 'sector', 'zone', or 'station'. For use with cases where 'this' does not exist yet. This overrides the space parameter since it should only be used where space cannot be properly set."/>

      <!-- only for passing into move.hack.station.storage -->
      <param name="target" default="null" type="object" text="{1041, 10044}" advanced="true" comment="Hack target. The object to steal from">
        <input_param name="class" value="[class.station]"/>
      </param>
      <param name="module" default="null" type="internal" text="{1041, 10043}" comment="Hack module. Storage module to steal from"/>
      <param name="movetomodule" default="true" type="internal" text="{1041, 10075}" comment="Move to module. Attempt to move to the best position for collection. Bool incase caller already has moved to desired position"/>

      <param name="debugchance" type="bool" default="0" advanced="true" text="{1041, 10086}" comment="Print debug output">
        <input_param name="truevalue" value="100"/>
      </param>
    </params>
    <skill min="80"/>
    <requires>
      <match shiptype="shiptype.lasertower" negate="true"/>
    </requires>
  </order>
  <interrupts>
    <handler ref="SectorChangeHandler"/>
    <handler ref="TargetInvalidHandler"/>
    <handler ref="AttackHandler"/>
    <handler ref="MissileLockHandler" />
    <handler ref="ScannedHandler"/>
    <handler ref="InspectedHandler"/>
    <handler ref="FoundAbandonedHandler"/>
    <handler ref="FoundLockboxHandler"/>
    <handler ref="ResupplyHandler"/>
    <handler>
      <conditions>
        <!-- event.object = object that found the drops, event.param = list of drops found -->
        <event_object_drops_found object="this.ship"/>
        <check_value value="not $donotcollect?"/>
      </conditions>
      <actions>
        <debug_text text="'event_object_drops_found fired on %1. event.object: %2 event.param: %3 event.param2: %4 event.param3: %5 (last should be null)'.[this.ship.knownname, event.object, event.param, event.param2, event.param3]" chance="$debugchance"/>
        <set_value name="$crates" exact="event.param.clone"/>
        <abort_called_scripts resume="plunder"/>
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_signalled object="this.assignedcontrolled" param="'exploration_stayput'" check="false"/>
      </conditions>
      <actions>
        <set_value name="$stayput"/>
        <set_value name="$targetzone" exact="this.zone"/>
        <debug_text text="'signal exploration_stayput received. staying put and patrolling in %s %s, sector %s %s'.[$targetzone.class, $targetzone, $targetzone.sector.knownname, $targetzone.sector]" chance="$debugchance"/>
        <abort_called_scripts resume="patrol"/>
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_signalled object="this.assignedcontrolled" param="'exploration_stayput_release'" check="false"/>
      </conditions>
      <actions>
        <remove_value name="$stayput"/>
        <remove_value name="$donotcollect"/>
        <remove_value name="$targetzone"/>
        <abort_called_scripts resume="prep"/>
      </actions>
    </handler>
    <!--<handler>
      <conditions>
        <event_object_changed_attention object="this.ship"/>
        <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)"/>
        <check_value value="not this.ship.boost.active"/>
      </conditions>
      <actions>
        <debug_text text="'Gametime: ' + player.age + ' Moveto interrupted by: ' + event.name" chance="$debugchance"/>
        <abort_called_scripts resume="prep"/>
      </actions>
    </handler>-->
  </interrupts>
  <init>
    <do_if value="this.ship.order != this.ship.defaultorder">
      <debug_text text="'order received from PlunderNet. initializing.'" chance="$debugchance"/>
    </do_if>

    <do_if value="this.$time_attackstarted?" chance="$debugchance">
      <debug_text text="player.age + ': %s %s %s reinitializing from attack. attack took %s seconds.'.[this.ship.idcode, this.ship.knownname, this.ship, player.age - this.$time_attackstarted]" chance="$debugchance"/>
      <remove_value name="this.$time_attackstarted"/>
    </do_if>

    <!--TODO: command and/or commandaction Piracy?-->
    <set_command command="command.patrol"/>
    <set_command_action commandaction="commandaction.calculating"/>
    <do_if value="this.ship.order" comment="Safety check in case the script is called from non-order script">
      <set_order_syncpoint_reached order="this.ship.order"/>
    </do_if>

    <!-- to do: determine the intended difference between capships and non-capships doing this behavior.
                  at the moment, this only changes:
                    search_duration (which is not used if going with move.seekenemies rather than Patrol),
                    and setting formation (which should be handled in the escort script). -->
    <do_if value="this.ship.isclass.[class.ship_xl, class.ship_l]">
      <set_value name="$capship" exact="true"/>
    </do_if>
    <do_else>
      <set_value name="$capship" exact="false"/>
    </do_else>

    <!-- to do: determine why capships are not supported. see no reason why they wouldn't. old collect? -->
    <!--<do_if value="not (this.ship.isclass.ship_l or this.ship.isclass.ship_xl)">
      <assert value="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" exact="'move.plunder not currently supporting non-capships'"/>
      <return value="false"/>
    </do_if>
    <set_value name="$capship" exact="true"/>-->

    <!-- running this without a basebasket should now be handled. -->
    <!--<do_if value="not $basebasket.count">
      <debug_text text="'No $basebasket set'" filter="error"/>
    </do_if>-->
    <debug_text text="this.ship.knownname + ', ' + this.zone.knownname + ' Pirate basket is: ' + $basebasket" chance="$debugchance"/>

    <!-- to do: determine what this is for. $attacker isn't used anywhere here. wasn't used in the old script either. -->
    <do_if value="$checkrelation">
      <set_value name="$attacker" exact="this.ship"/>
    </do_if>
    <do_else>
      <set_value name="$attacker" exact="null"/>
    </do_else>

    <!--<set_value name="$referenceware" exact="ware.smartchips"/>-->
    <set_value name="$pricethreshold" exact="ware.smartchips.averageprice"/>

    <do_if value="$capship">
      <set_value name="$search_duration" exact="20min"/>
    </do_if>
    <do_else>
      <set_value name="$search_duration" exact="10min"/>
    </do_else>

    <do_if value="($space.exists and $space.isclass.[class.station, class.zone, class.buildstorage]) or ($range_internal == 'station') or ($range_internal == 'zone')">
      <do_if value="not $base.isoperational">
        <do_if value="$space.isclass.[class.station, class.buildstorage]">
          <set_value name="$base" exact="$space"/>
        </do_if>
        <do_elseif value="($range_internal == 'station') and this.ship.commander.isoperational and this.ship.commander.isclass.[class.station, class.buildstorage]">
          <set_value name="$base" exact="this.ship.commander"/>
        </do_elseif>
      </do_if>

      <do_if value="$range_internal">
        <do_if value="this.ship.jobmainzone">
          <set_value name="$space" exact="this.ship.jobmainzone"/>
        </do_if>
        <do_else>
          <set_value name="$space" exact="this.ship.zone"/>
        </do_else>
      </do_if>
      <do_elseif value="not $space.isclass.zone and @$space.zone.exists">
        <set_value name="$space" exact="$space.zone"/>
      </do_elseif>
      <set_value name="$range" exact="class.zone"/>

      <do_if value="$space.isclass.[class.station, class.buildstorage]">
        <set_value name="$sellspaces" exact="[$space.zone]"/>
      </do_if>
      <do_else>
        <set_value name="$sellspaces" exact="[$space]"/>
      </do_else>
    </do_if>
    <do_else>
      <do_if value="($space.exists and $space.isclass.sector) or ($range_internal == 'sector')">
        <do_if value="$range_internal">
          <do_if value="this.ship.jobmainzone">
            <set_value name="$space" exact="this.ship.jobmainzone.sector"/>
          </do_if>
          <do_else>
            <set_value name="$space" exact="this.ship.sector"/>
          </do_else>
        </do_if>
        <set_value name="$range" exact="class.sector"/>
      </do_if>
      <do_else>
        <!-- either: $space is invalid, $space is a cluster, or $range_internal is 'cluster' -->
        <!-- Default space -->
        <do_if value="this.ship.jobmainzone">
          <set_value name="$space" exact="this.ship.jobmainzone.cluster"/>
        </do_if>
        <do_else>
          <set_value name="$space" exact="this.ship.cluster"/>
        </do_else>
        <set_value name="$range" exact="class.cluster"/>
      </do_else>

      <find_zone name="$spacezones" space="$space" normalzone="true" multiple="true"/>
      <do_if value="not $spacezones.count">
        <find_zone name="$spacezones" space="$space" tempzone="false" multiple="true">
          <match class="class.highway" negate="true"/>
        </find_zone>
      </do_if>
      <do_if value="not $spacezones.count">
        <find_station name="$spacestations" space="$space" multiple="true"/>
        <do_all exact="$spacestations.count" counter="$i">
          <do_if value="not $spacezones.indexof.{$spacestations.{$i}.zone} and not $spacestations.{$i}.zone.isclass.highway">
            <append_to_list name="$spacezones" exact="$spacestations.{$i}.zone"/>
          </do_if>
        </do_all>
        <remove_value name="$spacestations"/>
      </do_if>
      <do_if value="not $spacezones.count">
        <append_to_list name="$spacezones" exact="this.ship.zone"/>
      </do_if>
      <set_value name="$table_spacezones" exact="table[]"/>
      <do_all exact="$spacezones.count" counter="$i">
        <set_value name="$table_spacezones.{$spacezones.{$i}}" exact="$spacezones.{$i}.distanceto.{this.ship}"/>
      </do_all>
      <set_value name="$sellspaces" exact="$table_spacezones.keys.sorted"/>
      <debug_text text="'found %s zones in %s %s'.[$spacezones.count, $space.class, $space.knownname]" chance="$debugchance"/>
      <remove_value name="$table_spacezones"/>
    </do_else>
    <debug_text text="'%1 (%2) plundering in %3, %4. Range: %5 Space: %6 Sellspaces: %7'.[this.ship.knownname, this.ship, this.ship.sector.knownname, this.ship.cluster.knownname, $range, $space, $sellspaces]" chance="$debugchance"/>
  </init>
  <patch sinceversion="1">
    <do_if value="not $space.exists or (@$targetzone and not $targetzone.exists)">
      <set_value name="$targetzone" exact="null"/>
      <resume label="prep"/>
    </do_if>
  </patch>
  <patch sinceversion="3">
    <set_value name="$pricethreshold" exact="ware.smartchips.averageprice"/>
  </patch>
  <attention min="unknown">
    <actions>

      <label name="start"/>

      <do_if value="this.$signaldone? and $base.exists">
        <signal_objects object="$base" param="this.$signaldone" param2="this.assignedcontrolled"/>
        <remove_value name="this.$signaldone"/>
      </do_if>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <debug_text text="'%1 doing job %2 has expired. die!'.[this.ship.knownname, this.ship.job]" chance="$debugchance"/>
        <resume label="finish"/>
      </do_if>

      <!--See which wares can currently fit inside -->
      <set_value name="$currentbasket" exact="[]"/>
      <do_all exact="$basebasket.count" counter="$i">
        <do_if value="this.ship.cargo.{$basebasket.{$i}}.free">
          <append_to_list name="$currentbasket" exact="$basebasket.{$i}"/>
        </do_if>
      </do_all>

      <do_if value="@$base.isoperational and this.ship.trueowner == $base.trueowner">
        <run_script name="'order.assign.commander'">
          <param name="cancelorders" value="false"/>
        </run_script>
      </do_if>

      <!--Calculate the free space in the ship-->
      <set_value name="$freecapacity" exact="(this.ship.cargo.free.all)f"/>
      <set_value name="$totalcapacity" exact="(this.ship.cargo.capacity.all)f"/>

      <!-- if we have a base, and have any of anything that our base needs, drop it off. -->
      <do_if value="$base.isoperational and $basebasket">
        <do_all exact="$basebasket.count" counter="$i">
          <do_if value="this.ship.cargo.{$basebasket.{$i}}.exists">
            <debug_text text="'%s %s %s has wares that %s %s %s needs. moving to offload.'.[this.ship.idcode, this.ship.knownname, this.ship, $base.idcode, $base.knownname, $base]" chance="$debugchance"/>
            <set_value name="$offload"/>
            <resume label="prep"/>
          </do_if>
        </do_all>
      </do_if>

      <!-- No capacity -->
      <do_if value="not $totalcapacity">
        <debug_text text="'No capacity for some reason. Destroyed storage modules?'" chance="$debugchance"/>
        <wait min="2min" max="3min"/>
      </do_if>
      <!-- More than 5% of free space, so keep going -->
      <do_elseif value="($freecapacity / $totalcapacity) * 100" min="5">
        <do_if value="($freecapacity / $totalcapacity) * 100 != 100" chance="$debugchance">
          <debug_text text="this.ship.knownname + ' has ' + ($freecapacity / $totalcapacity) * 100 + '% of cargo free. Continuing to search.'"/>
        </do_if>
      </do_elseif>
      <do_else>
        <set_value name="$offload"/>
        <resume label="prep"/>
      </do_else>

      <label name="plunder"/>

      <do_if value="this.ship.coverowner == faction.player">
        <debug_text text="'ERROR: %1 (%2) covered itself as faction.player'.[this.ship.knownname, this.ship]" filter="error"/>
      </do_if>

      <do_if value="this.assignedcontrolled.iscapitalship and not this.assignedcontrolled.units.{unitcategory.transport}.count">
        <!-- to do: at the moment, this does not work unless the pirate faction has a shipyard or equipment dock
                because order.dock:
                  checks for this.ship's relation to the dock (which is correctly unchanged and usually hostile),
                  and request_docking is apparently not fooled by a ship with covered faction ownership. -->
        <signal_objects object="this.assignedcontrolled" param="'resupply'" param2="[false]" param3="$debugchance" comment="param2 = [urgent?, resupplystationID], param3 = $debugchance"/>
        <!--<create_order id="'Resupply'" object="this.ship">
          <param name="debugchance" value="$debugchance"/>
        </create_order>-->
      </do_if>

      <!-- to do: Currently, this script will not find crates if any are found by this.ship's gravidar while it is collecting.
                  This should be fine since it fits the behavior of a pirate frantically collecting everything as fast as he/she can, then bugging out.
                  However, if it becomes a problem, activate below.
                    Do not activate if this uses move.seekenemies directly rather than order.fight.patrol
                      because, with move.seekenemies, the find will be done a lot more often than is absolutely necessary. -->
      <!--<do_if value="not $crates?">
        <find_object name="$crates" class="class.collectable" space="this.ship.sector" multiple="true">
          <match_distance object="this.ship" max="this.ship.maxradarrange"/>
          <!-<match_distance object="this.ship" max="[10km, this.ship.maxradarrange].min"/>->
          <match_any_wares wares="$currentbasket"/>
        </find_object>
      </do_if>-->

      <do_if value="$crates?">
        <debug_text text="'Crates to collect %1, basket: %2'.[$crates, $currentbasket]" chance="$debugchance"/>

        <set_value name="$drops" exact="[]"/>
        <do_all exact="$crates.count" counter="$i">
          <do_if value="$crates.{$i}.exists">
            <set_value name="$cratewares" exact="$crates.{$i}.wares.list"/>
            <debug_text text="'target dropped crate with: ' + $cratewares" chance="$debugchance"/>
            <do_all exact="$cratewares.count" counter="$o">
              <do_if value="this.ship.cargo.{$cratewares.{$o}}.free">
                <do_if value="not $pickitup? and $currentbasket.count">
                  <do_if value="$currentbasket.indexof.{$cratewares.{$o}}">
                    <debug_text text="$cratewares.{$o} + ' added to final crates'" chance="$debugchance"/>
                    <append_to_list name="$drops" exact="$crates.{$i}"/>
                    <break/>
                  </do_if>
                </do_if>
                <do_else>
                  <debug_text text="$cratewares.{$o} + ' added to final crates'" chance="$debugchance"/>
                  <append_to_list name="$drops" exact="$crates.{$i}"/>
                  <break/>
                </do_else>
              </do_if>
            </do_all>
          </do_if>
        </do_all>
        <remove_value name="$crates"/>
        <remove_value name="$pickitup"/>

        <!-- Either if it was destroyed or disengaged, there might be some drops, if not end -->
        <do_if value="$drops.count">
          <!-- Collect -->
          <!-- shuffle list so that drops with the same value are still in a random order and not in the consistent order that they were found in -->
          <shuffle_list list="$drops"/>
          <sort_collectables_by_value name="$sortedlist" collectables="$drops" object="this.ship"/>
          <do_if value="$sortedlist.count">
            <debug_text text="'Checking for crates. Basket %1, drops %2'.[$currentbasket, $sortedlist]" chance="$debugchance"/>

            <!-- always uncover before collecting? -->
            <do_if value="this.ship.coverowner">
              <!-- this will cause all commanders and subordinates of this.ship to lose cover via Cover.xml -->
              <signal_objects object="this.defensible" param="'LoseCover'" param2="false"/>
            </do_if>

            <debug_text text="'Collecting. Relations should be penalized at this point, if at all. true owner: %1 cover owner: %2 this.ship.coverowner: %3'.[this.ship.trueowner, this.ship.owner, this.ship.coverowner]" chance="$debugchance"/>

            <create_order id="'Flee'" object="this.ship" immediate="true">
              <param name="method" value="'boost'"/>
              <!--<param name="return" value="false"/>-->
              <param name="maxboostdistance" value="this.zone.size + this.ship.size"/>
              <param name="maxboostduration" value="10min"/>
              <param name="debugchance" value="$debugchance"/>
            </create_order>
            <create_order id="'Collect'" object="this.ship" immediate="true">
              <param name="targetlist" value="$sortedlist"/>
              <param name="debugchance" value="$debugchance"/>
            </create_order>

            <!-- added wait to allow above orders to interrupt the present order. -->
            <wait min="19ms" max="101ms"/>
          </do_if>
          <do_else>
            <debug_text text="'No crates are suitable to be collected by this ship. Basket %1, drops %2'.[$currentbasket, $drops]" chance="$debugchance"/>
          </do_else>
        </do_if>
        <do_else>
          <debug_text text="'no drops!!'" chance="$debugchance"/>
        </do_else>
      </do_if>

      <label name="prep"/>

      <!--<debug_text text="'Hey! Im over here! %1, %2, %3'.[this.ship.zone.knownname, this.ship.sector.knownname, this.ship.cluster.knownname]" chance="$debugchance"/>-->

      <!-- to do: Going with move.seekenemies for now because set_cover_owner is handled in this script.
                If using order.fight.patrol, they will uncover when attacking and stay uncovered.
                However, using order.fight.patrol for this is more efficient, flexible, and easier to maintain since there is some duplication needed to use move.seekenemies.
                  So if the way set_cover_owner is changed such that it doesn't need any further attention after cover is first set (Adrian has an idea), change to use order.fight.patrol. -->
      <do_if value="$space != this.ship.zone">
        <do_if value="$spacezones?">
          <shuffle_list list="$spacezones"/>
          <do_all exact="$spacezones.count" counter="$i">
            <do_if value="$spacezones.{$i}.exists and this.ship.zone != $spacezones.{$i}">
              <do_if value="$spacezones.{$i}.owner != this.trueowner">
                <set_value name="$targetzone" exact="$spacezones.{$i}"/>
                <break/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <do_elseif value="$space.exists">
          <!-- in this case, $space is always a zone. it used to support being something in a zone. -->
          <do_if value="$space.isclass.highway">
            <debug_text text="'space: %s %s was a highway. resetting to related sector. script will restart.'.[$space.knownname, $space]" chance="$debugchance"/>
            <do_if value="$space.sector">
              <edit_order_param order="this.assignedcontrolled.order" param="'space'" value="$space.sector"/>
            </do_if>
            <do_elseif value="$space.issuperhighway">
              <edit_order_param order="this.assignedcontrolled.order" param="'space'" value="$space.destination.sector"/>
            </do_elseif>
            <do_else>
              <debug_text text="'unhandled case. space %s %s is a highway that is not in a sector and is not a superhighway'.[$space.knownname, $space]" filter="error"/>
            </do_else>
          </do_if>

          <do_if value="$space.isclass.zone">
            <set_value name="$targetzone" exact="$space"/>
          </do_if>
          <do_else>
            <set_value name="$targetzone" exact="$space.zone"/>
          </do_else>

          <do_if value="@$targetzone.isclass.highway">
            <debug_text text="'WARNING: %s (%s) was sent to plunder in a highway. space: %s (%s)'.[this.assignedcontrolled.knownname, this.assignedcontrolled, @$space.knownname, @$space]" filter="error"/>
          </do_if>
        </do_elseif>
      </do_if>
      <do_else>
        <set_value name="$targetzone" exact="this.ship.zone"/>
      </do_else>

      <do_if value="not @$targetzone.exists">
        <debug_text text="'Target zone not found. Proceeding to back up. This should not be necessary! Investigate $spacezones: %1. space: %s %s %s'.[@$spacezones, $space.class, $space.knownname, $space]" chance="$debugchance"/>
        <do_if value="$space.exists">
          <find_zone name="$potentialtargetzones" space="$space" normalzone="true" multiple="true">
            <match owner="this.trueowner" negate="true"/>
          </find_zone>
          <remove_from_list name="$potentialtargetzones" exact="this.zone"/>
          <set_value name="$targetzone" exact="null"/>
          <do_if value="$potentialtargetzones.count">
            <set_value name="$targetzone" exact="$potentialtargetzones.random"/>
          </do_if>
          <remove_value name="$potentialtargetzones"/>

          <do_if value="not $targetzone.exists">
            <find_station name="$spacestations" space="$space" multiple="true">
              <match owner="this.trueowner" negate="true"/>
              <match_relation_of faction="this.trueowner" relation="neutral" comparison="le"/>
            </find_station>
            <do_all exact="$spacestations.count" counter="$i">
              <do_if value="$spacestations.{$i}.zone != this.ship.zone and $spacestations.{$i}.zone.owner != this.trueowner and this.ship.relationto.{$spacestations.{$i}.zone.owner} le 0 and not $spacestations.{$i}.zone.isclass.highway">
                <set_value name="$targetzone" exact="$spacestations.{$i}.zone"/>
                <break/>
              </do_if>
            </do_all>
            <remove_value name="$spacestations"/>
          </do_if>
        </do_if>

        <do_if value="not @$targetzone.exists">
          <debug_text text="'%s %s has neither map zones nor stations. laying a trap in this zone.'.[$space.class, $space.knownname]" chance="$debugchance"/>
          <set_value name="$targetzone" exact="this.ship.zone"/>
        </do_if>
      </do_if>

      <debug_text text="'%1 (%2) is at %3, going to %4, %5, %6. Range: %7'.[this.ship.knownname, this.ship, this.ship.zone.knownname, $targetzone.knownname, $targetzone.sector.knownname, $targetzone.cluster.knownname, $range]" chance="$debugchance"/>

      <do_if value="$debugchance">
        <debug_text text="'prep. heading to cover. default order: %1. order list:'.[this.ship.defaultorder.id]"/>
        <do_all exact="this.ship.orders.count" counter="$i">
          <debug_text text="this.ship.orders.{$i}.id"/>
        </do_all>
      </do_if>

      <!-- NB: If need be, pirates should be covered when they sell their booty, or when they go on patrol.
              They are uncovered only if they attack.
              If they try to collect dropped wares while they are uncovered, they do not cover to do so. -->
      <do_if value="$targetzone.policefaction">
        <do_if value="this.assignedcontrolled.owner.relationto.{$targetzone.policefaction} lt 0">
          <do_if value="not this.assignedcontrolled.boardingoperations.count and ((this.attention lt attention.visible) or this.assignedcontrolled.dock or this.isplayerowned)">
            <!--<do_if value="this.ship.owner == this.ship.trueowner">-->
            <set_value name="$dapulis" exact="$targetzone.policefaction"/>
            <find_ship name="$ship_someother" class="this.assignedcontrolled.class" space="this.sector" hasjob="true">
              <match owner="this.trueowner" negate="true"/>
              <match owner="faction.player" negate="true"/>
              <match owner="faction.ownerless" negate="true"/>
              <match owner="$dapulis" negate="true"/>
              <match_relation_of faction="$dapulis" relation="neutral" comparison="ge"/>
            </find_ship>
            <do_if value="@$ship_someother">
              <set_value name="$faction_someother" exact="$ship_someother.owner"/>
              <debug_text text="'%1 found %2 for cover.'.[this.assignedcontrolled.knownname, $ship_someother.knownname]" chance="$debugchance"/>
              <remove_value name="$ship_someother"/>
            </do_if>
            <do_elseif value="$targetzone.policefaction != faction.player">
              <set_value name="$faction_someother" exact="$targetzone.policefaction"/>
            </do_elseif>
            <do_else>
              <!-- no cover -->
              <set_value name="$faction_someother" exact="null"/>
            </do_else>

            <do_if value="$faction_someother">
              <signal_objects object="player.galaxy" param="'Cover'" param2="[this.assignedcontrolled, $faction_someother, true, true]"/>
              <debug_text text="'%1 set cover to %2'.[this.assignedcontrolled.knownname, $faction_someother]" chance="$debugchance"/>
            </do_if>
          </do_if>
          <do_else>
            <debug_text text="'cannot cover. fleeing.'" chance="$debugchance"/>
            <create_order id="'Flee'" object="this.assignedcontrolled" immediate="true">
              <param name="method" value="3" comment="boost"/>
              <param name="donotdrop" value="true"/>
              <param name="deploydistraction" value="false"/>
              <param name="holdfire" value="false"/>
              <param name="attacker" value="@player.ship"/>
              <param name="debugchance" value="$debugchance"/>
            </create_order>
          </do_else>
        </do_if>
      </do_if>

      <do_if value="$offload?">
        <resume label="offload"/>
      </do_if>

      <set_value name="$donotcollect"/>
      <do_if value="not @$deepspace">
        <do_if value="this.ship.zone != $targetzone">
          <run_script name="'move.generic'">
            <param name="destination" value="$targetzone"/>
            <param name="endintargetzone" value="true"/>
            <param name="debugchance" value="$debugchance" />
          </run_script>
        </do_if>
      </do_if>
      <do_else>
        <!-- deepspace:
        problem:
          there are often (not always!) no zones in the areas we want to operate.
        so:
          get deepspace position from lib.find.point.indeepspace.
          here, move to the resulting sector position. (it will already be a safepos, but only right at this moment)
          after move.generic, set targetzone to be this.zone. -->
        <run_script name="'lib.find.point.indeepspace'" result="$targetsectorpos">
          <param name="sector" value="$targetzone.sector"/>
        </run_script>
        <debug_text text="'deep space pos: %s relative to: sector %s %s'.[$targetsectorpos, $targetzone.sector.knownname, $targetzone.sector]" chance="$debugchance"/>
        <run_script name="'move.generic'">
          <param name="destination" value="$targetzone.sector"/>
          <param name="position" value="$targetsectorpos"/>
          <param name="debugchance" value="$debugchance" />
        </run_script>
        <set_value name="$targetzone" exact="this.zone"/>
        <debug_text text="'deep space plunder ship %s %s now at target zone %s %s in sector %s %s, %sm away from sector center.'.[this.controlled.knownname, this.controlled, $targetzone.knownname, $targetzone, $targetzone.sector.knownname, $targetzone.sector, this.assignedcontrolled.distanceto.{$targetzone.sector}]" chance="$debugchance"/>
      </do_else>

      <remove_value name="$donotcollect"/>

      <resume label="patrol" chance="100 - ($plundermode * 50)"/>

      <label name="hack"/>

      <debug_text text="player.age + ' %1 (%2) decided to hack a station. plundermode: %3'.[this.ship.knownname, this.ship, $plundermode]" chance="$debugchance"/>

      <do_if value="not $target">
        <find_station name="$stations" space="this.zone" multiple="true">
          <match owner="this.trueowner" negate="true"/>
          <match_relation_of faction="this.trueowner" relation="neutral" comparison="le"/>
        </find_station>
        <shuffle_list list="$stations"/>

        <set_value name="$suitablestations" exact="[]"/>
        <do_all exact="$stations.count" counter="$i">
          <debug_text text="'%1 has cargo.list: %2'.[$stations.{$i}.knownname, $stations.{$i}.cargo.list]" chance="$debugchance"/>
          <do_if value="$stations.{$i} == $base" chance="90">
            <debug_text text="'%s %s %s is our client and we feel like being nice today.'.[@$stations.{$i}.idcode, @$stations.{$i}.knownname, $stations.{$i}]" chance="$debugchance"/>
            <continue/>
          </do_if>

          <do_if value="not $suitablestations.indexof.{$stations.{$i}}">
            <set_value name="$stationcargo" exact="$stations.{$i}.cargo.list"/>
            <do_all exact="$stationcargo.count" counter="$j">
              <do_if value="this.ship.cargo.{$stationcargo.{$j}}.free">
                <do_if value="$currentbasket.count">
                  <do_if value="$currentbasket.indexof.{$stationcargo.{$j}}">
                    <append_to_list name="$suitablestations" exact="$stations.{$i}"/>
                    <break/>
                  </do_if>
                </do_if>
                <do_else>
                  <append_to_list name="$suitablestations" exact="$stations.{$i}"/>
                  <break/>
                </do_else>
              </do_if>
            </do_all>
          </do_if>
        </do_all>

        <do_if value="$suitablestations.count">
          <!--Found some suitable stations to hack and steal from-->
          <set_value name="$target" exact="$suitablestations.random"/>
        </do_if>
        <do_else>
          <debug_text text="'%1 (%2) did not find a suitable station to hack.'.[this.ship.knownname, this.ship]" chance="$debugchance"/>
          <wait min="1s" max="10s"/>
        </do_else>
      </do_if>

      <do_if value="$target">
        <set_value name="$subordinateorders" exact="[]"/>
        <do_for_each name="$sub" in="this.assignedcontrolled.subordinates">
          <!-- wait here. if i'm not back in five minutes, you know what to do. -->
          <create_order name="$suborder" id="'Wait'" object="$sub">
            <param name="timeout" value="5min"/>
          </create_order>
          <append_to_list name="$subordinateorders" exact="$suborder"/>
        </do_for_each>
        <break_formation object="this.assignedcontrolled"/>
        <run_script name="'move.hack.station.storage'">
          <param name="target" value="$target"/>
          <param name="basket" value="$currentbasket"/>
          <param name="module" value="$module"/>
          <param name="movetomodule" value="$movetomodule"/>
          <param name="subordinateorders" value="$subordinateorders"/>
          <param name="debugchance" value="$debugchance"/>
        </run_script>
        <remove_value name="$subordinateorders"/>
      </do_if>
      <set_value name="$target" exact="null"/>

      <!-- we could now be in a different sector if we fled there. -->
      <do_if value="this.sector != $targetzone.sector">
        <resume label="prep"/>
      </do_if>
      <do_else>
        <resume label="prep" chance="$plundermode * 50"/>
      </do_else>

      <label name="patrol"/>

      <do_if value="not $targetzone.exists">
        <debug_text text="'%s %s %s was about to patrol but targetzone: %s %s %s does not exist. clearing targetzone and looping back.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, @$targetzone.class, @$targetzone.knownname, @$targetzone]" chance="$debugchance"/>
        <set_value name="$targetzone" exact="null"/>
        <resume label="prep"/>
      </do_if>

      <debug_text text="player.age + ' %1 (%2) decided to rob a ship. plundermode: %3'.[this.ship.knownname, this.ship, $plundermode]" chance="$debugchance"/>

      <create_position name="$base_pos" space="$targetzone" max="$targetzone.size / 2"/>
      <set_value name="$y" min="-5km" max="5km"/>
      <get_safe_pos result="$pos" radius="this.ship.size + 200m" ignored="this.ship" value="position.[$base_pos.x, $y, $base_pos.z]" zone="$targetzone" allowyaxis="false"/>

      <run_script name="'move.seekenemies'">
        <param name="destination" value="$targetzone"/>
        <param name="pos" value="$pos"/>
        <param name="pursuetargets" value="false" />
        <param name="pursuedistance" value="this.ship.maxradarrange" />
        <param name="allowothertargets" value="false" />
        <param name="targetpurposes" value="[purpose.trade, purpose.mine]" />
        <param name="plunder" value="true"/>
        <param name="plunderbasket" value="@$currentbasket"/>
        <param name="internalorder" value="true"/>
        <param name="debugchance" value="$debugchance" />
        <save_retval name="target" variable="$target"/>
        <!--<save_retval name="list_targets" variable="$list_potentialtargets"/>-->
      </run_script>
      <remove_value name="$base_pos"/>
      <remove_value name="$pos"/>
      <remove_value name="$y"/>

      <do_if value="@$target.isoperational">
        <!-- send 'piratehalt' signal. -->
        <signal_objects object="$target" param="'halt'" param2="this.defensible" param3="'piratehalt'"/>

        <!-- worththreshold changed to pricethreshold and moved to init. problem with using total worth of something filling our cargo hold as a reference value is that it results in a number that is extremely variable, and uses a value that is not readily available to the player (free storage, calculating free storage vs price and volume of reference ware). -->
        <!--<set_value name="$worththreshold" exact="$referenceware.averageprice * this.controlled.cargo.{$referenceware}.free"/>-->

        <set_value name="$table_preferredwares" exact="table[]"/>
        <set_value name="$list_targetwares" exact="$target.cargo.list"/>
        <do_all exact="$list_targetwares.count" counter="$i">
          <!-- removed the basket from this evaluation. would suck to have to guess what they're interested in. -->
          <!--<do_if value="$currentbasket.count">
            <do_if value="$currentbasket.indexof.{$list_targetwares.{$i}}">
              <set_value name="$table_preferredwares.{$list_targetwares.{$i}}" exact="$target.cargo.{$list_targetwares.{$i}}.count"/>
            </do_if>
          </do_if>-->
          <!-- MAINTENANCE: keep roughly synced with drop selection in lib.respond.inspected. -->
          <!-- criteria:
                not minable - we could get that stuff for free!
                something reasonably valuable - not energy cells, for example
                and something we can carry. -->
          <do_if value="not $list_targetwares.{$i}.tags.indexof.{tag.minable} and $list_targetwares.{$i}.averageprice ge $pricethreshold and this.controlled.cargo.{$list_targetwares.{$i}}.free">
          <!--<do_if value="not $list_targetwares.{$i}.tags.indexof.{tag.minable} and (($list_targetwares.{$i}.averageprice * [$target.cargo.{$list_targetwares.{$i}}.count, this.controlled.cargo.{$list_targetwares.{$i}}.free].min) ge $worththreshold)">-->
            <set_value name="$table_preferredwares.{$list_targetwares.{$i}}" exact="$target.cargo.{$list_targetwares.{$i}}.count"/>
          </do_if>
        </do_all>
      </do_if>

      <label name="accost"/>

      <do_if value="@$target.isoperational">

        <!-- inhibit the automatic collection handler for now. -->
        <set_value name="$donotcollect"/>

        <do_if value="$target == player.occupiedship">
          <run_script name="'player.interaction'">
            <param name="Line" value="11301" comment="(ship scan warning)Bet you've got some nice loot."/>
            <param name="MaxQueueDelay" value="10s"/>
            <param name="caption" value="'%s (%s)'.[this.assignedcontrolled.knownname, this.assignedcontrolled.idcode]"/>
            <param name="interactive" value="false"/>
            <param name="debugchance" value="$debugchance"/>
          </run_script>

          <wait min="2s" max="5s"/>

          <do_if value="not $list_targetwares.count or not $table_preferredwares.keys.count">
            <run_script name="'player.interaction'">
              <param name="Line" value="11302" comment="(ship scan result - nothing found)Pfft. Empty! What use is that?"/>
              <param name="MaxQueueDelay" value="10s"/>
              <param name="caption" value="'%s (%s)'.[this.assignedcontrolled.knownname, this.assignedcontrolled.idcode]"/>
              <param name="interactive" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </run_script>
            <resume label="plunder"/>
          </do_if>
          <do_else>
            <set_value name="$interested"/>
            <do_if value="not @$convoline">
              <set_value name="$convoline" exact="11310" comment="(pirate requesting to drop cargo)"/>
            </do_if>
            <!-- INTERACTION: pirate ordered player to drop cargo -->
            <run_script name="'player.interaction'" result="$response">
              <param name="Line" value="$convoline"/>
              <param name="UIText" value="{1002, 12011}" comment="Drop your cargo!"/>
              <param name="ConversationParam" value="'g_playership_plundered'"/>
              <param name="MaxQueueDelay" value="10s"/>
              <param name="caption" value="{1002, 12011} + ' - %s (%s)'.[this.assignedcontrolled.knownname, this.assignedcontrolled.idcode]" comment="Drop your cargo!"/>
              <param name="debugchance" value="$debugchance"/>
            </run_script>
            <remove_value name="$convoline"/>

            <do_if value="@$response == 'comply'">
              <!-- MenuMap triggered via player.interaction from Conversations.xml -->
              <wait>
                <interrupt>
                  <conditions>
                    <event_conversation_finished actor="this"/>
                  </conditions>
                  <actions>
                    <debug_text text="player.age + ': player done interacting with map menu. actor: %s %s, outcome: %s, param2: %s'.[event.object.knownname, event.object, @event.param, @event.param2]" chance="$debugchance"/>
                  </actions>
                </interrupt>
              </wait>
            </do_if>
          </do_else>
        </do_if>
        <!-- following should only be true if targetobject is player-owned and was told to wait for the player. -->
        <do_elseif value="not $waited? and $target.isplayerowned">
          <wait min="1min" max="2min">
            <interrupt>
              <conditions>
                <!-- signal sent from lib.respond.inspected. responses: 'comply', 'wait', 'attack', or 'flee'. for any responses other than 'wait', we'll pretend we didn't hear anything.
                      if event.param2 == 'wait', expects event.param3 to be a duration. -->
                <event_object_signalled object="this.ship" param="'player halt response'"/>
              </conditions>
              <actions>
                <set_value name="$response" exact="event.param2"/>
                <do_if value="event.param3">
                  <set_value name="$waitduration" exact="event.param3"/>
                </do_if>
                <do_else>
                  <set_value name="$waitduration" exact="1min"/>
                </do_else>
              </actions>
            </interrupt>
          </wait>

          <set_value name="$waited"/>

          <do_if value="@$response == 'wait'">
            <wait exact="$waitduration">
              <interrupt>
                <conditions>
                  <event_control_entity_added object="$target"/>
                  <check_value value="event.param == player.entity"/>
                </conditions>
              </interrupt>
            </wait>
            <remove_value name="$response"/>
            <remove_value name="$waitduration"/>
            <resume label="accost"/>
          </do_if>
          <do_else>
            <remove_value name="$response"/>
            <remove_value name="$waitduration"/>
          </do_else>
        </do_elseif>
        <remove_value name="$waited"/>

        <!-- extremely short wait, just to allow AI to respond. -->
        <wait exact="1ms"/>

        <!-- check to see if the player dropped something you wanted. -->
        <find_object name="$crates" class="class.collectable" space="this.ship.sector" multiple="true">
          <match_distance object="$target" max="($target.size / 2.0) + 1km"/>
        </find_object>
        <debug_text text="'target dropped %s crate(s).'.[$crates.count]" chance="$debugchance"/>
        <set_value name="$satisfied" exact="0"/>
        <do_all exact="$crates.count" counter="$i">
          <do_if value="$crates.{$i}.exists">
            <set_value name="$cratewares" exact="$crates.{$i}.wares.list"/>
            <do_all exact="$cratewares.count" counter="$j">
              <do_if value="@$table_preferredwares.{$cratewares.{$j}}">
                <set_value name="$satisfied" exact="1"/>
                <set_value name="$dropped_totalpercent" exact="@$dropped_totalpercent + (($crates.{$i}.wares.{$cratewares.{$j}}.count / ($table_preferredwares.{$cratewares.{$j}})f) * 100)"/>
                <set_value name="$dropped_totalvolume" exact="@$dropped_totalvolume + ( $crates.{$i}.wares.{$cratewares.{$j}}.count * $cratewares.{$j}.volume )"/>
                <!--<set_value name="$table_droppedwares.{$cratewares.{$j}}" exact="$crates.{$i}.wares.{$cratewares.{$j}}.count"/>-->
                <!--<set_value name="$totalworth" exact="@$totalworth + [$crates.{$i}.wares.{$cratewares.{$j}}.count, this.controlled.cargo.{$cratewares.{$j}}.free].min * $cratewares.{$j}.averageprice"/>-->
                <!--<do_if value="$crates.{$i}.wares.{$cratewares.{$j}}.count ge [( $table_preferredwares.{$cratewares.{$j}} * (this.assignedcontrolled.combinedskill / 200.0) ), this.controlled.cargo.{$cratewares.{$j}}.free].min">
                  <set_value name="$satisfied" exact="2"/>
                  <break/>
                </do_if>-->
                <!-- this.combinedskill takes morale into account. in this case, this represents a combination of nerve and a way to accurately gauge how much $target has.
                      NB: the multiplier of combinedskill below (0.5) is the maximum percentage threshold. -->
                <do_if value="$dropped_totalpercent ge (0.5 * this.assignedcontrolled.combinedskill) or $dropped_totalvolume ge this.controlled.cargo.free.all">
                  <debug_text text="'%s %s accosting %s %s.\nthey dropped %s %s which is fine.\npercent dropped: %s, threshold: %s\nvolume dropped: %s, free cargo volume: %s'.[this.controlled.knownname, this.controlled, $target.knownname, $target, $crates.{$i}.wares.{$cratewares.{$j}}.count, $cratewares.{$j}.name, $dropped_totalpercent, 0.5 * this.assignedcontrolled.combinedskill, $dropped_totalvolume, this.controlled.cargo.free.all]" chance="$debugchance"/>
                  <set_value name="$satisfied" exact="2"/>
                  <set_value name="$break"/>
                  <break/>
                </do_if>
              </do_if>
            </do_all>
            <do_if value="$break?">
              <remove_value name="$break"/>
              <break/>
            </do_if>
            <remove_value name="$cratewares"/>
          </do_if>
        </do_all>

        <do_if value="$interested? and $target == player.occupiedship and @$response == 'comply'">
          <do_if value="$satisfied ge 2">
            <!-- we're happy. go pick up the stuff and leave the target be. -->
            <run_script name="'player.interaction'">
              <param name="Line" value="9006" comment="(player releases cargo)"/>
              <param name="MaxQueueDelay" value="10s"/>
              <param name="caption" value="'%s (%s)'.[this.assignedcontrolled.knownname, this.assignedcontrolled.idcode]"/>
              <param name="interactive" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </run_script>
            <set_value name="$pickitup"/>
            <remove_value name="$dropped_totalvolume"/>
            <remove_value name="$dropped_totalpercent"/>
            <remove_value name="$interested"/>
            <remove_value name="$table_preferredwares"/>
            <remove_value name="$list_targetwares"/>
            <remove_value name="$donotcollect"/>
            <remove_value name="$satisfied"/>
            <remove_value name="$looped"/>
            <resume label="plunder"/>
          </do_if>
          <!-- TODO @Nick: This can be simplified - we do not want this behaviour anymore: could be that we don't need the voice lines either -->
          <do_elseif value="not $looped?">
            <set_value name="$looped"/>
            <!-- target's holding out. didn't drop what we wanted, or not enough. -->
            <set_value name="$convoline" exact="6013" comment="(order to release cargo)Drop the cargo!"/>
            <resume label="accost"/>
          </do_elseif>
        </do_if>
        <remove_value name="$interested"/>
        <remove_value name="$table_preferredwares"/>
        <remove_value name="$list_targetwares"/>
        <remove_value name="$looped"/>

        <!-- if target either:
              does not drop wares,
              or refuses demand for more

              attack. -->
        <do_if value="@$satisfied lt 2">
          <debug_text text="'%s %s accosting %s %s.\nwe are not pleased with the response. attacking.\npercent dropped: %s, threshold: %s\nvolume dropped: %s, free cargo volume: %s'.[this.controlled.knownname, this.controlled, $target.knownname, $target, @$dropped_totalpercent, 0.5 * this.assignedcontrolled.combinedskill, @$dropped_totalvolume, this.controlled.cargo.free.all]" chance="$debugchance"/>
          <signal_objects object="this.assignedcontrolled" param="'LoseCover'" param2="false"/>
          <do_if value="not this.mayattack.{$target}">
            <do_if value="$target.isplayerowned">
              <add_relation_boost object="this" otherobject="$target" value="this.owner.relation.kill.max" decay="1" delay="10min" silent="true"/>
            </do_if>
            <do_else>
              <add_relation_boost object="$target" otherobject="this" value="this.owner.relation.kill.max" decay="1" delay="10min" silent="true"/>
            </do_else>
          </do_if>
          <create_order id="'Attack'" object="this.ship" immediate="true">
            <param name="primarytarget" value="$target"/>
            <param name="pursuedistance" value="this.ship.maxradarrange"/>
            <param name="pursuetargets" value="false"/>
            <param name="allowothertargets" value="false"/>
            <param name="internalorder" value="true"/>
            <param name="debugchance" value="$debugchance"/>
          </create_order>

          <!-- short wait to prevent further actions before new order is started. otherwise, pirates may do things like flee before attacking. -->
          <wait exact="1s" sinceversion="3"/>
        </do_if>
        <remove_value name="$dropped_totalvolume"/>
        <remove_value name="$dropped_totalpercent"/>
        <remove_value name="$response"/>
        <remove_value name="$donotcollect"/>
      </do_if>
      <remove_value name="$satisfied"/>

      <do_if value="$stayput?">
        <resume label="patrol"/>
      </do_if>
      <resume label="prep"/>

      <!--<run_script name="'order.fight.patrol'">
        <!-<param name="space" value="$targetzone"/>->
        <param name="range" value="$range"/>
        <param name="pursuetargets" value="false"/>
        <param name="pursuedistance" value="this.ship.maxradarrange"/>
        <param name="timeout" value="$search_duration"/>
        <param name="allowothertargets" value="false"/>
        <param name="targetpurposes" value="[purpose.trade, purpose.mine]"/>
        <param name="debugchance" value="$debugchance"/>
      </run_script>

      <resume label="plunder"/>-->

      <label name="offload"/>

      <!-- Enable dropping of wares at a station-->
      <do_if value="$returntobase and $offload?">
        <debug_text text="this.ship.knownname + ' has ' + (1 - ($freecapacity / $totalcapacity)) * 100 + '% of cargo filled. Looking to offload some.'" chance="$debugchance"/>

        <do_if value="@$base.isoperational and this.ship.trueowner == $base.trueowner">
          <run_script name="'order.assign.commander'">
            <param name="commander" value="$base"/>
            <param name="cancelorders" value="false"/>
          </run_script>
          <!--<append_to_list name="$sellspaces" exact="$base"/>-->
        </do_if>

        <set_value name="$indices_found" exact="[]"/>
        <do_all exact="$basebasket.count" counter="$i">
          <do_if value="this.ship.cargo.list.indexof.{$basebasket.{$i}}">
            <append_to_list name="$indices_found" exact="$i"/>
          </do_if>
        </do_all>

        <do_if value="$base and $base != this.ship.commander and $indices_found.count">
          <do_all exact="$indices_found.count" counter="$i">
            <do_if value="$base.relationto.{this.ship} lt 0">
              <debug_text text="'%s (%s) reporting to client %s (%s). client is hostile. covering.'.[this.ship.knownname, this.ship, $base.knownname, $base]" chance="$debugchance"/>
              <signal_objects object="player.galaxy" param="'Cover'" param2="[this.ship, $base.owner, true, true]"/>
            </do_if>
            <debug_text text="'%s (%s) selling %s to client %s (%s) in %s, %s.'.[this.ship.knownname, this.ship, $basebasket.{$indices_found.{$i}}.name, $base.knownname, $base, $base.sector.knownname, $base.cluster.knownname]" chance="$debugchance"/>
            <run_script name="'order.trade.single.sell'">
              <param name="ware" value="$basebasket.{$indices_found.{$i}}"/>
              <param name="locations" value="[$base]"/>
              <param name="pricethreshold" value="1Cr"/>
              <param name="debugchance" value="$debugchance"/>
            </run_script>
          </do_all>
        </do_if>
        <do_else>
          <!-- With commander, try to sell to him, otherwise free trade in range
                'trade.find.free' handles the case of commander with no offers -->
          <!--<set_value name="$traderunscript" exact="if ($returntobase and $base and not $base.isclass.ship) then 'trade.find.commander' else 'trade.find.free'"/>-->
          <set_value name="$traderunscript" exact="if (this.ship.commander.isoperational and not this.ship.commander.isclass.ship) then 'trade.find.commander' else 'trade.find.free'"/>
          <run_script name="$traderunscript">
            <param name="warebasket" value="this.ship.cargo.list"/>
            <!-- range doesn't matter -->
            <param name="range" value="$space"/>
            <param name="sellspaces" value="$sellspaces.clone"/>
            <param name="debugchance" value="$debugchance"/>
            <save_retval name="buyoffer" variable="$buyoffer"/>
          </run_script>

          <!-- Execute the trade -->
          <do_if value="$buyoffer.available and $buyoffer.amount">
            <clamp_trade_amount trade="$buyoffer" amount="$buyoffer.amount" buyer="$buyoffer.buyer" seller="this.ship" result="$amount"/>
            <debug_text text="'Buyer found! Selling %1 %2 to %3 (%4)'.[$amount, $buyoffer.ware, $buyoffer.buyer.knownname, $buyoffer.buyer]" chance="$debugchance"/>
            <create_trade_order object="this.ship" tradeoffer="$buyoffer" amount="$amount" internal="true" immediate="true"/>
          </do_if>
          <do_else>
            <do_if value="not this.isplayerowned">
              <!-- if we can't find a trade, drop the least valuable wares in our cargo. -->
              <set_value name="$currentcargo" exact="this.ship.cargo.list"/>
              <do_all exact="$currentcargo.count" counter="$i">
                <do_if value="not $dropware? or ($currentcargo.{$i}.averageprice lt @$dropware.averageprice)">
                  <set_value name="$dropware" exact="$currentcargo.{$i}"/>
                </do_if>
              </do_all>
              <do_if value="$dropware?">
                <set_value name="$donotcollect"/>
                <debug_text text="'No buyer found. Dropping %1'.[$dropware]" chance="$debugchance"/>
                <drop_cargo object="this.ship" ware="$dropware" exact="this.ship.cargo.{$dropware}.max"/>
                <remove_value name="$dropware"/>
              </do_if>
              <remove_value name="$currentcargo"/>
              <remove_value name="$offload"/>
            </do_if>
            <resume label="start"/>
          </do_else>
        </do_else>
        <remove_value name="$indices_found"/>

        <set_value name="this.$signaldone" exact="'plunder done'"/>
        <!-- short wait to allow immediate trade orders to start, if any are made. -->
        <wait exact="100ms" sinceversion="2"/>
      </do_if>

      <label name="finish"/>

      <debug_text text="'This ship %1 (%2) finished this script'.[this.ship.knownname, this.ship]" chance="$debugchance"/>
      <do_if value="$base.exists">
        <signal_objects object="$base" param="'plunder done'" param2="this.ship"/>
      </do_if>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <debug_text text="'%1 doing job %2 has expired, die!'.[this.ship.knownname, this.ship.job]" chance="$debugchance"/>
        <create_order object="this.ship" id="'MoveDie'" immediate="true">
          <param name="byhostile" value="true" />
        </create_order>
      </do_if>
    </actions>
  </attention>
</aiscript>