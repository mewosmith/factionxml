<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="order.mining.routine" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="10">
  <!--
  This script will try to automatically supply stations and will only work with
  a valid warebasket parameter (defined via jobs). It can do gas and mineral
  mining and works for all ship classes. 
  
  Supports:
   * Range: space class or space string 'zone', 'sector', 'cluster'
   * Buy/Sell with Min/Max gate distances from $range
  
  If there is a valid commander, it will gather resources to supply the commander (homebase)
  
  -->
  <order id="MiningRoutine" name="{1041, 341}" description="{1041, 342}" category="internal">
    <params>
      <param name="warebasket" required="true" default="this.ship.warebasket.list" type="list" text="{1041, 10146}" comment="Wares. list of wares that takes precedence over any defined warebasket">
        <input_param name="type" value="'ware'"/>
        <input_param name="cancarry" value="this.ship"/>
      </param>
      <param name="range" default="if @this.ship.commanderentity.$config_subordinate_range then @this.ship.commanderentity.$config_subordinate_range 
             else (if @this.ship.commander.isclass.[class.station, class.buildstorage] then this.ship.commander.sector else (if this.ship.jobmainzone then this.ship.jobmainzone.sector else this.sector))" type="internal" text="{1041, 10005}" comment="Anchor space"/>

      <param name="minbuy" default="0" type="number" advanced="true" text="{1041, 10067}" comment="Min gate distance to gather resources. Gathering range supported if $minsell and $maxsell are provided">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[([@this.ship.commander.tradenpc.skill.management, @this.ship.pilot.skill.piloting].max / 3) - 1, 0].max"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="maxbuy" default="0" type="number" text="{1041, 10056}" comment="Max gate distance to gather resources. Gathering range supported if $minsell and $maxsell are provided">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[@this.ship.commander.tradenpc.skill.management, @this.ship.pilot.skill.piloting].max / 3"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="minsell" default="0" type="number" advanced="true" text="{1041, 10069}" comment="Min gate distance to sell resources. Sell range supported if $minsell and $maxsell are provided">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[([@this.ship.commander.tradenpc.skill.management, @this.ship.pilot.skill.piloting].max / 3) - 1, 0].max"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="maxsell" default="0" type="number" text="{1041, 10058}" comment="Max gate distance to sell resources. Sell range supported if $minsell and $maxsell are provided">
        <input_param name="startvalue" value="0"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="[@this.ship.commander.tradenpc.skill.management, @this.ship.pilot.skill.piloting].max / 3"/>
        <input_param name="step" value="1"/>
      </param>

      <param name="deepspace" default="false" type="bool" text="{1041, 10082}" advanced="true" comment="Operate in deep space. Operate only in deep space. Currently defined as 100 +/- 50km from sector core edge"/>
      <param name="resourcescout" default="false" type="bool" text="{1041, 10109}" advanced="true" comment="Scout for resources. Visibly look for resources before mining"/>
      <param name="duration" default="0s" type="time" infinitevalue="0s" advanced="true" text="{1041, 10034}" comment="Duration">
        <input_param name="startvalue" value="0s"/>
        <input_param name="min" value="0s"/>
        <input_param name="max" value="24h"/>
        <input_param name="step" value="1min"/>
        <patch value="0s" sinceversion="7"/>
      </param>
      <param name="effectiveskill" default="this.ship.combinedskill" type="internal" comment="Effective skill level used for skill checks"/>
      <param name="debugchance" type="bool" default="0" advanced="true" text="{1041, 10086}" comment="Print debug output">
        <input_param name="truevalue" value="100"/>
      </param>
      <param name="debugchance2" type="bool" default="0" advanced="true" text="{1041, 10142}" comment="Verbose debug output">
        <input_param name="truevalue" value="100"/>
      </param>
    </params>
    <skill min="20"/>
    <requires primarypurpose="purpose.mine"/>
  </order>
  <interrupts>
    <handler ref="SectorChangeHandler"/>
    <handler ref="AttackHandler" />
    <handler ref="MissileLockHandler" />
    <handler ref="ScannedHandler" />
    <handler ref="InspectedHandler"/>
    <handler ref="FoundAbandonedHandler"/>
    <handler ref="FoundLockboxHandler"/>
    <handler ref="ResupplyHandler" />
    <handler ref="TargetInvalidHandler"/>
    <handler comment="handler kept local since it modifies a value local to this script">
      <conditions>
        <event_object_signalled object="this.assignedcontrolled" param="'range_setting_updated'" />
      </conditions>
      <actions>
        <set_value name="$range" exact="if @event.param2 then event.param2 else this.assignedcontrolled.commanderentity.$config_subordinate_range" />
        <debug_text text="'updated operational range for %1(%2) to %3(%4)'.[this.assignedcontrolled.knownname, this.assignedcontrolled, $range.knownname, $range]" chance="$debugchance" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.freemining" />
    <!-- Mining for commander (Must to be Station) -->
    <do_if value="@this.assignedcontrolled.commander.isclass.[class.station, class.buildstorage]">
      <set_value name="$homebase" exact="this.assignedcontrolled.commander" />
    </do_if>

    <set_value name="$time_start" exact="player.age"/>
    <do_if value="(this.assignedcontrolled.order.id == 'MiningRoutine') or (this.assignedcontrolled.order.id == 'MiningRoutine_Basic') or (this.assignedcontrolled.order.id == 'MiningRoutine_Advanced') or (this.assignedcontrolled.order.id == 'MiningRoutine_Expert')">
      <set_value name="$thisorder" exact="this.assignedcontrolled.order"/>
    </do_if>

    <do_if value="this.isplayerowned">
      <set_value name="$maxrange" exact="[@this.assignedcontrolled.commander.tradenpc.skill.management, @this.skill.piloting].max / 3"/>
      <do_if value="$effectiveskill == 100">
        <set_value name="$maxrange" exact="$maxrange * 3"/>
      </do_if>
      <do_if value="$minbuy gt [$maxrange - 1, 0].max">
        <edit_order_param order="this.assignedcontrolled.order" param="'minbuy'" value="[$maxrange - 1, 0].max"/>
      </do_if>
      <do_if value="$minsell gt [$maxrange - 1, 0].max">
        <edit_order_param order="this.assignedcontrolled.order" param="'minsell'" value="[$maxrange - 1, 0].max"/>
      </do_if>
      <do_if value="$maxsell gt $maxrange">
        <edit_order_param order="this.assignedcontrolled.order" param="'maxsell'" value="$maxrange"/>
      </do_if>

      <do_if value="not @$homebase.isoperational">
        <do_if value="$maxbuy gt $maxrange">
          <edit_order_param order="this.assignedcontrolled.order" param="'maxbuy'" value="$maxrange"/>
        </do_if>
      </do_if>
      <do_else>
        <!-- station-based miners always harvest at their maximum range. changing maxsell won't do anything since they'll always only offload at their own station. -->
        <do_if value="$maxbuy != $maxrange">
          <edit_order_param order="this.assignedcontrolled.order" param="'maxbuy'" value="$maxrange"/>
        </do_if>
      </do_else>
      <remove_value name="$maxrange"/>
    </do_if>

    <!-- update effective skill everytime the script starts. -->
    <do_if value="($effectiveskill != 0) and ($effectiveskill != 100)">
      <set_value name="$effectiveskill" exact="this.assignedcontrolled.combinedskill"/>
    </do_if>

    <!-- to do: for now, these are based on maximum logged numbers and will have to be updated when yields are updated.
                  if/when a way to directly get the yield of spaces (preferably clusters, but zones will do. regions would be ok, but only if you could get some sort of position information) is available, do that instead. -->
    <set_value name="$minamounts" exact="table[{ware.ore}=1000, {ware.silicon}=1000, {ware.ice}=1000, {ware.nividium}=1000, {ware.helium}=1000, {ware.methane}=1000, {ware.hydrogen}=1000]"/>
  </init>
  <patch sinceversion="2">
    <do_if value="$minbuy == -1">
      <set_value name="$minbuy" exact="0"/>
    </do_if>
    <do_if value="$maxbuy == -1">
      <set_value name="$maxbuy" exact="0"/>
    </do_if>
    <do_if value="$minsell == -1">
      <set_value name="$minsell" exact="0"/>
    </do_if>
    <do_if value="$maxsell == -1">
      <set_value name="$maxsell" exact="0"/>
    </do_if>
    <do_if value="($minbuy gt 0) and ($minbuy ge $maxbuy)">
      <debug_text text="'PATCH: minbuy is greater than maxbuy. cannot find spaces. resetting minbuy to 0.'" filter="savegame"/>
      <set_value name="$minbuy" exact="0"/>
    </do_if>
    <do_if value="($minsell gt 0) and ($minsell ge $maxsell)">
      <debug_text text="'PATCH: minsell is greater than maxsell. cannot find spaces. resetting minsell to 0.'" filter="savegame"/>
      <set_value name="$minsell" exact="0"/>
    </do_if>
  </patch>
  <patch sinceversion="3">
    <do_if value="this.isplayerowned">
      <set_value name="$maxrange" exact="[@this.assignedcontrolled.commander.tradenpc.skill.management, @this.assignedcontrolled.pilot.skill.piloting].max / 3"/>
      <do_if value="$minbuy gt [$maxrange - 1, 0].max">
        <debug_text text="'PATCH: reducing minbuy from %s to %s'.[$minbuy, $maxrange - 1]" filter="savegame"/>
        <edit_order_param order="this.assignedcontrolled.order" param="'minbuy'" value="[$maxrange - 1, 0].max"/>
      </do_if>
      <do_if value="$maxbuy gt $maxrange">
        <debug_text text="'PATCH: reducing maxbuy from %s to %s'.[$maxbuy, $maxrange]" filter="savegame"/>
        <edit_order_param order="this.assignedcontrolled.order" param="'maxbuy'" value="$maxrange"/>
      </do_if>
      <do_if value="$minsell gt [$maxrange - 1, 0].max">
        <debug_text text="'PATCH: reducing minsell from %s to %s'.[$minsell, $maxrange - 1]" filter="savegame"/>
        <edit_order_param order="this.assignedcontrolled.order" param="'minsell'" value="[$maxrange - 1, 0].max"/>
      </do_if>
      <do_if value="$maxsell gt $maxrange">
        <debug_text text="'PATCH: reducing maxsell from %s to %s'.[$maxsell, $maxrange]" filter="savegame"/>
        <edit_order_param order="this.assignedcontrolled.order" param="'maxsell'" value="$maxrange"/>
      </do_if>
      <remove_value name="$maxrange"/>
    </do_if>
  </patch>
  <patch sinceversion="4">
    <do_if value="this.assignedcontrolled.order.id == 'MiningRoutine'">
      <edit_order_param order="this.assignedcontrolled.order" param="'effectiveskill'" value="this.assignedcontrolled.combinedskill"/>
    </do_if>
  </patch>
  <patch sinceversion="7">
    <set_value name="$time_start" exact="player.age"/>
    <set_value name="$duration" exact="0s"/>

    <do_if value="(this.assignedcontrolled.order.id == 'MiningRoutine') or (this.assignedcontrolled.order.id == 'MiningRoutine_Basic') or (this.assignedcontrolled.order.id == 'MiningRoutine_Advanced') or (this.assignedcontrolled.order.id == 'MiningRoutine_Expert')">
      <!-- NB: if this is not the current order, variables will be correctly set when the script starts/restarts. -->
      <set_value name="$thisorder" exact="this.assignedcontrolled.order"/>
    </do_if>
  </patch>
  <patch sinceversion="10">
    <!-- if $gatheringspaces has not yet been defined, $range will be re-evaluated after it is defined. -->
    <do_if value="this.hasrelation.enemy.{$range.owner} and @$gatheringspaces.count">
      <do_all exact="$gatheringspaces.count" counter="$i">
        <do_if value="$gatheringspaces.{$i}.owner == this.owner">
          <set_value name="$locrange" exact="$gatheringspaces.{$i}"/>
          <break/>
        </do_if>
        <do_elseif value="not this.hasrelation.enemy.{$gatheringspaces.{$i}.owner}">
          <set_value name="$locfallback" exact="$gatheringspaces.{$i}"/>
        </do_elseif>
      </do_all>

      <do_if value="not $locrange? and $locfallback?">
        <set_value name="$locrange" exact="$locfallback"/>
      </do_if>
      <remove_value name="$locfallback"/>

      <do_if value="$locrange?">
        <set_value name="$range" exact="$locrange"/>
        <debug_text text="'PATCH: old anchor space was hostile. changing to %s %s.'.[$range.class, $range.knownname]" filter="savegame"/>
        <do_if value="@this.assignedcontrolled.order.$range.isclass.space">
          <edit_order_param order="this.assignedcontrolled.order" param="'range'" value="$range"/>
          <do_if value="this.assignedcontrolled.defaultorder == this.assignedcontrolled.order">
            <edit_order_param order="this.assignedcontrolled.defaultorder" param="'range'" value="$range"/>
          </do_if>
        </do_if>
      </do_if>
      <remove_value name="$locrange"/>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>
      <do_if value="($minbuy gt 0) and ($minbuy ge $maxbuy)">
        <debug_text text="'minbuy is greater than maxbuy. cannot find spaces. resetting minbuy to 0.'" filter="error"/>
        <set_value name="$minbuy" exact="0"/>
      </do_if>
      <do_if value="($minsell gt 0) and ($minsell ge $maxsell)">
        <debug_text text="'minsell is greater than maxsell. cannot find spaces. resetting minsell to 0.'" filter="error"/>
        <set_value name="$minsell" exact="0"/>
      </do_if>

      <do_if value="this.assignedcontrolled.isonlineobject and not this.isplayerowned">
        <debug_text text="'Venture ship %s %s %s ordered to mine. num wares in basket: %s.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, @$warebasket.count]" chance="$debugchance"/>
        <do_if value="not @$warebasket.count">
          <debug_text text="'no warebasket defined. populating ware basket with cargo in hold. adding %s wares to the warebasket.'.[this.assignedcontrolled.cargo.count]" chance="$debugchance"/>
          <set_value name="$warebasket" exact="this.assignedcontrolled.cargo.list.clone"/>
        </do_if>

        <do_if value="this.assignedcontrolled.cargo.capacity.solid or this.assignedcontrolled.cargo.capacity.universal">
          <set_value name="$canminesolid"/>
        </do_if>
        <do_if value="this.assignedcontrolled.cargo.capacity.liquid or this.assignedcontrolled.cargo.capacity.universal">
          <set_value name="$canmineliquid"/>
        </do_if>

        <set_value name="$isvalidventure" exact="false"/>
        <do_if value="@$warebasket.count and ($canminesolid or $canmineliquid)">
          <do_all exact="$warebasket.count" counter="$i">
            <do_if value="this.assignedcontrolled.cargo.{$warebasket.{$i}}.max">
              <do_if value="($canminesolid? and ($warebasket.{$i}.waretransport == waretransport.solid)) or ($canmineliquid? and ($warebasket.{$i}.waretransport == waretransport.liquid))">
                <set_value name="$isvalidventure" exact="true"/>
                <debug_text text="'Venture ship %s %s %s can mine ware %s.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $warebasket.{$i}]" chance="$debugchance"/>
                <break/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <do_else>
          <debug_text text="'Venture ship %s %s %s either does not have a ware basket or cannot carry mineable wares.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
        </do_else>

        <do_if value="not $isvalidventure">
          <debug_text text="'Venture ship %s %s %s was ordered to mine but cannot. Getting new orders.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, this.assignedcontrolled.defaultorder.id]" chance="$debugchance"/>
          <cancel_all_orders object="this.assignedcontrolled"/>
          <run_script name="'lib.request.orders'" sinceversion="1">
            <param name="object" value="this.assignedcontrolled"/>
            <param name="debugchance" value="$debugchance"/>
          </run_script>
        </do_if>
      </do_if>

      <label name="prep"/>

      <do_if value="(not this.isplayerowned and not this.hasrelation.enemy.{this.sector.owner}) or $forceidle?">
        <!-- Idle for a while -->
        <run_script name="'move.idle'" >
          <param name="Min" value="20s" />
          <param name="Max" value="70s" />
        </run_script>
        <remove_value name="$forceidle"/>
      </do_if>

      <do_if value="not $resourcescout and this.assignedcontrolled.iscapitalship">
        <remove_value name="$resupplying"/>
        <do_if value="this.assignedcontrolled.waretransport.indexof.{waretransport.solid} and not this.assignedcontrolled.units.{unitcategory.orecollector}.count">
          <debug_text text="'%s %s %s starting MiningRoutine with no ore collectors. trying to get some.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
          <signal_objects object="this.assignedcontrolled" param="'resupply'" param2="[true]" param3="$debugchance" comment="param2 = [urgent?, resupplystationID], param3 = $debugchance"/>
          <set_value name="$resupplying"/>
        </do_if>
        <do_elseif value="this.assignedcontrolled.waretransport.indexof.{waretransport.liquid} and not this.assignedcontrolled.units.{unitcategory.gascollector}.count">
          <debug_text text="'%s %s %s starting MiningRoutine with no gas collectors. trying to get some.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
          <signal_objects object="this.assignedcontrolled" param="'resupply'" param2="[true]" param3="$debugchance" comment="param2 = [urgent?, resupplystationID], param3 = $debugchance"/>
          <set_value name="$resupplying"/>
        </do_elseif>
        <do_if value="$resupplying?">
          <remove_value name="$resupplying"/>
          <wait exact="1s" sinceversion="9"/>
          <!-- NB: if we're still here, interrupt.restock couldn't find any places to buy ore collectors. idle and try again later. -->
          <debug_text text="'unable to get collector drones. idling and trying again later.'" chance="$debugchance"/>
          <set_value name="$forceidle"/>
          <resume label="prep"/>
        </do_if>
      </do_if>

      <!-- basic checks first -->
      <label name="start" />

      <!-- check cargo capacity -->
      <do_if value="this.assignedcontrolled.cargo.capacity.all" max="0">
        <debug_text text="'%1 has cargo capacity of %2!'.[this.assignedcontrolled.knownname, this.assignedcontrolled.cargo.capacity.all]" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_CARGOSPACE'" />
        <set_value name="$failreason2" exact="'Macro: ' + this.assignedcontrolled.macro.name" />
        <resume label="finish" />
      </do_if>

      <!-- check basket -->
      <do_if value="not $warebasket.count and not @$homebase.isoperational">
        <do_if value="this.assignedcontrolled.job and this.assignedcontrolled.warebasket.count">
          <debug_text text="'job ship %s %s %s with job %s had no warebasket. recovering with job-defined basket: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, this.assignedcontrolled.job, this.assignedcontrolled.warebasket.list]" chance="$debugchance"/>
          <edit_order_param order="this.assignedcontrolled.order" param="'warebasket'" value="this.assignedcontrolled.warebasket.list"/>
          <wait exact="1s" sinceversion="8"/>
        </do_if>
        <do_else>
          <debug_text text="'mining without warebasket defined in jobs not supported!'" chance="$debugchance" />
          <set_value name="$failreason" exact="'ERR_NO_WAREBASKET'" />
          <set_value name="$failreason2" exact="'Job: ' + this.assignedcontrolled.job" />
          <resume label="finish" />
        </do_else>
      </do_if>

      <!-- Ranges -->
      <do_if value="not @$range.isclass.space">
        <!-- For jobs, get the string range 'zone', 'sector', 'cluster' -->
        <set_value name="$range" exact="this.assignedcontrolled.{$range}" />
      </do_if>

      <do_if value="this.isplayerowned">
        <!-- if maxbuy or maxsell is 0, we must assume that the player wants us to go back to this space regardless of blacklist. -->
        <do_if value="$maxbuy le 0">
          <set_value name="$blacklist_overridebuy"/>
        </do_if>
        <do_if value="$maxsell le 0">
          <set_value name="$blacklist_overridesell"/>
        </do_if>
      </do_if>

      <run_script name="'lib.find.sectors.inrange'" result="$gatheringspaces" sinceversion="5">
        <param name="refobject" value="$range"/>
        <param name="mingatedistance" value="$minbuy"/>
        <param name="maxgatedistance" value="$maxbuy"/>
        <param name="debugchance" value="$debugchance"/>
      </run_script>
      <do_if value="$blacklist_overridebuy? and not $gatheringspaces.indexof.{$range} and $range.isclass.sector">
        <append_to_list name="$gatheringspaces" exact="$range"/>
      </do_if>
      <debug_text text="'%s %s %s found %s gathering spaces.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $gatheringspaces.count]" chance="$debugchance"/>

      <run_script name="'lib.find.sectors.inrange'" result="$sellspaces" sinceversion="5">
        <param name="refobject" value="$range"/>
        <param name="mingatedistance" value="$minsell"/>
        <param name="maxgatedistance" value="$maxsell"/>
        <param name="debugchance" value="$debugchance"/>
      </run_script>
      <do_if value="$blacklist_overridesell? and not $sellspaces.indexof.{$range} and $range.isclass.sector">
        <append_to_list name="$sellspaces" exact="$range"/>
      </do_if>
      <debug_text text="'%s %s %s found %s sell spaces.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $sellspaces.count]" chance="$debugchance"/>

      <do_if value="not $gatheringspaces.count and not $sellspaces.count">
        <debug_text text="'No gatheringspaces and no sellspaces. %s %s %s in sector %s cannot operate. Idling for a while and trying again later in case conditions change.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @this.assignedcontrolled.sector.knownname]"/>
        <set_value name="$forceidle"/>
        <resume label="prep"/>
      </do_if>

      <do_if value="this.hasrelation.enemy.{$range.owner}">
        <do_all exact="$gatheringspaces.count" counter="$i">
          <do_if value="$gatheringspaces.{$i}.owner == this.owner">
            <set_value name="$locrange" exact="$gatheringspaces.{$i}"/>
            <break/>
          </do_if>
          <do_elseif value="not this.hasrelation.enemy.{$gatheringspaces.{$i}.owner}">
            <set_value name="$locfallback" exact="$gatheringspaces.{$i}"/>
          </do_elseif>
        </do_all>

        <do_if value="not $locrange? and $locfallback?">
          <set_value name="$locrange" exact="$locfallback"/>
        </do_if>
        <remove_value name="$locfallback"/>

        <do_if value="$locrange?">
          <set_value name="$range" exact="$locrange"/>
          <debug_text text="'old anchor space was hostile. changing to %s %s.'.[$range.class, $range.knownname]" chance="$debugchance"/>
          <do_if value="@this.assignedcontrolled.order.$range.isclass.space">
            <edit_order_param order="this.assignedcontrolled.order" param="'range'" value="$range"/>
            <do_if value="this.assignedcontrolled.defaultorder == this.assignedcontrolled.order">
              <edit_order_param order="this.assignedcontrolled.defaultorder" param="'range'" value="$range"/>
            </do_if>
            <!-- wait until order is restarted by param changing. -->
            <wait sinceversion="10"/>
          </do_if>
        </do_if>
        <remove_value name="$locrange"/>
      </do_if>

      <do_if value="this.hasrelation.enemy.{this.sector.owner} and not this.hasrelation.enemy.{$range.owner}">
        <debug_text text="'sector we are currently in is hostile. moving to safe space.'" chance="$debugchance"/>
        <run_script name="'move.generic'" sinceversion="10">
          <param name="destination" value="$range"/>
          <param name="endintargetzone" value="true"/>
          <param name="debugchance" value="$debugchance" />
        </run_script>
        <resume label="prep"/>
      </do_if>

      <!-- primary loop start -->
      <label name="loop" />

      <do_if value="$duration and ((player.age - $time_start) gt $duration)">
        <resume label="finish"/>
      </do_if>

      <do_if value="not $resourcescout and this.assignedcontrolled.iscapitalship and ((this.assignedcontrolled.waretransport.indexof.{waretransport.solid} and not this.assignedcontrolled.units.{unitcategory.orecollector}.count) or (this.assignedcontrolled.waretransport.indexof.{waretransport.liquid} and not this.assignedcontrolled.units.{unitcategory.gascollector}.count))">
        <debug_text text="'%s %s %s has no collector drones. looping back to prep.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
        <resume label="prep"/>
      </do_if>

      <do_if value="player.age gt @$next_resupply_check" chance="30">
        <debug_text text="'%1 (%2) ready to resupply.'.[this.assignedcontrolled.knownname, this.assignedcontrolled]" chance="$debugchance"/>
        <signal_objects object="this.assignedcontrolled" param="'resupply'" param2="[false]" param3="$debugchance" comment="param2 = [urgent?, resupplystationID], param3 = $debugchance"/>
        <set_value name="$next_resupply_check" exact="player.age + 30min"/>
      </do_if>

      <!-- sell wares first if less than 50% free cargo -->
      <do_if value="(this.assignedcontrolled.cargo.free.all)f / this.assignedcontrolled.cargo.capacity.all" max="0.5">
        <resume label="sellwares" />
      </do_if>
      <do_else>
        <debug_text text="player.age + ' looking good, starting new mining run'" chance="$debugchance" />
      </do_else>

      <!-- command action -->
      <set_command_action commandaction="commandaction.searchingresources" />

      <!-- Create the mining basket -->
      <create_list name="$miningbasket" />
      <!-- When Mining for commander -->
      <do_if value="@$homebase.isoperational">
        <!-- update the wares we deal with for a new trade run - ensure that we don't miss any wares if the list has changed due to the homebase being expanded -->
        <set_value name="$resources" exact="$homebase.resources.list" />

        <set_value name="$supplyresources" exact="$homebase.supplyresources.list" />
        <do_all exact="$supplyresources.count" counter="$i">
          <do_if value="not $resources.indexof.{$supplyresources.{$i}}">
            <append_to_list name="$resources" exact="$supplyresources.{$i}"/>
          </do_if>
        </do_all>

        <!-- support working for trade stations / warehouses as well -->
        <set_value name="$tradewares" exact="$homebase.tradewares.list" />
        <do_all exact="$tradewares.count" counter="$i">
          <do_if value="not $resources.indexof.{$tradewares.{$i}}">
            <append_to_list name="$resources" exact="$tradewares.{$i}" />
          </do_if>
        </do_all>
        <remove_value name="$tradewares" />

        <!-- start with an empty list in case warebasket contains outdated wares. -->
        <create_list name="$locwares"/>
        <!-- Resources + Tradewares to Warebasket -->
        <do_all exact="$resources.count" counter="$i">
          <set_value name="$ware" exact="$resources.{$i}" />
          <!-- Minable wares, with capacity to carry them and that are not already in the ware list -->
          <do_if value="($ware.tags.indexof.{tag.minable}) and (this.assignedcontrolled.cargo.{$ware}.max gt 0) and (not $locwares.indexof.{$ware})">
            <!-- either is not a big ship, or the ware is not mineral, or it is mineral and needs collectors -->
            <do_if value="(not this.assignedcontrolled.isclass.[class.ship_l, class.ship_xl]) or (not $ware.tags.indexof.{tag.mineral}) or (this.object.units.collect.{$ware}.count)">
              <append_to_list name="$locwares" exact="$ware"/>
              <do_if value="not $warebasket.indexof.{$ware}">
                <set_value name="$basketchanged"/>
              </do_if>
            </do_if>
          </do_if>
        </do_all>

        <!-- check to see if we either added something or removed something from our warebasket. -->
        <do_if value="$basketchanged? or ($warebasket.count != $locwares.count)">
          <debug_text text="'%s %s %s updating warebasket. wares added? %s, wares removed? %s\nnew warebasket: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $basketchanged?, $locwares.count != $warebasket.count, $warebasket]" chance="$debugchance"/>
          <set_value name="$warebasket" exact="$locwares.clone"/>
          <do_if value="this.assignedcontrolled.order.id == 'MiningRoutine'">
            <edit_order_param order="this.assignedcontrolled.order" param="'warebasket'" value="$locwares"/>
            <wait exact="1ms" sinceversion="6"/>
          </do_if>
        </do_if>
        <remove_value name="$locwares"/>

        <do_if value="not $warebasket.count">
          <debug_text text="'Home base: %s %s %s does not need anything at the moment. Waiting to check again.'.[@$homebase.idcode, @$homebase.knownname, $homebase]" chance="$debugchance"/>
          <set_value name="$forceidle"/>
          <resume label="prep"/>
        </do_if>

        <!-- we build our shopping list by intersecting our warebasket and the resources of our homebase -->
        <set_value name="$shoppinglist" exact="table[]" />
        <!-- Get the buy offers with this ships as partner -->
        <find_buy_offer buyer="$homebase" multiple="true" result="$buyoffers" wares="$warebasket" tradepartner="this.assignedcontrolled"/>
        <debug_text text="player.age + ' homebase %1 [%2] has %3 offers for %4'.[$homebase.knownname, $homebase, $buyoffers.count, $warebasket]" chance="$debugchance" />
        <!-- Create the shoppinglist table -->
        <do_if value="$buyoffers.count" min="1">
          <!-- use the buyoffers on our homebase to determine resource need -->
          <do_all counter="$b" exact="$buyoffers.count">
            <set_value name="$buyoffer" exact="$buyoffers.{$b}" />
            <get_ware_reservation object="$homebase" ware="$buyoffer.ware" type="sell" virtual="true" result="$reserved" />
            <debug_text text="player.age + ' %1 wants %5(want %2, expecting %4) units of %3'.[$homebase.knownname, $buyoffer.offeramount.{this.assignedcontrolled}, $buyoffer.ware, $reserved, [$buyoffer.offeramount.{this.assignedcontrolled} - $reserved, 0].max]" chance="$debugchance" />
            <!-- Table key: buyoffer, value: needed amount (buy offer amount - reserved) / target amount -->
            <set_value name="$shoppinglist.{$buyoffer}" exact="[$buyoffer.offeramount.{this.assignedcontrolled} - $reserved, 0].max / ([$homebase.cargo.{$buyoffer.ware}.target, 1].max)f"/>
          </do_all>
          <remove_value name="$reserved" />
          <remove_value name="$buyoffer" />
          <remove_value name="$buyoffers" />
        </do_if>
        <!-- Minable resources that the station wants -->
        <do_if value="$shoppinglist.keys.count">
          <!-- Sorted by needed  -->
          <set_value name="$neededbuyoffers" exact="$shoppinglist.keys.sorted" />
          <create_list name="$miningbasket" comment="Ware list sorted by most needed wares" />
          <create_list name="$neededamounts" comment="Associated offer amounts for the sorted wares" />
          <create_list name="$priorities"/>
          <!-- Iterate in reverse to put the most needed (last) into the first places -->
          <do_all exact="$neededbuyoffers.count" counter="$i" reverse="true">
            <!-- key: buy offer ware, value: offer amount -->
            <append_to_list name="$miningbasket" exact="$neededbuyoffers.{$i}.ware" />
            <append_to_list name="$neededamounts" exact="$neededbuyoffers.{$i}.offeramount.{this.assignedcontrolled}"/>
            <append_to_list name="$priorities" exact="$shoppinglist.{$neededbuyoffers.{$i}}"/>
          </do_all>
          <do_all exact="$miningbasket.count" counter="$i" chance="$debugchance">
            <debug_text text="'ware: %s, amount: %s, priority: %s'.[$miningbasket.{$i}, $neededamounts.{$i}, $priorities.{$i}]"/>
          </do_all>
          <remove_value name="$shoppinglist" />
          <remove_value name="$neededbuyoffers" />
        </do_if>
        <do_else>
          <debug_text text="player.age + ' unable to find an appropriate buyoffer'" chance="$debugchance" />
        </do_else>
      </do_if>
      <!-- Free miner -->
      <do_else>
        <!-- Ware Selection: two choices. Either:
                Look through everything in $sellspaces and pick the ware that sells for the biggest price. (Barring travel cost, that would be the most profitable because costs are only capital. Ideal, but more expensive since more buy offers will have to be processed.)
                Or tally three (or some arbitrary number. only important that it's consistent.) prices, get the average (or just add them if you can always relibaly get the same number of offers for everything in the ware basket) and compare those. (Cheaper, but not as smart.)
                
                Idea is to guess which ware will be in high demand AFTER we're done mining.
                So we look at what's selling well now, but we don't do a comprehensive search because we have no idea if those conditions will hold later. -->
        <do_if value="($warebasket.count gt 1) and ((this.skill.management ge 6) or ($effectiveskill == 100))">
          <set_value name="$buyoffers_evaluate" exact="[]"/>
          <set_value name="$miningtable" exact="table[]"/>

          <!-- iterate over all of the clusters in the defined range. sellspaces is sorted by distance. -->
          <do_all exact="$sellspaces.count" counter="$i">
            <!-- find all buy offers in each space. -->
            <find_buy_offer tradepartner="this.assignedcontrolled" wares="$warebasket" space="$sellspaces.{$i}" result="$buyoffers_evaluate" multiple="true"/>
            <debug_text text="player.age + ' found %1 buy offers in %2. ware basket: %3'.[$buyoffers_evaluate.count, $sellspaces.{$i}.knownname, $warebasket]" chance="0"/>
            <wait min="30ms" max="70ms"/>
            <!-- if we found any ... -->
            <do_if value="$buyoffers_evaluate.count">
              <!-- shuffle list so that offers with the same relprice are still in a random order and not in the consistent order that the stations were found in -->
              <shuffle_list list="$buyoffers_evaluate"/>
              <!-- sort buy offers by relative price. relative price is the amount of deviation from average price. -->
              <sort_trades name="$buyoffers_evaluate" tradelist="$buyoffers_evaluate" sorter="relativeprice"/>
              <do_all exact="$buyoffers_evaluate.count" counter="$j" reverse="true">
                <!-- record this trade if:
                      we have not recorded a trade for this ware yet,
                      or we found a better price for this ware. (only relevant if we ever evaluate more than one cluster) -->
                <do_if value="not $miningtable.{$buyoffers_evaluate.{$j}.ware}? or ($buyoffers_evaluate.{$j}.relativeprice gt $miningtable.{$buyoffers_evaluate.{$j}.ware})">
                  <set_value name="$miningtable.{$buyoffers_evaluate.{$j}.ware}" exact="$buyoffers_evaluate.{$j}.relativeprice"/>
                  <debug_text text="'adding %1 to mining basket. price: %2. mining table: %3.'.[$buyoffers_evaluate.{$j}.ware, $buyoffers_evaluate.{$j}.relativeprice, $miningtable]" chance="$debugchance"/>
                </do_if>
                <!-- if we have records for all wares we are interested in, we need not look any further to get an estimate.
                      update: we don't really need the whole basket because we'll end up only getting one ware. stop after finding offers for two wares to limit the number of times we have to iterate.
                        update reverted because it could introduce the problem of mining ships never going after a third ware in their basket because two wares are always in demand in their starting cluster.
                        reduces the number of clusters evaluated from around 9 on average to 1 or 2 though, so performance gain could be substantial. might prove necessary. -->
                <!--<do_if value="$miningtable.keys.count == [2, $warebasket.count].min">-->
                <do_if value="$miningtable.keys.count == $warebasket.count">
                  <debug_text text="'offers found for everything in the basket! looked through ' + $i + ' clusters.'" chance="$debugchance"/>
                  <break/>
                </do_if>
              </do_all>
              <do_if value="$miningtable.keys.count == $warebasket.count">
                <break/>
              </do_if>
            </do_if>
          </do_all>

          <do_if value="$miningtable.keys.count">
            <debug_text text="'trade offers for %1 wares found. %2 wares in the ware basket.'.[$miningtable.keys.count, $warebasket.count]" chance="$debugchance"/>
            <!-- if the miner is really good, the list will be sorted by best price over the space evaluated. again, only relevant if more than one cluster is ever evaluated. -->
            <do_if value="true" chance="$effectiveskill">
              <set_value name="$sortedbasket" exact="$miningtable.keys.sorted"/>
              <do_all exact="$sortedbasket.count" counter="$i" reverse="true">
                <append_to_list name="$miningbasket" exact="$sortedbasket.{$i}"/>
              </do_all>
              <remove_value name="$sortedbasket"/>
            </do_if>
            <do_else>
              <set_value name="$miningbasket" exact="$miningtable.keys.list"/>
              <shuffle_list list="$miningbasket"/>
            </do_else>
            <debug_text text="'mining basket assembled: ' + $miningbasket" chance="$debugchance"/>
          </do_if>
          <do_else>
            <debug_text text="'no offers found after going through %1 clusters. %2 wares in the warebasket.'.[$sellspaces.count, $warebasket.count]" chance="$debugchance"/>
          </do_else>
          <!--<debug_text text="'%1 selected. prices: %2, %3, %4'.[$miningbasket.{1}, $miningtable.{$miningbasket.{1}}, $miningtable.{$miningbasket.{2}}, $miningtable.{$miningbasket.{3}}]" chance="$debugchance"/>-->

          <!-- if we are ever in a situation where we do not find buy offers for everything in our ware basket, add everything in the ware basket anyway
                  because there might not be demand for these wares right now, but there might be demand for them later. they will have lower priority. -->
          <do_if value="$miningbasket.count lt $warebasket.count">
            <do_all exact="$warebasket.count" counter="$i">
              <do_if value="not $miningbasket.indexof.{$warebasket.{$i}}">
                <append_to_list name="$miningbasket" exact="$warebasket.{$i}"/>
              </do_if>
            </do_all>
          </do_if>
          <remove_value name="$miningtable"/>
          <remove_value name="$buyoffers_evaluate"/>
        </do_if>
        <do_else>
          <!-- Really bad miners just get whatever is handy. -->
          <set_value name="$miningbasket" exact="$warebasket.clone"/>
          <shuffle_list list="$miningbasket"/>
          <debug_text text="'backup mining basket: ' + $miningbasket" chance="$debugchance"/>
        </do_else>
      </do_else>

      <!-- No minable resources -->
      <do_if value="not $miningbasket.count" >
        <debug_text text="player.age + ' unable to find minable resources, waiting...'" chance="$debugchance" />
        <!-- Idle for a while -->
        <run_script name="'move.idle'" >
          <param name="Min" value="30s" />
          <param name="Max" value="90s" />
        </run_script>
        <resume label="loop"/>
      </do_if>

      <!-- deepspace: find a spot within a region that will tend to be in deep space (doesn't have to be absolute) and mine there.
          that, or be able to define a minimum offset from sector center to pass into find_resource. -->

      <!-- to do: for now, these are based on maximum logged numbers and will have to be updated when yields are updated.
                  if/when a way to directly get the yield of spaces (preferably clusters, but zones will do. regions would be ok, but only if you could get some sort of position information) is available, do that instead. -->
      <do_all exact="$minamounts.keys.count" counter="$i">
        <set_value name="$minamounts.{$minamounts.keys.{$i}}" min="($minamounts.{$minamounts.keys.{$i}} * 0.5)i" max="$minamounts.{$minamounts.keys.{$i}}"/>
        <debug_text text="'table updated: ' + $minamounts" chance="0"/>
      </do_all>
      <!-- Iterate over the wares in the basket -->
      <do_all exact="$miningbasket.count" counter="$w" >
        <set_value name="$ware" exact="$miningbasket.{$w}" />
        <!-- Find Resouces: Iterate over the gathering spaces -->
        <do_all exact="$gatheringspaces.count" counter="$i">
          <debug_text text="'now looking for %1 in %2 %3'.[$ware, $gatheringspaces.{$i}.class, $gatheringspaces.{$i}.knownname]" chance="$debugchance" />
          <!-- NB: As this was (commented out below), when the ship evaluates this.cluster, it looks in the station's cluster. If it doesn't find anything until the list iterates to the station's cluster, it looks at it again.
                Changed so that it will look in this.cluster when it is in this.cluster.

                Possibly desirable behavior if the ship is subordinate to a station is to always look at the station's cluster first. In that case, the below and $range above would have to be changed.
                Same with the old method below. -->
          <do_if value="$deepspace">
            <do_if value="$gatheringspaces.{$i}.isclass.cluster">
              <find_sector name="$clustersectors" space="$gatheringspaces.{$i}" multiple="true"/>
            </do_if>
            <do_elseif value="$gatheringspaces.{$i}.isclass.sector">
              <set_value name="$clustersectors" exact="[$gatheringspaces.{$i}]"/>
            </do_elseif>
            <do_elseif value="$gatheringspaces.{$i}.sector">
              <set_value name="$clustersectors" exact="[$gatheringspaces.{$i}.sector]"/>
            </do_elseif>
            <do_else>
              <debug_text text="'ERROR: gatheringspaces.{$i}: %s %s is neither a cluster, nor a sector, nor something in a sector.'.[$gatheringspaces.{$i}.knownname, $gatheringspaces.{$i}]" filter="error"/>
            </do_else>
            <do_all exact="$clustersectors.count" counter="$j">
              <run_script name="'lib.find.point.indeepspace'" result="$deepspacepos">
                <param name="sector" value="$clustersectors.{$j}"/>
                <param name="allowyaxis" value="true"/>
              </run_script>
              <find_closest_resource ware="$ware" refobject="$clustersectors.{$j}" sector="$sector" position="$pos_sector" wares="$secwares" minamount="$minamounts.{$ware}">
                <refposition value="$deepspacepos"/>
              </find_closest_resource>
              <do_if value="$sector">
                <debug_text text="'find method 1. going to position: %s, %s, %s relative to sector %s %s\ndeepspace pos: %s, %s, %s'.[@$pos_sector.x, @$pos_sector.y, @$pos_sector.z, @$sector.knownname, $sector, $deepspacepos.x, $deepspacepos.y, $deepspacepos.z]" chance="$debugchance"/>
                <break/>
              </do_if>
            </do_all>
            <remove_value name="$clustersectors"/>
          </do_if>
          <do_elseif value="($gatheringspaces.{$i} == this.sector) or ($gatheringspaces.{$i} == this.cluster)">
            <find_closest_resource ware="$ware" refobject="this.assignedcontrolled" sector="$sector" position="$pos_sector" wares="$secwares" minamount="$minamounts.{$ware}"/>
            <!--<find_closest_resource ware="$ware" refobject="if $homebase? then $homebase else this.assignedcontrolled" zone="$zone" wares="$secwares" minamount="$minamounts.{$ware}"/>-->
          </do_elseif>
          <do_else>
            <find_resource ware="$ware" refobject="$gatheringspaces.{$i}" sector="$sector" position="$pos_sector" wares="$secwares" minamount="$minamounts.{$ware}"/>
          </do_else>
          <!-- Zone found -->
          <do_if value="$sector.exists">
            <debug_text text="'Resource %1 found in %2, %3. minamount: %4'.[$ware, $sector.knownname, $sector.cluster.knownname, $minamounts.{$ware}]" chance="$debugchance"/>
            <do_if value="not $gatheringspaces.indexof.{$sector} or $sector.hashazardousregion or this.hasrelation.enemy.{$sector.owner}">
              <debug_text text="'%s %s %s refuses to mine in sector %s belonging to %s. has hazardous region: %s. not in gatheringspaces: %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $sector.knownname, $sector.owner, $sector.hashazardousregion, not $gatheringspaces.indexof.{$sector}]" chance="$debugchance"/>
              <!-- allow player-owned ships automatically mining in a hazardous region if the only space they can operate in is in a hazardous region. -->
              <do_if value="not this.isplayerowned and ($gatheringspaces.count == 1)">
                <!-- NPC ships will try to mine in a hostile or hazardous region if they have no other choice. player-owned ships will not under any circumstances. -->
                <set_value name="$hostilesector" exact="$sector"/>
                <set_value name="$hostilepos" exact="$pos_sector"/>
              </do_if>
              <remove_value name="$sector"/>
            </do_if>
            <do_else>
              <debug_text text="'%s %s %s mining in sector %s belonging to %s. enemy? %s, effective skill: %s, combinedskill: %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $sector.knownname, $sector.owner, this.hasrelation.enemy.{$sector.owner}, $effectiveskill, this.assignedcontrolled.combinedskill]" chance="$debugchance"/>
              <break/>
            </do_else>
          </do_if>
          <wait min="1ms" max="100ms" comment="Avoid performance peaks with find functions" />
        </do_all>

        <do_if value="not @$sector.exists and @$hostilesector.exists">
          <debug_text text="'%s %s %s found no safe sector but hostile sector %s owned by %s found. has hazardous region? %s. mining in hostile sector.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $hostilesector.knownname, $hostilesector.owner, $hostilesector.hashazardousregion]" chance="$debugchance"/>
          <set_value name="$sector" exact="$hostilesector"/>
          <set_value name="$pos_sector" exact="$hostilepos"/>
        </do_if>

        <!-- if all else fails, do the old method. this is much more reliable. -->
        <do_if value="@$sector.exists" negate="true">
          <debug_text text="'Cannot find resource %1 Trying old method. minamount: %2'.[$ware, $minamounts.{$ware}]" chance="$debugchance"/>
          <!-- Find Resouces: Iterate over the gathering spaces -->
          <do_all exact="$gatheringspaces.count" counter="$i">
            <set_value name="$ware" exact="$miningbasket.{$w}" />
            <debug_text text="'now looking for %1 in %2 %3'.[$ware, $gatheringspaces.{$i}.class, $gatheringspaces.{$i}.knownname]" chance="$debugchance" />
            <!-- Find resources -->
            <do_if value="$deepspace">
              <do_if value="$gatheringspaces.{$i}.isclass.cluster">
                <find_sector name="$clustersectors" space="$gatheringspaces.{$i}" multiple="true"/>
              </do_if>
              <do_elseif value="$gatheringspaces.{$i}.isclass.sector">
                <set_value name="$clustersectors" exact="[$gatheringspaces.{$i}]"/>
              </do_elseif>
              <do_elseif value="$gatheringspaces.{$i}.sector">
                <set_value name="$clustersectors" exact="[$gatheringspaces.{$i}.sector]"/>
              </do_elseif>
              <do_else>
                <debug_text text="'ERROR: gatheringspaces.{$i}: %s %s is neither a cluster, nor a sector, nor something in a sector.'.[$gatheringspaces.{$i}.knownname, $gatheringspaces.{$i}]" filter="error"/>
              </do_else>
              <do_all exact="$clustersectors.count" counter="$j">
                <run_script name="'lib.find.point.indeepspace'" result="$deepspacepos">
                  <param name="sector" value="$clustersectors.{$j}"/>
                  <param name="allowyaxis" value="true"/>
                </run_script>
                <find_closest_resource ware="$ware" refobject="$clustersectors.{$j}" sector="$sector" position="$pos_sector" wares="$secwares">
                  <refposition value="$deepspacepos"/>
                </find_closest_resource>
                <do_if value="$sector">
                  <debug_text text="'find method 2. going to position: %s, %s, %s relative to sector %s %s\ndeepspace pos: %s, %s, %s'.[@$pos_sector.x, @$pos_sector.y, @$pos_sector.z, @$sector.knownname, $sector, $deepspacepos.x, $deepspacepos.y, $deepspacepos.z]" chance="$debugchance"/>
                  <break/>
                </do_if>
              </do_all>
              <remove_value name="$clustersectors"/>
            </do_if>
            <do_elseif value="$gatheringspaces.{$i}" exact="this.cluster">
              <find_closest_resource ware="$ware" refobject="this.assignedcontrolled" sector="$sector" position="$pos_sector" wares="$secwares" />
              <!--<find_closest_resource ware="$ware" refobject="if $homebase? then $homebase else this.assignedcontrolled" zone="$zone" wares="$secwares"/>-->
            </do_elseif>
            <do_else>
              <find_resource ware="$ware" refobject="$gatheringspaces.{$i}" sector="$sector" position="$pos_sector" wares="$secwares" />
            </do_else>
            <!-- Zone found -->
            <do_if value="$sector.exists">
              <debug_text text="'Resource %1 found in %2, %3. old reliable'.[$ware, $sector.knownname, $sector.cluster.knownname]" chance="$debugchance"/>
              <break />
            </do_if>
            <wait min="1ms" max="100ms" comment="Avoid performance peaks with find functions" />
          </do_all>
        </do_if>

        <!-- Zone found -->
        <do_if value="$sector.exists">
          <break />
        </do_if>
      </do_all>

      <!-- Check the result zone -->
      <do_if value="@$sector.exists">
        <debug_text text="player.age + ' there is %1 in sector %2'.[$ware, $sector.knownname]" chance="$debugchance" />
        <!-- Check the secondary wares vs the warebasket -->
        <do_all exact="$secwares.count" counter="$i" reverse="true">
          <do_if value="(not $miningbasket.indexof.{$secwares.{$i}}) or ($secwares.{$i} == $ware)">
            <remove_value name="$secwares.{$i}" />
          </do_if>
        </do_all>
        <!-- When Mining for commander, make a virtual reservation (to coordinate other miners) -->
        <do_if value="@$homebase.isoperational">
          <!-- min amount of ware. Default: max free space in cargo ship or amount homebase wants, whichever is the smaller value -->
          <set_value name="$minamount" exact="$neededamounts.{$miningbasket.indexof.{$ware}}" />
          <do_if value="$minamount gt this.assignedcontrolled.cargo.{$ware}.free">
            <set_value name="$minamount" exact="this.assignedcontrolled.cargo.{$ware}.free" />
          </do_if>
          <debug_text text="'reserving storage for %s %s'.[$minamount, $ware]" chance="$debugchance"/>
          <!-- virtual reservation -->
          <add_ware_reservation amount="$minamount" type="sell" reserver="this.assignedcontrolled" object="$homebase" duration="5h" virtual="true" ware="$ware" replace="true" />
          <!-- Clear values that are not needed anymore -->
          <remove_value name="$minamount" />
          <remove_value name="$neededamounts" />
        </do_if>
      </do_if>
      <do_else>
        <!-- Debug info: Enable to see the mining ships unable to gather resources on the defined spaces -->
        <do_if value="$debugchance">
          <debug_text text="'%1 Could not find any ware, waiting. Mining basket: %2'.[player.age, $miningbasket]" />
          <do_all exact="$gatheringspaces.count" counter="$i">
            <debug_text text="'Gathering space #%1: %2 %3 (%4)'.[$i, $gatheringspaces.{$i}.class, $gatheringspaces.{$i}.knownname, $gatheringspaces.{$i}]" />
          </do_all>
        </do_if>
        <!-- Nothing found, idle a while -->
        <run_script name="'move.idle'" >
          <param name="Min" value="50s" />
          <param name="Max" value="70s" />
        </run_script>
        <resume label="loop"/>
      </do_else>

      <debug_text text="'decided to mine %1 in %2, %3. secwares: %4'.[$ware, $sector.knownname, $sector.cluster.knownname, $secwares]" chance="$debugchance"/>

      <label name="movetocollect" />

      <!-- debug_eco - start -->
      <do_if value="this.assignedcontrolled.isclass.ship_m and $ware.tags.indexof.{tag.mineral}">
        <set_value name="$debug_eco" exact="0"/>
        <set_value name="$time_started" exact="player.age"/>
        <do_if value="this.$time_donemining?">
          <debug_to_file name="'eco_report.csv'" directory="'mining'" text="'%1;travel_from_location;%2;%3;%4;%5'.[player.age, this.assignedcontrolled.knownname, this.assignedcontrolled, this.assignedcontrolled.owner, player.age - this.$time_donemining]" output="$debugchance" chance="$debug_eco"/>
          <remove_value name="this.$time_donemining"/>
        </do_if>
      </do_if>
      <do_else>
        <set_value name="$debug_eco" exact="0"/>
        <set_value name="$time_started" exact="null"/>
      </do_else>

      <!-- move.generic was here. moved to MiningCollect order and call to MiningCollect made an immediate order because SectorChangeHandler was causing this script to reinitialize and potentially change destinations every time the ship changes sectors. -->

      <wait min="1s" max="3s" />

      <label name="collect"/>

      <do_if value="$resourcescout">
        <do_if value="this.sector != $sector or this.assignedcontrolled.distanceto.[$sector, $pos_sector] gt 10km">
          <debug_text text="'going long-distance to %1 relative to %2 %3.'.[$pos_sector, $sector.class, $sector]" chance="$debugchance"/>
          <run_script name="'move.generic'">
            <param name="destination" value="$sector"/>
            <param name="position" value="$pos_sector"/>
            <param name="endintargetzone" value="true"/>
            <param name="debugchance" value="$debugchance" />
          </run_script>
        </do_if>
        <run_script name="'order.move.recon'">
          <param name="targetspace" value="this.sector"/>
          <param name="targetclasses" value="[class.collectable, class.lockbox]"/>
          <param name="resourcescout" value="true"/>
          <param name="debugchance" value="$debugchance"/>
        </run_script>
        <resume label="loop"/>
      </do_if>

      <debug_text text="'%s %s %s moving to mine %s in %s %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $ware, $sector.class, $sector.knownname]" chance="$debugchance"/>
      <!-- collecting is done in an external script -->
      <create_order object="this.assignedcontrolled" id="'MiningCollect'" immediate="true">
        <param name="destination" value="[$sector, $pos_sector]"/>
        <param name="ware" value="$ware"/>
        <param name="secwares" value="if $effectiveskill then $secwares else []"/>
        <param name="internalorder" value="not $blacklist_overridebuy?"/>
        <param name="debugchance" value="$debugchance"/>

        <!-- debug_eco -->
        <param name="time_started" value="$time_started"/>
        <param name="debug_eco" value="$debug_eco"/>
      </create_order>
      <!-- very short wait to allow the newly-created order to start and prevent the following logic from needlessly being processed. -->
      <wait exact="1ms" sinceversion="4"/>

      <label name="sellwares" />

      <!-- Initializate the results -->
      <set_value name="$buyoffer" exact="null" />
      <!-- Mining for commander -->
      <do_if value="@$homebase.isoperational">
        
        <do_if value="this.assignedcontrolled.cargo.count">
          <!-- NB: we are always allowed to operate in our commander's sector regardless of blacklist. -->
          <set_value name="$blacklist_overridesell"/>
          <debug_text text="player.age + ' checking if we can sell our current cargo to our homebase'" chance="$debugchance" />
          <find_buy_offer result="$buyoffer" tradepartner="this.assignedcontrolled" buyer="$homebase" wares="this.assignedcontrolled.cargo.list">
            <offeramount min="1" tradepartner="this.assignedcontrolled"/>
          </find_buy_offer>
          <do_if value="true" chance="$debugchance">
            <find_buy_offer result="$test_buyoffers" tradepartner="this.assignedcontrolled" buyer="$homebase" wares="this.assignedcontrolled.cargo.list" multiple="true"/>
            <debug_text text="'%s %s %s, working for %s %s %s found %s buyoffers'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $homebase.idcode, $homebase.knownname, $homebase, $test_buyoffers.count]"/>
            <do_all exact="$test_buyoffers.count" counter="$i">
              <debug_text text="'ware: %s, desired amount: %s, offer amount: %s, amount: %s'.[$test_buyoffers.{$i}.ware, $test_buyoffers.{$i}.desiredamount, $test_buyoffers.{$i}.offeramount, $test_buyoffers.{$i}.amount]"/>
            </do_all>
            <remove_value name="$test_buyoffers"/>
          </do_if>
        </do_if>
      </do_if>
      <!-- Free miner -->
      <do_else>
        <!-- Find normal trade -->
        <run_script name="'trade.find.free'">
          <param name="warebasket" value="$warebasket" />
          <param name="range" value="$range" />
          <param name="sellspaces" value="$sellspaces.clone" comment="pass a copy so it can be modified on the find script"/>
          <param name="sellcurrentcargo" value="true"/>
          <param name="debugchance" value="$debugchance"/>
          <param name="debugchance2" value="$debugchance2"/>
          <save_retval name="buyoffer" variable="$buyoffer" />
        </run_script>
      </do_else>

      <do_if value="(this.assignedcontrolled.order.id == 'MiningRoutine') or (this.assignedcontrolled.order.id == 'MiningRoutine_Basic') or (this.assignedcontrolled.order.id == 'MiningRoutine_Advanced') or (this.assignedcontrolled.order.id == 'MiningRoutine_Expert')">
        <!-- NB: order will not be interrupted until after a blocking action is hit so, if a trade order is to be added and this order is to be interrupted, the trade order will be added first. -->
        <set_order_syncpoint_reached order="this.assignedcontrolled.order"/>
      </do_if>

      <!-- For the buyoffer (I sell) -->
      <do_if value="$buyoffer.available and ($buyoffer.amount or ($homebase? and $buyoffer.desiredamount))">
        <!-- I want to sell after gathering resources, I limit what I want to sell to what I gathered (selloffer-offer amount of this) -->
        <do_if value="not $homebase?">
          <!-- NB: buyoffer was found using offeramount which includes storage space reserved for other trades, so it could be clamped to 0. -->
          <clamp_trade_amount trade="$buyoffer" seller="this.assignedcontrolled" amount="$buyoffer.amount" buyer="$buyoffer.buyer" result="$amount"/>
        </do_if>
        <do_else>
          <clamp_trade_amount trade="$buyoffer" seller="this.assignedcontrolled" amount="$buyoffer.desiredamount" buyer="$buyoffer.buyer" result="$amount"/>
        </do_else>

        <debug_text text="'clamped amount: %s, buyoffer amount: %s, buyoffer desiredamount: %s, amount in hold: %s\ntrade price: %s, station cash: %s'.[$amount, $buyoffer.amount, $buyoffer.desiredamount, this.assignedcontrolled.cargo.{$buyoffer.ware}.count, ($amount * $buyoffer.unitprice).formatted.default, $buyoffer.buyer.money.formatted.default]" chance="$debugchance"/>
        <!-- Add sell trade perform (if available) => This object sells (create_trade_order adds the reservation automatically) -->
        <do_if value="$amount">
          <!-- cache values as $buyoffer may no longer be an offer after a trade order has been created from it, make sure we still know the relevant bits for removing any virtual reservations for that ware -->
          <set_value name="$resource_buyer" exact="$buyoffer.buyer"/>
          <set_value name="$resource_ware" exact="$buyoffer.ware"/>
          <debug_text text="'creating trade order to sell %1 %2 to %3 (%4, %5) for %6Cr'.[$amount, $resource_ware, $resource_buyer.knownname, $resource_buyer, $resource_buyer.idcode, ($amount * $buyoffer.unitprice).formatted.default]" chance="$debugchance" />
          <create_trade_order name="$tradeorder" object="this.object" tradeoffer="$buyoffer" amount="$amount" internal="not $blacklist_overridesell?" immediate="true"/>
          <!-- if we are now actually selling, remove any virtual reservation for this ware as we have a real one as part of the trade order -->
          <remove_ware_reservation object="$resource_buyer" reserver="this.assignedcontrolled" type="sell" virtual="true" ware="$resource_ware"/>
          <remove_value name="$resource_buyer" />
          <remove_value name="$resource_ware" />
        </do_if>
        <!-- if a trade order has been made, move.idle should be interrupted as soon as it hits a blocking action. -->
        <set_value name="$idle"/>
      </do_if>
      <!-- if we have wares that cannot be sold, just dump them -->
      <do_elseif value="this.assignedcontrolled.cargo.count">
        <do_if value="not this.isplayerowned">
          <do_all exact="$warebasket.count" counter="$i">
            <set_value name="$possibleware" exact="$warebasket.{$i}"/>
            <set_value name="$maxamount" exact="this.assignedcontrolled.cargo.{$possibleware}.max"/>
            <!-- Drop cargo -->
            <do_if value="$maxamount">
              <drop_cargo object="this.assignedcontrolled" ware="$possibleware" min="($maxamount * 0.1f)i" max="($maxamount * 0.2f)i" amounts="$droppedamounts" wares="$droppedwares"/>
              <do_all exact="$droppedwares.count" counter="$d" chance="$debugchance">
                <debug_text text="'%1 (%2) dropped %3 %4 because that ware is unsellable in %5'.[this.assignedcontrolled.knownname, this.assignedcontrolled, $droppedamounts.{$d}, $droppedwares.{$d}, this.cluster.knownname]"/>
              </do_all>
            </do_if>
          </do_all>
          <remove_value name="$possibleware" />
          <remove_value name="$maxamount" />
          <remove_value name="$droppedwares" />
        </do_if>
        <set_value name="$idle"/>
      </do_elseif>

      <do_if value="$idle?">
        <remove_value name="$idle"/>
        <!-- command action -->
        <set_command_action commandaction="commandaction.calculating" />

        <run_script name="'move.idle'" >
          <param name="Min" value="10s" />
          <param name="Max" value="40s" />
        </run_script>
      </do_if>

      <!-- No offer found, restart -->
      <do_if value="not @this.assignedcontrolled.isjobship or not this.assignedcontrolled.jobexpired">
        <resume label="loop" />
      </do_if>

      <label name="finish" />

      <do_if value="@$homebase.exists">
        <!-- clean up any virtual reservation we may have made if this script ends (as opposed to going into a subscript) -->
        <remove_ware_reservation object="$homebase" reserver="this.assignedcontrolled" type="sell" virtual="true"/>
      </do_if>

      <do_if value="$failreason?">
        <do_if value="@$sector and @$pos_sector">
          <debug_text text="'script ends with reason %1. Looking to gather %4 for job \'%5\'. This ship %2 m away from destination, destination %3'.[$failreason, this.assignedcontrolled.distanceto.[$sector, $pos_sector], $sector.knownname, @$warebasket, this.assignedcontrolled.job]"/>
        </do_if>
        <do_else>
          <debug_text text="'script ends with reason %s. Looking to gather %s for job \'%s\'.'.[$failreason, @$warebasket, this.assignedcontrolled.job]"/>
        </do_else>
      </do_if>
      <do_if value="$failreason2?">
        <debug_text text="$failreason2" />
      </do_if>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.assignedcontrolled.jobexpired">
        <debug_text text="'%1 doing job %2 has expired, die!'.[this.assignedcontrolled.knownname, this.assignedcontrolled.job]" chance="$debugchance" />
        <create_order object="this.assignedcontrolled" id="'MoveDie'" immediate="true">
          <param name="byhighway" value="not this.assignedcontrolled.isclass.[class.ship_l, class.ship_xl]" />
        </create_order>
      </do_if>

    </actions>
  </attention>
  <on_abort>
    <do_if value="@$homebase.exists and not $thisorder.exists">
      <debug_text text="'on_abort: removing ware reservation. current order: %s, this order exists: %s'.[@this.assignedcontrolled.order.id, $thisorder.exists]" chance="$debugchance"/>
      <!-- clean up any virtual reservation we may have made if this script is aborted -->
      <remove_ware_reservation object="$homebase" reserver="this.assignedcontrolled" type="sell" virtual="true"/>
    </do_if>
    <do_if value="$duration and @$tradeorder.exists and @$thisorder.exists">
      <!-- do not reduce duration to 0s since that would make the order infinite. -->
      <debug_text text="'on_abort: updating duration from %s to %s'.[$duration, $duration - [(player.age - $time_start), $duration - 1s].min]" chance="$debugchance"/>
      <edit_order_param order="$thisorder" param="'duration'" value="[$duration - (player.age - $time_start), 1s].max"/>
    </do_if>
  </on_abort>
</aiscript>