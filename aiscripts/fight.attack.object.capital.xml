<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="fight.attack.object.capital" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="15">
  <!--

  Fight attack object capital
  by Adrian
  
  Defense/Attack mode of a capital ship (made by defense npc), to attack enemys/targets in weapon range.
  This ship reacts to attacks and attempt to defend itself.
  
    - Defense Mode
      - Hold Fire Mode (Withdraw from Battle)
    - Attack Mode

  -->
  <params>
    <param name="debugchance" default="0"/>
  </params>
  <interrupts>
    <library>
      <actions name="CapitalLaunchFighters">
        <do_if value="$iscarrier">
          <do_if value="@$closestthreat.exists and (not $closestthreat.canbeattacked or not this.assignedcontrolled.mayattack.{$closestthreat})">
            <debug_text text="'closest threat %s %s %s is no longer a valid threat. cleaning up.'.[@$closestthreat.idcode, @$closestthreat.knownname, $closestthreat]" chance="$debugchance"/>
            <remove_value name="$closestthreat"/>
          </do_if>

          <do_if value="not this.ship.subordinates.count">
            <debug_text text="'%s %s %s has no more subordinates. skipping carrier calculations.'.[this.ship.idcode, this.ship.knownname, this.ship]" chance="$debugchance"/>
            <set_value name="$iscarrier" exact="false"/>
          </do_if>
          <do_elseif value="@this.ship.pilot.$escortgroup.count">
            <!-- scramble sends everything we have. so if we scramble, no point doing carrier attack. prohibit if we are actively attacking a target. -->
            <do_if value="@$closestthreat.canbeattacked and (this.assignedcontrolled.distanceto.{$closestthreat} lt $criticalrange) and not @$primarytarget.canbeattacked">
              <debug_text text="player.age + ': %s %s %s scrambling all fighters to attack %s %s %s.'.[this.ship.idcode, this.ship.knownname, this.ship, @$closestthreat.idcode, @$closestthreat.knownname, $closestthreat]" chance="$debugchance"/>
              <signal_objects object="this.ship" param="$closestthreat" param2="'carrier scramble'"/>
              <add_to_group groupname="$dronetargets" object="$closestthreat"/>
              <remove_value name="$closestthreat"/>
            </do_if>
            <do_else>
              <debug_text text="player.age + ': %s %s %s signalling carrier attack.'.[this.ship.idcode, this.ship.knownname, this.ship]" chance="$debugchance"/>
              <!-- target list here is different from the initial one we went over. this one includes the surface elements of the primary target, if one is designated. -->
              <do_if value="@this.ship.pilot.$escortgroup.count">
                <!-- try to deploy all direct subordinates against everything in our target list. -->
                <set_value name="$availableships" exact="this.ship.pilot.$escortgroup.list"/>
                <shuffle_list list="$availableships"/>

                <!-- reorder the targetlist. primarytarget, if defined, at the front of the list; subcomponents of primarytarget, if acquired, next, then everything else. -->
                <set_value name="$loctargetlist" exact="[]"/>
                <do_if value="@$primarytarget.canbeattacked">
                  <append_to_list name="$loctargetlist" exact="$primarytarget"/>
                  <do_all exact="$targets.count" counter="$interruptcounter">
                    <do_if value="$targets.{$interruptcounter}.hascontext.{$primarytarget} and ($targets.{$interruptcounter} != $primarytarget)">
                      <append_to_list name="$loctargetlist" exact="$targets.{$interruptcounter}"/>
                    </do_if>
                  </do_all>
                </do_if>
                <do_all exact="$targets.count" counter="$interruptcounter">
                  <do_if value="not $loctargetlist.indexof.{$targets.{$interruptcounter}}">
                    <append_to_list name="$loctargetlist" exact="$targets.{$interruptcounter}"/>
                  </do_if>
                </do_all>

                <debug_text text="'%s %s %s sending %s ships against %s targets.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $availableships.count, $loctargetlist.count]" chance="$debugchance"/>
                <!-- send fighters to attack acquired targets. -->
                <do_all exact="$loctargetlist.count" counter="$interruptcounter">
                  <set_value name="$loctarget" exact="$loctargetlist.{$interruptcounter}"/>
                  <do_if value="$availableships.count">
                    <do_if value="$loctarget.canbeattacked and (not @$engagedcarriertargets.indexof.{$loctarget} or ($loctarget == @$primarytarget) or (@$primarytarget.canbeattacked and @$loctarget.hascontext.{$primarytarget}))">
                      <do_if value="@$loctarget.iscapitalship or $loctarget.isrealclass.station">
                        <set_value name="$interceptorclass" exact="[class.ship_m, class.ship_l, class.ship_xl]"/>
                        <!-- NB: numsend is the number of ships to send against $loctarget. -->
                        <set_value name="$numsend" exact="1"/>
                      </do_if>
                      <!-- this should include surface elements. -->
                      <do_else>
                        <set_value name="$interceptorclass" exact="[class.ship_s, class.ship_m]"/>
                        <set_value name="$numsend" min="1" max="[this.ship.pilot.$escortgroup.count * 0.2, 1].max"/>
                      </do_else>
                      <do_if value="@$primarytarget.canbeattacked and (($loctarget == $primarytarget) or ($loctarget.hascontext.{$primarytarget}))">
                        <set_value name="$prenumsend" chance="$debugchance"/>
                        <set_value name="$numsend" exact="$numsend * [this.assignedcontrolled.combinedskill / 20, 1].max"/>
                        <debug_text text="'target %s %s %s is the primary target or is connected to the primary target. increasing force from %s to %s.'.[@$loctarget.idcode, @$loctarget.knownname, $loctarget, $prenumsend, $numsend]" chance="$debugchance"/>
                        <remove_value name="$prenumsend"/>
                      </do_if>
                      <debug_text text="'trying to send %s ships against %s %s %s.'.[[$availableships.count, $numsend].min, @$loctarget.idcode, @$loctarget.knownname, $loctarget]" chance="$debugchance"/>

                      <!-- we will still launch fighters against surface elements, just not against entire big targets. -->
                      <do_all exact="$availableships.count" counter="$interruptcounter2" reverse="true">
                        <set_value name="$locsub" exact="$availableships.{$interruptcounter2}"/>
                        <do_if value="$numsend gt 0">
                          <do_if value="not $locsub.subordinategroupdockoverride and $locsub.isclass.{$interceptorclass} and ($locsub.assignment != assignment.interception or ($loctarget.isclass.ship and not $loctarget.iscapitalship))">
                            <do_if value="$debugchance">
                              <set_value name="$debug_interceptor" exact="$locsub"/>
                              <debug_text text="player.age + ': %s %s %s sending %s %s %s after %s %s %s.'.[this.ship.idcode, this.ship.knownname, this.ship, $debug_interceptor.idcode, $debug_interceptor.knownname, $debug_interceptor, @$loctarget.idcode, $loctarget.knownname, $loctarget]"/>
                              <remove_value name="$debug_interceptor"/>
                            </do_if>
                            <signal_objects object="$locsub" param="$loctarget" param2="'carrier attack'"/>
                            <add_to_group groupname="$engagedcarriertargets" object="$loctarget"/>
                            <remove_value name="$locsub"/>
                            <set_value name="$numsend" exact="$numsend - 1"/>
                          </do_if>
                        </do_if>
                        <do_else>
                          <break/>
                        </do_else>
                      </do_all>
                      <remove_value name="$locsub"/>
                      <remove_value name="$numsend"/>
                      <remove_value name="$interceptorclass"/>
                    </do_if>
                    <do_else>
                      <debug_text text="'target %s %s %s is either no longer operational or already being engaged.'.[@$loctarget.idcode, @$loctarget.knownname, $loctarget]" chance="$debugchance"/>
                    </do_else>
                  </do_if>
                  <do_else>
                    <break/>
                  </do_else>
                </do_all>
                <remove_value name="$loctarget"/>
                <remove_value name="$loctargetlist"/>
                <remove_value name="$availableships"/>
              </do_if>
            </do_else>
          </do_elseif>
        </do_if>
      </actions>
      <actions name="CanLaunchDrones">
        <!-- caller must clean this up -->
        <set_value name="$canlaunchdrones" exact="not this.zone.isclass.highway and not this.assignedcontrolled.travel.active"/>
      </actions>
      <actions name="LaunchDrone_OreCollector">
        <!-- requires list $pickuptargets_solid -->
        <include_interrupt_actions ref="CanLaunchDrones"/>
        <do_if value="@$pickuptargets_solid.count and $canlaunchdrones and this.assignedcontrolled.hasarmedminingdrones">
          <do_all exact="$pickuptargets_solid.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_solid.{$interruptcounter}.isclass.asteroid and $pickuptargets_solid.{$interruptcounter}.canbepickedup and not $pickuptargets_solid.{$interruptcounter}.container and not $pickuptargets_solid.{$interruptcounter}.owner and this.assignedcontrolled.availableunits.{unitcategory.orecollector}.count">
              <set_owner object="$pickuptargets_solid.{$interruptcounter}" faction="this.assignedcontrolled.owner"/>
              <launch_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.orecollector" exact="1"/>
              <do_if value="$locdrone.isoperational">
                <add_to_group groupname="$group_launchedminingdrones" object="$locdrone"/>
                <start_script name="'mining.collect.drone'" object="$locdrone.pilot">
                  <param name="homebase" value="this.assignedcontrolled"/>
                  <param name="target" value="$pickuptargets_solid.{$interruptcounter}"/>
                  <param name="debugchance" value="$debugchance"/>
                </start_script>
              </do_if>
              <debug_text text="'%s %s %s sending %s %s %s to pick up %s %s. already picked up? %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$locdrone.idcode, @$locdrone.knownname, $locdrone, @$pickuptargets_solid.{$interruptcounter}.knownname, $pickuptargets_solid.{$interruptcounter}, $pickuptargets_solid.{$interruptcounter}.ship]" chance="$debugchance"/>
              <remove_value name="$locdrone"/>
            </do_if>
          </do_all>
        </do_if>
        <remove_value name="$pickuptargets_solid"/>
        <remove_value name="$canlaunchdrones"/>
      </actions>
      <actions name="LaunchDrone_GasCollector">
        <!-- requires list $locwares -->
        <include_interrupt_actions ref="CanLaunchDrones"/>
        <do_if value="@$locwares and $canlaunchdrones and this.assignedcontrolled.hasarmedminingdrones">
          <find_closest_resource wares="$locresultwares" zone="$loczone" position="$loczonepos" ware="$locwares" refobject="this.assignedcontrolled"/>
          <do_if value="$loczone == this.zone">
            <do_all exact="this.assignedcontrolled.availableunits.{unitcategory.gascollector}.count">
              <shuffle_list list="$locwares"/>
              <do_all exact="$locwares.count" counter="$interruptcounter">
                <do_if value="$locresultwares.indexof.{$locwares.{$interruptcounter}}">
                  <set_value name="$locware" exact="$locwares.{$interruptcounter}"/>
                  <break/>
                </do_if>
              </do_all>
              <do_if value="@$locware">
                <launch_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.gascollector" exact="1"/>
                <do_if value="$locdrone.isoperational">
                  <add_to_group groupname="$group_launchedminingdrones" object="$locdrone"/>
                  <start_script name="'mining.collect.drone'" object="$locdrone.pilot">
                    <param name="homebase" value="this.assignedcontrolled"/>
                    <param name="ware" value="$locware"/>
                  </start_script>
                  <debug_text text="'%s %s %s sending %s %s %s to harvest %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$locdrone.idcode, @$locdrone.knownname, $locdrone, $locware]" chance="$debugchance"/>
                </do_if>
              </do_if>
              <remove_value name="$locdrone"/>
              <remove_value name="$locware"/>
            </do_all>
          </do_if>
          <remove_value name="$locresultwares"/>
          <remove_value name="$loczonepos"/>
          <remove_value name="$loczone"/>
        </do_if>
        <remove_value name="$locwares"/>
        <remove_value name="$canlaunchdrones"/>
      </actions>
      <actions name="LaunchDrone_Transport">
        <!-- requires list $pickuptargets_container -->
        <include_interrupt_actions ref="CanLaunchDrones"/>
        <do_if value="@$pickuptargets_container.count and $canlaunchdrones and this.assignedcontrolled.hasarmedtransportdrones">
          <do_all exact="$pickuptargets_container.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_container.{$interruptcounter}.isclass.collectable and $pickuptargets_container.{$interruptcounter}.canbepickedup and not $pickuptargets_container.{$interruptcounter}.container and not $pickuptargets_container.{$interruptcounter}.owner and this.assignedcontrolled.availableunits.{unitcategory.transport}.count">
              <set_owner object="$pickuptargets_container.{$interruptcounter}" faction="this.assignedcontrolled.owner"/>
              <launch_masstraffic_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.transport" pickup="true" target="$pickuptargets_container.{$interruptcounter}"/>
              <do_if value="$locdrone.isoperational">
                <add_to_group groupname="$group_launchedtransportdrones" object="$locdrone"/>
                <start_script name="'move.collect.drone'" object="$locdrone.pilot">
                  <param name="homebase" value="this.assignedcontrolled"/>
                  <param name="target" value="$pickuptargets_container.{$interruptcounter}"/>
                  <param name="masstraffic" value="true"/>
                  <param name="stayactive" value="false" comment="deactivate animation after picked up"/>
                  <param name="debugchance" value="$debugchance"/>
                </start_script>
                <debug_text text="'%s %s %s sending %s %s %s to pick up %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$locdrone.idcode, @$locdrone.knownname, $locdrone, @$pickuptargets_container.{$interruptcounter}.knownname, $pickuptargets_container.{$interruptcounter}]" chance="$debugchance"/>
                <remove_value name="$locdrone"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <remove_value name="$pickuptargets_container"/>
        <remove_value name="$canlaunchdrones"/>
      </actions>
    </library>
    <handler comment="Self defense" consume="false">
      <conditions>
        <event_object_attacked object="this.ship" />
        <check_value value="event.param.isoperational"/>
        <check_value value="this.ship.mayattack.{event.param}" comment="check relation of ship (not defense NPC)" />
        <check_value value="not @$attackers.indexof.{event.param} or event.param.isclass.station" comment="Is not in the attackers group"/>
      </conditions>
      <actions>
        <set_value name="$evaltarget" exact="event.param"/>
        <include_interrupt_actions ref="SelectTargets"/>
        <do_if value="@$resulttargets.count">
          <add_to_group groupname="$targets" group="$resulttargets"/>
          <add_to_group groupname="$attackers" group="$resulttargets"/>
          <do_if value="($defencedronemode == dronemode.defend) or ($defencedronemode == dronemode.attackenemies)">
            <add_to_group groupname="$dronetargets" group="$resulttargets"/>
          </do_if>
        </do_if>
        <remove_value name="$resulttargets"/>
        <remove_value name="$evaltarget"/>
        <debug_text text="'Self defense. Attacker: %1. attackers %2'.[event.param, $attackers]" chance="$debugchance" />
        <abort_called_scripts resume="Attack" />
      </actions>
    </handler>
    <handler comment="Boarding pods launched nearby" consume="false">
      <conditions>
        <event_gravidar_has_scanned object="this.ship"/>
        <check_value value="this.sector"/>
        <count_gravidar_contacts result="$boardingpods_nearby" object="this.ship" excluded="$attackers" macro="param.boarding.boardingpodmacro" maybeattackedby="this.ship" functional="true" multiple="true">
          <match_context macro="this.sector.macro"/>
        </count_gravidar_contacts>
      </conditions>
      <actions>
        <debug_text text="'%s %s %s detected %s hostile boarding pods.'.[this.ship.idcode, this.ship.knownname, this.ship, $boardingpods_nearby.count]" chance="$debugchance"/>
        <do_all exact="$boardingpods_nearby.count" counter="$boardingpodcounter">
          <set_value name="$evaltarget" exact="$boardingpods_nearby.{$boardingpodcounter}"/>
          <include_interrupt_actions ref="SelectTargets"/>
          <do_if value="@$resulttargets.count">
            <add_to_group groupname="$targets" group="$resulttargets"/>
            <add_to_group groupname="$attackers" group="$resulttargets"/>
            <do_if value="($defencedronemode == dronemode.defend) or ($defencedronemode == dronemode.attackenemies)">
              <add_to_group groupname="$dronetargets" group="$resulttargets"/>
            </do_if>
          </do_if>
          <remove_value name="$resulttargets"/>
          <remove_value name="$evaltarget"/>
        </do_all>
        <debug_text text="'We are being boarded. %s boarding pods detected. Attackers %s'.[$boardingpods_nearby.count, $attackers]" chance="$debugchance"/>
        <abort_called_scripts resume="Attack" />
      </actions>
    </handler>
    <handler comment="Missile defense" consume="false">
      <conditions>
        <event_object_incoming_missile object="this.ship" />
        <check_value value="this.ship.mayattack.{event.param3}" comment="check relation of ship (not defense NPC)" />
        <check_value value="not @$incomingmissiles.indexof.{event.param2}" comment="Is not in the incomingmissiles group" />
        <check_value value="event.param2.isoperational"/>
      </conditions>
      <actions>
        <do_if value="event.param2.isoperational">
          <add_to_group groupname="$incomingmissiles" object="event.param2" comment="missile"/>
          <do_if value="$defencedronemode == dronemode.missiledefence">
            <add_to_group groupname="$dronetargets" group="$incomingmissiles"/>
          </do_if>

          <set_value name="$evaltarget" exact="event.param3" comment="missile source"/>
          <include_interrupt_actions ref="SelectTargets"/>
          <do_if value="@$resulttargets.count">
            <add_to_group groupname="$targets" group="$resulttargets"/>
            <add_to_group groupname="$attackers" group="$resulttargets"/>
            <do_if value="($defencedronemode == dronemode.defend) or ($defencedronemode == dronemode.attackenemies)">
              <add_to_group groupname="$dronetargets" group="$resulttargets"/>
            </do_if>
          </do_if>
          <remove_value name="$resulttargets"/>
          <remove_value name="$evaltarget"/>
          <debug_text text="'Missile defense. new incoming missile: %s %s. attacker %s %s %s %s'.[@event.param2.knownname, event.param2, @event.param3.class, @event.param3.idcode, @event.param3.knownname, event.param3]" chance="$debugchance" />
          <abort_called_scripts resume="Attack" />
        </do_if>
      </actions>
    </handler>
    <!-- NB: do not forget to clear $disabletargets by sending this signal with param2 null. otherwise, if this ship later meets a target in the disabletarget list, it will still only try to disable that target. -->
    <handler comment="attack signals. if param3.{4} is provided, these targets will be disabled. clears the group of targets to disable and repopulates with with the contents of param3.{4}. event.param3.{7} simply redirects the script to label Start without changing anything." consume="false">
      <conditions>
        <event_object_signalled object="this" param="'attack'" comment="param2 is target, param3 is [$secondarytargets, $allowothertargets, $checkrelation, $disabletargets, $disablehullpercentagethreshold, $behaviortargetclasses, forcereset(bool)]"/>
        <check_any>
          <check_value value="not event.param2 or @$primarytarget != event.param2 or @$secondarytargets != @event.param3.{1}"/>
          <check_value value="@event.param3.{7}"/>
        </check_any>
      </conditions>
      <actions>
        <debug_text text="'event %1, param %2, param2 %3, param3 %4'.[@event.name, @event.param, @event.param2, @event.param3]" chance="$debugchance" />

        <do_if value="not @event.param3.{7}">
          <!-- Attack -->
          <do_if value="event.param2">
            <set_value name="$locdisabletargets" exact="@event.param3.{4}"/>
            <do_if value="@$locdisabletargets.count">
              <set_value name="$disablehullpercentagethreshold" exact="if @event.param3.{5} then event.param3.{5} else 20"/>
              <clear_group group="$disabletargets"/>
              <add_to_group groupname="$disabletargets" list="event.param3.{4}"/>
              <set_value name="$behaviortargetclasses" exact="if @event.param3.{6} then event.param3.{6} else []"/>
            </do_if>

            <!-- main target -->
            <set_value name="$primarytarget" exact="event.param2" comment="if main target is null, means to stop fire" />
            <set_value name="$secondarytargets" exact="event.param3.{1}" />
            <!-- Additional parameters -->
            <set_value name="$allowothertargets" exact="event.param3.{2}" />
            <set_value name="$checkrelation" exact="event.param3.{3}" />
            <remove_value name="$locdisabletargets"/>
          </do_if>
          <!-- Stop Attack -->
          <do_else>
            <clear_group group="$disabletargets"/>

            <!-- Clear attack variables -->
            <clear_group group="$targets" />
            <clear_group group="$targets_capital"/>
            <clear_group group="$targets_fighters"/>
            <clear_group group="$attackers" />
            <clear_group group="$miningtargets"/>
            <remove_value name="$primarytarget" />
            <remove_value name="$secondarytargets" />
            <remove_value name="$allowothertargets" />
            <remove_value name="$closestthreat"/>
            <remove_value name="$behaviortargetclasses"/>
            <set_value name="$checkrelation" exact="$default_checkrelation"/>
          </do_else>

          <!-- Tell to subordinates to attack -->
          <set_value name="$subordinates" exact="this.ship.subordinates" />
          <do_all exact="$subordinates.count" counter="$interruptcounter" >
            <do_if value="$subordinates.{$interruptcounter}.defencenpc.exists">
              <debug_text text="'attack to %1. allowothertargets %2'.[$subordinates.{$interruptcounter}.defencenpc, @$allowothertargets]" chance="$debugchance" />
              <signal_objects object="$subordinates.{$interruptcounter}.defencenpc" param="event.param" param2="event.param2" param3="event.param3" />
            </do_if>
          </do_all>
          <remove_value name="$subordinates" />
        </do_if>

        <abort_called_scripts resume="Start" />
      </actions>
    </handler>
    <handler comment="weaponmode changed" consume="false">
      <conditions>
        <event_object_weaponmode_changed object="this.ship" />
      </conditions>
      <actions>
        <debug_text text="'event_object_weaponmode_changed %1, %2'.[@event.param, @event.param2]" chance="$debugchance" />
        <!-- Update turret modes again -->
        <set_value name="$weapons_all" exact="this.ship.turrets.operational.list" />
        <create_list name="$turretmodes" />
        <do_all exact="$weapons_all.count" counter="$interruptcounter">
          <do_if value="not $turretmodes.indexof.{$weapons_all.{$interruptcounter}.mode}">
            <append_to_list name="$turretmodes" exact="$weapons_all.{$interruptcounter}.mode"/>
          </do_if>
        </do_all>
        <remove_value name="$weapons_all" />

        <do_if value="$turretmodes.indexof.{weaponmode.autoassist} and player.target and this.assignedcontrolled.mayattack.{player.target}">
          <set_value name="$evaltarget" exact="player.target"/>
          <include_interrupt_actions ref="SelectTargets"/>
          <do_if value="@$resulttargets.count">
            <debug_text text="'setting autoassist turrets to fire upon %s targets.'.[$resulttargets.count]" chance="$debugchance"/>
            <!-- NB: this target list will be ignored. target acquisition for autoassist turrets is handled in code. -->
            <set_turret_targets object="this.assignedcontrolled" target="$resulttargets.list" weaponmode="weaponmode.autoassist"/>
          </do_if>
          <remove_value name="$resulttargets"/>
          <remove_value name="$evaltarget"/>
          <!-- important to skip label Wait since that does cease_fire -->
          <abort_called_scripts resume="FindEnemies"/>
        </do_if>
        <abort_called_scripts resume="Start" />
      </actions>
    </handler>
    <handler comment="defencedronemode changed or defence drones armed" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <event_object_defencedronemode_changed object="this.assignedcontrolled"/>
            <check_value value="event.param != $defencedronemode"/>
            <check_value value="this.assignedcontrolled.hasarmeddefencedrones"/>
            <debug_text text="'defence drone mode changed from %s to %s'.[$defencedronemode, event.param]" debugchance="$debugchance"/>
          </check_all>
          <event_object_defencedrones_armed object="this.assignedcontrolled"/>
        </check_any>
      </conditions>
      <actions>
        <set_value name="$newdefencedronemode" exact="$defencedronemode"/>
        <do_if value="event.name == 'event_object_defencedronemode_changed'">
          <set_value name="$newdefencedronemode" exact="event.param"/>
        </do_if>
        <set_value name="$newtargets" exact="[]"/>

        <!-- switching from dronemode.escort to something else. dock if no targets. -->
        <do_if value="($newdefencedronemode != dronemode.escort) and ($defencedronemode == dronemode.escort)">
          <debug_text text="'switching defencedronemode from %s. setting default orders for all defence drones to DockAndWait at me.'.[$defencedronemode]" chance="$debugchance"/>
          <!-- for all defence drones currently in the air, do not disengage current targets, but dock when able. -->
          <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
            <create_order id="'DockAndWait'" object="$group_launcheddefencedrones.{$interruptcounter}" default="true">
              <param name="destination" value="this.assignedcontrolled"/>
              <param name="dockfollowers" value="true"/>
              <param name="debugchance" value="$debugchance"/>
            </create_order>
          </do_all>
        </do_if>
        <!-- switching from something else to dronemode.escort. escort me if no targets. target acquisition done via escort script. -->
        <do_elseif value="$newdefencedronemode == dronemode.escort">
          <debug_text text="'switching defencedronemode to %s. setting default orders for all defence drones to Escort me.'.[$newdefencedronemode]" chance="$debugchance"/>
          <do_if value="(this.assignedcontrolled.attention ge attention.visible) and not this.zone.isclass.highway and not this.assignedcontrolled.travel.active">
            <do_all exact="this.assignedcontrolled.availableunits.{unitcategory.defence}.count">
              <launch_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.defence"/>
              <add_to_group groupname="$group_launcheddefencedrones" object="$locdrone"/>
              <remove_value name="$locdrone"/>
            </do_all>
          </do_if>
          <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
            <!-- for all defence drones currently in the air, do not disengage current targets, but fall in to formation when able. -->
            <create_order id="'Escort'" object="$group_launcheddefencedrones.{$interruptcounter}" default="true"/>
          </do_all>
        </do_elseif>

        <do_if value="($newdefencedronemode == dronemode.defend) or ($newdefencedronemode == dronemode.autoassist) or ($newdefencedronemode == dronemode.missiledefence)">
          <set_value name="$resettargets"/>
        </do_if>

        <do_if value="this.sector">
          <!-- immediate new target acquisition.
                target acquisition for dronemode.attackenemies done in FindEnemies.
                target acquisition for dronemode.defend is in response to event_object_attacked; but if turrets are already tracking attackers, attack those directly.
                target acquisition for dronemode.escort done in Escort. -->
          <do_if value="$newdefencedronemode == dronemode.autoassist">
            <do_if value="player.target and this.assignedcontrolled.mayattack.{player.target} and (this.assignedcontrolled.distanceto.{player.target} le this.assignedcontrolled.maxradarrange)">
              <set_value name="$evaltarget" exact="player.target"/>
              <include_interrupt_actions ref="SelectTargets"/>
              <do_all exact="@$resulttargets.count" counter="$interruptcounter">
                <append_to_list name="$newtargets" exact="$resulttargets.{$interruptcounter}"/>
              </do_all>
              <remove_value name="$resulttargets"/>
              <remove_value name="$evaltarget"/>
            </do_if>
          </do_if>
          <do_elseif value="$newdefencedronemode == dronemode.defend">
            <do_all exact="$attackers.count" counter="$interruptcounter">
              <append_to_list name="$newtargets" exact="$attackers.{$interruptcounter}"/>
            </do_all>
          </do_elseif>
          <do_elseif value="$newdefencedronemode == dronemode.missiledefence">
            <find_object name="$newtargets" space="this.sector" class="class.missile" multiple="true">
              <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.maxradarrange"/>
            </find_object>
            <do_all exact="$newtargets.count" counter="$interruptcounter" reverse="true">
              <do_if value="$newtargets.{$interruptcounter}.target != this.assignedcontrolled">
                <remove_value name="$newtargets.{$interruptcounter}"/>
              </do_if>
            </do_all>
          </do_elseif>
          <debug_text text="'switching defencedronemode to %s. setting drones to engage %s targets.'.[$newdefencedronemode, @$newtargets.count]" chance="$debugchance"/>
        </do_if>

        <do_if value="$resettargets?">
          <!-- for drone modes: attackenemies, autoassist, and missiledefence; stop engaging current targets and engage new targets. logic for target acquisition after this point should be handled separately. -->
          <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
            <cancel_all_orders object="$group_launcheddefencedrones.{$interruptcounter}"/>
          </do_all>
          <clear_group group="$dronetargets"/>

          <remove_value name="$resettargets"/>
        </do_if>

        <do_if value="@$newtargets.count">
          <debug_text text="'switching defencedronemode to %s. setting drones to engage %s targets.'.[$newdefencedronemode, $newtargets.count]" chance="$debugchance"/>
          <add_to_group groupname="$dronetargets" list="$newtargets"/>
        </do_if>

        <set_value name="$defencedronemode" exact="$newdefencedronemode"/>

        <remove_value name="$newtargets"/>
        <remove_value name="$newdefencedronemode"/>

        <do_if value="$dronetargets.count">
          <abort_called_scripts resume="Attack"/>
        </do_if>
        <do_elseif value="$defencedronemode == dronemode.attackenemies">
          <abort_called_scripts resume="FindEnemies"/>
        </do_elseif>
        <abort_called_scripts resume="Start"/>
      </actions>
    </handler>
    <handler comment="drones disarmed or player gets up" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <check_any>
              <event_object_defencedrones_disarmed object="this.assignedcontrolled"/>
              <event_object_signalled object="this" param="'recall_defencedrones'"/>
            </check_any>
            <check_value value="$group_launcheddefencedrones.count"/>
          </check_all>
          <check_all>
            <check_any>
              <event_control_entity_removed object="this.ship" entity="player.entity"/>
              <event_object_miningdrones_disarmed object="this.assignedcontrolled"/>
            </check_any>
            <check_value value="@$group_launchedminingdrones.count"/>
          </check_all>
          <check_all>
            <check_any>
              <event_control_entity_removed object="this.ship" entity="player.entity"/>
              <event_object_transportdrones_disarmed object="this.assignedcontrolled"/>
            </check_any>
            <check_value value="$group_launchedtransportdrones.count"/>
          </check_all>
        </check_any>
      </conditions>
      <actions>
        <do_if value="event.name == 'event_object_defencedrones_disarmed' or (event.name == 'event_object_signalled' and event.param == 'recall_defencedrones')">
          <do_if value="(event.name == 'event_object_defencedrones_disarmed') or ($defencedronemode != dronemode.escort)">
            <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
              <create_order id="'DockAndWait'" object="$group_launcheddefencedrones.{$interruptcounter}" default="true">
                <param name="destination" value="this.assignedcontrolled"/>
                <param name="dockfollowers" value="true"/>
                <param name="debugchance" value="$debugchance"/>
              </create_order>
              <cancel_all_orders object="$group_launcheddefencedrones.{$interruptcounter}"/>
              <debug_text text="'%s %s %s recalling defence drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launcheddefencedrones.{$interruptcounter}.idcode, @$group_launcheddefencedrones.{$interruptcounter}.knownname, $group_launcheddefencedrones.{$interruptcounter}]" chance="$debugchance"/>
            </do_all>
          </do_if>
          <do_else>
            <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
              <cancel_all_orders object="$group_launcheddefencedrones.{$interruptcounter}"/>
              <debug_text text="'%s %s %s recalling %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launcheddefencedrones.{$interruptcounter}.idcode, @$group_launcheddefencedrones.{$interruptcounter}.knownname, $group_launcheddefencedrones.{$interruptcounter}]" chance="$debugchance"/>
            </do_all>
          </do_else>
        </do_if>
        <do_elseif value="event.name == 'event_control_entity_removed'">
          <do_all exact="@$group_launchedminingdrones.count" counter="$interruptcounter">
            <start_script name="'order.dock'" object="$group_launchedminingdrones.{$interruptcounter}.pilot">
              <param name="destination" value="this.assignedcontrolled"/>
              <param name="abouttofinish" value="true"/>
              <param name="debugchance" value="$debugchance"/>
            </start_script>
            <debug_text text="'%s %s %s recalling mining drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launchedminingdrones.{$interruptcounter}.idcode, @$group_launchedminingdrones.{$interruptcounter}.knownname, $group_launchedminingdrones.{$interruptcounter}]" chance="$debugchance"/>
          </do_all>
          <do_all exact="$group_launchedtransportdrones.count" counter="$interruptcounter">
            <start_script name="'move.collect.drone'" object="$group_launchedtransportdrones.{$interruptcounter}.pilot">
              <param name="homebase" value="this.assignedcontrolled"/>
              <param name="masstraffic" value="true"/>
              <param name="launching" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </start_script>
            <debug_text text="'%s %s %s recalling transport drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launchedtransportdrones.{$interruptcounter}.idcode, @$group_launchedtransportdrones.{$interruptcounter}.knownname, $group_launchedtransportdrones.{$interruptcounter}]" chance="$debugchance"/>
          </do_all>
        </do_elseif>
        <do_elseif value="event.name == 'event_object_miningdrones_disarmed'">
          <do_all exact="@$group_launchedminingdrones.count" counter="$interruptcounter">
            <start_script name="'order.dock'" object="$group_launchedminingdrones.{$interruptcounter}.pilot">
              <param name="destination" value="this.assignedcontrolled"/>
              <param name="abouttofinish" value="true"/>
              <param name="debugchance" value="$debugchance"/>
            </start_script>
            <debug_text text="'%s %s %s recalling mining drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launchedminingdrones.{$interruptcounter}.idcode, @$group_launchedminingdrones.{$interruptcounter}.knownname, $group_launchedminingdrones.{$interruptcounter}]" chance="$debugchance"/>
          </do_all>
        </do_elseif>
        <do_elseif value="event.name == 'event_object_transportdrones_disarmed'">
          <do_all exact="$group_launchedtransportdrones.count" counter="$interruptcounter">
            <start_script name="'move.collect.drone'" object="$group_launchedtransportdrones.{$interruptcounter}.pilot">
              <param name="homebase" value="this.assignedcontrolled"/>
              <param name="masstraffic" value="true"/>
              <param name="launching" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </start_script>
            <debug_text text="'%s %s %s recalling transport drone %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$group_launchedtransportdrones.{$interruptcounter}.idcode, @$group_launchedtransportdrones.{$interruptcounter}.knownname, $group_launchedtransportdrones.{$interruptcounter}]" chance="$debugchance"/>
          </do_all>
        </do_elseif>
      </actions>
    </handler>
    <handler comment="condition preventing drone launch has changed and defencedronemode == dronemode.escort" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <event_object_changed_attention object="this.assignedcontrolled"/>
            <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)"/>
          </check_all>
          <check_all>
            <event_object_changed_zone object="this.assignedcontrolled"/>
            <check_value value="not event.param.isclass.highway and event.param2.isclass.highway"/>
          </check_all>
          <event_object_destroyed group="$group_launcheddefencedrones" method="killmethod.collected"/>
        </check_any>
        <check_value value="this.assignedcontrolled.hasarmeddefencedrones"/>
        <check_value value="$defencedronemode == dronemode.escort"/>
        <check_value value="this.assignedcontrolled.availableunits.{unitcategory.defence}.count"/>
        <check_value value="not this.zone.isclass.highway and not this.assignedcontrolled.travel.active and (this.assignedcontrolled.attention ge attention.visible)"/>
      </conditions>
      <actions>
        <debug_text text="'launching defence drones to escort. event: %s'.[event.name]" chance="$debugchance"/>
        <do_all exact="this.assignedcontrolled.availableunits.{unitcategory.defence}.count">
          <launch_drone name="$locdrone" object="this.assignedcontrolled" category="unitcategory.defence"/>
          <add_to_group groupname="$group_launcheddefencedrones" object="$locdrone"/>
          <remove_value name="$locdrone"/>
        </do_all>
        <do_all exact="$group_launcheddefencedrones.count" counter="$interruptcounter">
          <!-- for all defence drones currently in the air, do not disengage current targets, but fall in to formation when able. -->
          <create_order id="'Escort'" object="$group_launcheddefencedrones.{$interruptcounter}" default="true"/>
        </do_all>
      </actions>
    </handler>
    <handler comment="dronemode collectable found" consume="false">
      <conditions>
        <event_gravidar_has_scanned object="this.assignedcontrolled"/>
        <check_value value="this.assignedcontrolled == player.occupiedship"/>
        <check_value value="not this.zone.isclass.highway and not this.assignedcontrolled.travel.active"/>
        <check_value value="this.sector"/>
        <count_gravidar_contacts result="$collectables" object="this.assignedcontrolled" class="[class.collectable, class.asteroid]" canbepickedup="true" multiple="true">
          <match_context macro="this.sector.macro"/>
        </count_gravidar_contacts>
      </conditions>
      <actions>
        <set_value name="$pickuptargets_solid" exact="[]"/>
        <set_value name="$pickuptargets_container" exact="[]"/>

        <do_all exact="$collectables.count" counter="$interruptcounter">
          <do_if value="$collectables.{$interruptcounter}.canbepickedup">
            <do_if value="$collectables.{$interruptcounter}.isclass.asteroid">
              <do_if value="$miningdronemode? and this.assignedcontrolled.hasarmedminingdrones and this.assignedcontrolled.cargo.free.solid and (this.assignedcontrolled.primarypurpose == purpose.mine)">
                <do_if value="$miningdronemode == dronemode.collectanymineable">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_if>
                <do_elseif value="($miningdronemode == dronemode.collectice) and $collectables.{$interruptcounter}.wares.{ware.ice}.count">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_elseif>
                <do_elseif value="($miningdronemode == dronemode.collectore) and $collectables.{$interruptcounter}.wares.{ware.ore}.count">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_elseif>
                <do_elseif value="($miningdronemode == dronemode.collectore) and $collectables.{$interruptcounter}.wares.{ware.silicon}.count">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_elseif>
                <do_elseif value="($miningdronemode == dronemode.collectnividium) and $collectables.{$interruptcounter}.wares.{ware.nividium}.count">
                  <append_to_list name="$pickuptargets_solid" exact="$collectables.{$interruptcounter}"/>
                </do_elseif>
              </do_if>
            </do_if>
            <do_elseif value="this.assignedcontrolled.hasarmedtransportdrones">
              <do_if value="$transportdronemode == dronemode.collectanycrate">
                <append_to_list name="$pickuptargets_container" exact="$collectables.{$interruptcounter}"/>
              </do_if>
              <do_elseif value="($transportdronemode == dronemode.collectillegal)">
                <do_all exact="$collectables.{$interruptcounter}.wares.count" counter="$interruptcounter2">
                  <do_if value="this.zone.policefaction and $collectables.{$interruptcounter}.wares.{$interruptcounter2}.illegal">
                    <append_to_list name="$pickuptargets_container" exact="$collectables.{$interruptcounter}"/>
                    <break/>
                  </do_if>
                </do_all>
              </do_elseif>
              <do_elseif value="($transportdronemode == dronemode.collectlegal)">
                <do_all exact="$collectables.{$interruptcounter}.wares.count" counter="$interruptcounter2">
                  <do_if value="not this.zone.policefaction or not $collectables.{$interruptcounter}.wares.{$interruptcounter2}.illegal">
                    <append_to_list name="$pickuptargets_container" exact="$collectables.{$interruptcounter}"/>
                    <break/>
                  </do_if>
                </do_all>
              </do_elseif>
            </do_elseif>
          </do_if>
        </do_all>

        <do_if value="$pickuptargets_solid.count">
          <include_interrupt_actions ref="LaunchDrone_OreCollector"/>
        </do_if>

        <do_if value="$pickuptargets_container.count">
          <include_interrupt_actions ref="LaunchDrone_Transport"/>
        </do_if>

        <remove_value name="$pickuptargets_container"/>
        <remove_value name="$pickuptargets_solid"/>
        <remove_value name="$collectables"/>
      </actions>
    </handler>
    <handler comment="miningdronemode gas resource found" consume="false">
      <conditions>
        <event_object_changed_zone object="this.assignedcontrolled"/>
        <check_value value="$miningdronemode?"/>
        <check_value value="this.assignedcontrolled == player.occupiedship"/>
        <check_value value="this.assignedcontrolled.primarypurpose == purpose.mine"/>
        <check_value value="this.assignedcontrolled.hasarmedminingdrones"/>
        <check_value value="this.assignedcontrolled.availableunits.{unitcategory.gascollector}.count and this.assignedcontrolled.cargo.free.liquid"/>
        <check_value value="not this.zone.isclass.highway and not this.assignedcontrolled.travel.active"/>
      </conditions>
      <actions>
        <set_value name="$locware" exact="[ware.helium, ware.hydrogen, ware.methane]"/>
        <do_if value="$miningdronemode == dronemode.collecthelium">
          <set_value name="$locware" exact="ware.helium"/>
        </do_if>
        <do_elseif value="$miningdronemode == dronemode.collecthydrogen">
          <set_value name="$locware" exact="ware.hydrogen"/>
        </do_elseif>
        <do_elseif value="$miningdronemode == dronemode.collectmethane">
          <set_value name="$locware" exact="ware.methane"/>
        </do_elseif>

        <set_value name="$locwares" exact="[$locware]"/>
        <include_interrupt_actions ref="LaunchDrone_GasCollector"/>

        <remove_value name="$locware"/>
      </actions>
    </handler>
    <handler comment="miningdronemode gas mining drones dock" consume="false">
      <conditions>
        <event_object_docked group="$group_launchedminingdrones" dock="this.assignedcontrolled"/>
        <check_value value="this.sector"/>
      </conditions>
      <actions>
        <do_if value="$miningdronemode == dronemode.collectanymineable">
          <find_closest_resource wares="$locfoundwares" zone="$loczone" position="$loczonepos" ware="[ware.helium, ware.hydrogen, ware.methane]" refobject="this.assignedcontrolled"/>
          <do_if value="$locfoundwares.count">
            <shuffle_list list="$locfoundwares"/>
            <set_value name="$locware" exact="$locfoundwares.random"/>
          </do_if>

          <remove_value name="$locfoundwares"/>
          <remove_value name="$loczonepos"/>
          <remove_value name="$loczone"/>
        </do_if>
        <do_elseif value="$miningdronemode == dronemode.collecthelium">
          <set_value name="$locware" exact="ware.helium"/>
        </do_elseif>
        <do_elseif value="$miningdronemode == dronemode.collecthydrogen">
          <set_value name="$locware" exact="ware.hydrogen"/>
        </do_elseif>
        <do_elseif value="$miningdronemode == dronemode.collectmethane">
          <set_value name="$locware" exact="ware.methane"/>
        </do_elseif>

        <do_if value="@$locware">
          <create_position name="$locsectorpos" space="this.sector" object="this.assignedcontrolled"/>
          <get_resource_gatherrate name="$locgatherrate" refobject="this.assignedcontrolled" sector="this.sector" ware="$locware">
            <position value="$locsectorpos"/>
          </get_resource_gatherrate>
          <!-- "15" below to stay consistent with mining.collect.ship.liquid -->
          <set_value name="$locgathered" min="$locgatherrate * 15 * 0.75" max="$locgatherrate * 15 * 1.25"/>
          <deplete_yield sector="this.sector" container="this.assignedcontrolled" ware="$locware" amount="$locgathered">
            <position value="$locsectorpos"/>
          </deplete_yield>
          <debug_text text="'%s %s %s gathered %s %s from %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, $locgathered, $locware, this.sector.knownname, this.sector]" chance="$debugchance"/>

          <remove_value name="$locsectorpos"/>
          <remove_value name="$locgathered"/>
          <remove_value name="$locgatherrate"/>
        </do_if>

        <remove_value name="$locware"/>
      </actions>
    </handler>
    <handler comment="miningdronemode changed or mining drones armed or player takes over or conditions changed such that drones can now launch" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <event_object_miningdronemode_changed object="this.assignedcontrolled"/>
            <check_value value="event.param != @$miningdronemode"/>
          </check_all>
          <event_object_miningdrones_armed object="this.assignedcontrolled"/>
          <event_control_entity_added object="this.assignedcontrolled" entity="player.entity"/>
          <check_all>
            <event_object_changed_attention object="this.assignedcontrolled"/>
            <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)"/>
          </check_all>
          <check_all>
            <event_object_changed_zone object="this.assignedcontrolled"/>
            <check_value value="not event.param.isclass.highway and event.param2.isclass.highway"/>
          </check_all>
        </check_any>
        <debug_text text="'mining drone handler. event: %s. miningdronemode: %s. check 1: %s, check 2: %s, check 3: %s'.[event.name, $miningdronemode?, this.assignedcontrolled.primarypurpose == purpose.mine, this.assignedcontrolled == player.occupiedship, this.assignedcontrolled.hasarmedminingdrones]" debugchance="$debugchance"/>
        <check_value value="$miningdronemode?"/>
        <check_value value="this.assignedcontrolled.primarypurpose == purpose.mine"/>
        <check_value value="this.assignedcontrolled == player.occupiedship"/>
        <check_value value="this.assignedcontrolled.hasarmedminingdrones"/>
      </conditions>
      <actions>
        <set_value name="$newminingdronemode" exact="this.assignedcontrolled.miningdronemode"/>
        <do_if value="event.name == 'event_object_miningdronemode_changed'">
          <set_value name="$newminingdronemode" exact="event.param"/>
        </do_if>

        <set_value name="$locwares" exact="[]"/>
        <do_if value="$newminingdronemode == dronemode.collectanymineable">
          <do_if value="this.assignedcontrolled.units.{unitcategory.orecollector}.count and this.assignedcontrolled.cargo.capacity.solid">
            <append_to_list name="$locwares" exact="ware.ore"/>
            <append_to_list name="$locwares" exact="ware.silicon"/>
            <append_to_list name="$locwares" exact="ware.ice"/>
            <append_to_list name="$locwares" exact="ware.nividium"/>
            <set_value name="$locfindsolid"/>
          </do_if>

          <do_if value="this.assignedcontrolled.units.{unitcategory.gascollector}.count and this.assignedcontrolled.cargo.capacity.liquid">
            <append_to_list name="$locwares" exact="ware.helium"/>
            <append_to_list name="$locwares" exact="ware.hydrogen"/>
            <append_to_list name="$locwares" exact="ware.methane"/>
            <set_value name="$locfindliquid"/>
          </do_if>
        </do_if>
        <do_elseif value="$newminingdronemode == dronemode.collectice">
          <append_to_list name="$locwares" exact="ware.ice"/>
          <set_value name="$locfindsolid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collectore">
          <append_to_list name="$locwares" exact="ware.ore"/>
          <set_value name="$locfindsolid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collectsilicon">
          <append_to_list name="$locwares" exact="ware.silicon"/>
          <set_value name="$locfindsolid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collectnividium">
          <append_to_list name="$locwares" exact="ware.nividium"/>
          <set_value name="$locfindsolid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collecthelium">
          <append_to_list name="$locwares" exact="ware.helium"/>
          <set_value name="$locfindliquid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collecthydrogen">
          <append_to_list name="$locwares" exact="ware.hydrogen"/>
          <set_value name="$locfindliquid"/>
        </do_elseif>
        <do_elseif value="$newminingdronemode == dronemode.collectmethane">
          <append_to_list name="$locwares" exact="ware.methane"/>
          <set_value name="$locfindliquid"/>
        </do_elseif>

        <do_if value="$locwares.count">
          <do_if value="$locfindsolid?">
            <find_object name="$pickuptargets_solid" space="this.zone" class="class.asteroid" multiple="true">
              <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.maxradarrange"/>
            </find_object>
            <include_interrupt_actions ref="LaunchDrone_OreCollector"/>
            <remove_value name="$locfindsolid"/>
          </do_if>

          <do_if value="$locfindliquid?">
            <include_interrupt_actions ref="LaunchDrone_GasCollector"/>
            <remove_value name="$locfindliquid"/>
          </do_if>
        </do_if>

        <set_value name="$miningdronemode" exact="$newminingdronemode"/>

        <remove_value name="$locwares"/>
        <remove_value name="$newtargets"/>
        <remove_value name="$newminingdronemode"/>
      </actions>
    </handler>
    <handler comment="transportdronemode changed or transport drones armed or player takes over or conditions changed such that drones can now launch" consume="false">
      <conditions>
        <check_any>
          <check_all>
            <event_object_transportdronemode_changed object="this.assignedcontrolled"/>
            <check_value value="event.param != $transportdronemode"/>
          </check_all>
          <event_object_transportdrones_armed object="this.assignedcontrolled"/>
          <event_control_entity_added object="this.assignedcontrolled" entity="player.entity"/>
          <check_all>
            <event_object_changed_attention object="this.assignedcontrolled"/>
            <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)"/>
          </check_all>
          <check_all>
            <event_object_changed_zone object="this.assignedcontrolled"/>
            <check_value value="not event.param.isclass.highway and event.param2.isclass.highway"/>
          </check_all>
        </check_any>
        <check_value value="this.assignedcontrolled == player.occupiedship"/>
        <check_value value="this.assignedcontrolled.hasarmedtransportdrones"/>
      </conditions>
      <actions>
        <set_value name="$newtransportdronemode" exact="this.assignedcontrolled.transportdronemode"/>
        <do_if value="event.name == 'event_object_transportdronemode_changed'">
          <set_value name="$newtransportdronemode" exact="event.param"/>
        </do_if>

        <find_object name="$pickuptargets_container" space="this.zone" class="class.collectable" multiple="true">
          <match_distance object="this.assignedcontrolled" max="this.assignedcontrolled.maxradarrange"/>
        </find_object>
        <do_if value="$newtransportdronemode == dronemode.collectanycrate">
          <do_all exact="$pickuptargets_container.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_container.{$interruptcounter}.isclass.asteroid">
              <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
            </do_if>
          </do_all>
        </do_if>
        <do_elseif value="$newtransportdronemode == dronemode.collectillegal">
          <do_all exact="$pickuptargets_container.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_container.{$interruptcounter}.isclass.asteroid">
              <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
            </do_if>
            <do_else>
              <do_all exact="$pickuptargets_container.{$interruptcounter}.wares.count" counter="$interruptcounter2">
                <do_if value="not this.zone.policefaction or not $pickuptargets_container.{$interruptcounter}.wares.{$interruptcounter2}.illegal">
                  <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
                  <break/>
                </do_if>
              </do_all>
            </do_else>
          </do_all>
        </do_elseif>
        <do_elseif value="$newtransportdronemode == dronemode.collectlegal">
          <do_all exact="$pickuptargets_container.count" counter="$interruptcounter" reverse="true">
            <do_if value="$pickuptargets_container.{$interruptcounter}.isclass.asteroid">
              <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
            </do_if>
            <do_else>
              <do_all exact="$pickuptargets_container.{$interruptcounter}.wares.count" counter="$interruptcounter2">
                <do_if value="this.zone.policefaction and $pickuptargets_container.{$interruptcounter}.wares.{$interruptcounter2}.illegal">
                  <remove_value name="$pickuptargets_container.{$interruptcounter}"/>
                  <break/>
                </do_if>
              </do_all>
            </do_else>
          </do_all>
        </do_elseif>

        <do_if value="$pickuptargets_container.count">
          <include_interrupt_actions ref="LaunchDrone_Transport"/>
        </do_if>

        <set_value name="$transportdronemode" exact="$newtransportdronemode"/>

        <remove_value name="$newtransportdronemode"/>
      </actions>
    </handler>
    <handler comment="stop firing if a target changes ownership to less than hostile" consume="false">
      <conditions>
        <check_any>
          <event_object_changed_owner group="$targets"/>
          <event_object_changed_owner group="$attackers"/>
          <event_object_changed_owner group="$disabletargets"/>
          <event_object_changed_owner object="this.assignedcontrolled"/>
          <event_object_changed_owner group="$pilotgroup"/>
        </check_any>
        <check_value value="not this.assignedcontrolled.mayattack.{event.object}"/>
      </conditions>
      <actions>
        <do_if value="(event.object == this.assignedcontrolled) or (event.object == @this.assignedcontrolled.pilot)">
          <debug_text text="'my ownership changed resulting in a relation change. ceasing fire.'" chance="$debugchance"/>
          <clear_group group="$targets"/>
          <clear_group group="$targets_capital"/>
          <clear_group group="$targets_fighters"/>
          <clear_group group="$attackers"/>
          <clear_group group="$disabletargets"/>
        </do_if>
        <do_else>
          <debug_text text="'target ownership changed. ceasing fire against %s %s %s.'.[@event.object.idcode, @event.object.knownname, event.object]" chance="$debugchance"/>
          <do_if value="$targets.indexof.{event.object}">
            <remove_from_group group="$targets" object="event.object"/>
          </do_if>
          <do_if value="$attackers.indexof.{event.object}">
            <remove_from_group group="$attackers" object="event.object"/>
          </do_if>
          <do_if value="$disabletargets.indexof.{event.object}">
            <remove_from_group group="$disabletargets" object="event.object"/>
          </do_if>
        </do_else>
        <abort_called_scripts resume="Start" />
      </actions>
    </handler>
    <handler comment="start firing if the player takes over a ship that has turrets set to weaponmode.mining" consume="false">
      <conditions>
        <event_control_entity_added object="this.ship"/>
      </conditions>
      <actions>
        <clear_group group="$pilotgroup"/>
        <add_to_group groupname="$pilotgroup" object="event.param"/>
        <do_if value="(event.param == player.entity) and @$turretmodes.indexof.{weaponmode.mining}">
          <debug_text text="'%s %s %s %s is now flown by the player and has turrets set to mining.'.[this.ship.class, this.ship.idcode, this.ship.knownname, this.ship]" chance="$debugchance"/>
          <abort_called_scripts resume="Start" />
        </do_if>
      </actions>
    </handler>
    <handler comment="stop firing if the player is no longer flying the ship and we were mining. AI mining turret handling in the mining scripts." consume="false">
      <conditions>
        <event_control_entity_removed object="this.ship"/>
      </conditions>
      <actions>
        <clear_group group="$pilotgroup"/>
        <do_if value="(event.param == player.entity) and @$turretmodes.indexof.{weaponmode.mining}">
          <debug_text text="'%s %s %s %s is no longer flown by the player and has turrets set to mining.'.[this.ship.class, this.ship.idcode, this.ship.knownname, this.ship]" chance="$debugchance"/>
          <clear_group group="$miningtargets"/>
          <cease_fire object="this.ship" weaponmode="weaponmode.mining"/>
        </do_if>
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command_action commandaction="commandaction.standingby" />
    <!-- Initial variables -->
    <set_value name="$lastdronelaunch" exact="player.age - 10min" />
    <set_value name="$nextammocheck" exact="player.age + 100s" />
    <set_value name="$FiringRange" exact="this.ship.maxcombatrange.all"/>
    <set_value name="$operationalrange" exact="this.ship.maxradarrange * 0.8"/>
    <set_value name="$criticalrange" exact="this.ship.maxradarrange * 0.4"/>
    <set_value name="$checkrelation" exact="true"/>
    <set_value name="$default_checkrelation" exact="$checkrelation"/>
    <set_value name="$scantime" exact="500ms + ((1.0 - (@this.assignedcontrolled.combinedskill / 100.0)) * 60s)"/>

    <create_group groupname="$attackers"/>
    <create_group groupname="$targets"/>
    <create_group groupname="$targets_capital"/>
    <create_group groupname="$targets_fighters"/>
    <create_group groupname="$incomingmissiles"/>
    <create_group groupname="$disabletargets"/>
    <create_group groupname="$miningtargets"/>
    <create_group groupname="$dronetargets"/>

    <set_value name="$defencedronemode" exact="this.assignedcontrolled.defencedronemode"/>
    <create_group groupname="$group_launcheddefencedrones"/>
    <set_value name="$transportdronemode" exact="this.assignedcontrolled.transportdronemode"/>
    <create_group groupname="$group_launchedtransportdrones"/>
    <set_value name="$miningdronemode" exact="this.assignedcontrolled.miningdronemode"/>
    <create_group groupname="$group_launchedminingdrones"/>

    <create_group groupname="$pilotgroup"/>
    <do_if value="this.assignedcontrolled.pilot.exists">
      <add_to_group groupname="$pilotgroup" object="this.assignedcontrolled.pilot"/>
    </do_if>

    <!-- HACK - would be a lot better to make a way to detect launch tubes directly. 
        NB: If launchtubes ever become destructible, move this to a place where checkoperational can be re-evaluated.
          If launchtubes later become inconsistent with .external and not .isdockingallowed, another way to identify them will have to be devised. -->
    <set_value name="$num_launchtubes" exact="0"/>
    <set_value name="$num_dronedocks" exact="0"/>
    <find_dockingbay name="$docks" object="this.ship" checkoperational="1" multiple="1">
      <match_dock size="tag.dock_s" storage="false"/>
    </find_dockingbay>
    <do_all exact="$docks.count" counter="$i">
      <do_if value="$docks.{$i}.external and not $docks.{$i}.isdockingallowed">
        <set_value name="$num_launchtubes" exact="$num_launchtubes + 1"/>
      </do_if>
      <set_value name="$num_dronedocks" exact="$num_dronedocks + 1"/>
    </do_all>
    <remove_value name="$docks"/>
    <set_value name="$iscarrier" exact="this.assignedcontrolled.type == shiptype.carrier"/>
  </init>
  <patch sinceversion="1">
    <set_value name="$numpatchcleared" exact="0"/>
    <do_all exact="$attackers.count" counter="$p" reverse="true">
      <do_if value="not $attackers.{$p}.isclass.defensible and not $attackers.{$p}.container">
        <remove_from_group group="$attackers" object="$attackers.{$p}"/>
        <set_value name="$numpatchcleared" exact="$numpatchcleared + 1"/>
      </do_if>
    </do_all>
    <do_all exact="$targets.count" counter="$p" reverse="true">
      <do_if value="not $targets.{$p}.isclass.defensible and not $targets.{$p}.container">
        <remove_from_group group="$targets" object="$targets.{$p}"/>
        <set_value name="$numpatchcleared" exact="$numpatchcleared + 1"/>
      </do_if>
    </do_all>
    <do_all exact="$disabletargets.count" counter="$p" reverse="true">
      <do_if value="not $disabletargets.{$p}.isclass.defensible and not $disabletargets.{$p}.container">
        <remove_from_group group="$disabletargets" object="$disabletargets.{$p}"/>
        <set_value name="$numpatchcleared" exact="$numpatchcleared + 1"/>
      </do_if>
    </do_all>
    <do_all exact="@$dronetargets.count" counter="$p" reverse="true">
      <do_if value="not $dronetargets.{$p}.isclass.defensible and not $dronetargets.{$p}.container">
        <remove_from_group group="$dronetargets" object="$dronetargets.{$p}"/>
        <set_value name="$numpatchcleared" exact="$numpatchcleared + 1"/>
      </do_if>
    </do_all>
    <debug_text text="'PATCH: cleared target lists of %s invalid targets.'.[$numpatchcleared]" chance="$numpatchcleared * 100" filter="savegame"/>
    <remove_value name="$numpatchcleared"/>
  </patch>
  <patch sinceversion="2">
    <set_value name="$num_dronedocks" exact="0"/>
    <find_dockingbay name="$docks" object="this.ship" checkoperational="1" multiple="1">
      <match_dock size="tag.dock_s" storage="false"/>
    </find_dockingbay>
    <set_value name="$num_dronedocks" exact="$docks.count"/>
    <remove_value name="$docks"/>
  </patch>
  <patch sinceversion="7">
    <set_value name="$locship" exact="this.assignedcontrolled"/>
    <set_value name="$locnum_deployedunits" exact="0"/>
    <set_value name="$locnum_unavailableunits" exact="$locship.units.{unitcategory.defence}.count - $locship.availableunits.{unitcategory.defence}.count"/>
    <do_all exact="$locship.subordinates.count" counter="$_i">
      <do_if value="$locship.subordinates.{$_i}.isunit">
        <set_value name="$locnum_deployedunits" exact="$locnum_deployedunits + 1"/>
      </do_if>
    </do_all>

    <set_value name="$locnum_destroyedunits" exact="0"/>
    <set_value name="$locnum_reassignedunits" exact="0"/>
    <find_object_component name="$localldockedunits" object="$locship" unit="true" recursive="true" multiple="true"/>
    <do_all exact="$localldockedunits.count" counter="$_i" reverse="true">
      <set_value name="$loccommander" exact="$localldockedunits.{$_i}.commander"/>
      <do_if value="@$loccommander.isunit and (not $loccommander.commander or ($loccommander.commander == $locship))">
        <set_value name="$loccommander" exact="null"/>
      </do_if>
      <do_if value="not $loccommander.isoperational">
        <do_if value="$locnum_unavailableunits gt $locnum_deployedunits">
          <set_object_commander object="$localldockedunits.{$_i}" commander="$locship"/>
          <set_value name="$locnum_deployedunits" exact="$locnum_deployedunits + 1"/>
          <set_value name="$locnum_reassignedunits" exact="$locnum_reassignedunits + 1"/>
        </do_if>
        <do_else>
          <destroy_object object="$localldockedunits.{$_i}" explosion="false"/>
          <set_value name="$locnum_destroyedunits" exact="$locnum_destroyedunits + 1"/>
        </do_else>
      </do_if>
    </do_all>
    <debug_text text="'PATCH: found %s docked units that have no commander.\n reassigned: %s\n destroyed: %s\n deployed: %s'.[$locnum_reassignedunits + $locnum_destroyedunits, $locnum_reassignedunits, $locnum_destroyedunits, $locnum_deployedunits]" filter="savegame" chance="(($locnum_destroyedunits gt 0) or ($locnum_reassignedunits gt 0)) * 100"/>

    <set_value name="$locnum_collected" exact="0"/>
    <set_value name="$locnum_destroyedunits" exact="0"/>
    <do_all exact="$locship.subordinates.count" counter="$_i" reverse="true">
      <set_value name="$locsub" exact="$locship.subordinates.{$_i}"/>
      <do_if value="$locsub.isunit and $locsub.dock and (@$locsub.order.id == 'DockAndWait' or @$locsub.order.id == 'DockAt')">
        <do_if value="$locship.units.{unitcategory.defence}.count gt $locship.availableunits.{unitcategory.defence}.count">
          <collect_unit object="$locship" unit="$locsub"/>
          <set_value name="$locnum_collected" exact="$locnum_collected + 1"/>
        </do_if>
        <do_else>
          <destroy_object object="$locsub" explosion="false"/>
          <set_value name="$locnum_destroyedunits" exact="$locnum_destroyedunits + 1"/>
        </do_else>
      </do_if>
    </do_all>
    <debug_text text="'PATCH: %s %s %s found %s defence drones that were docked but uncollected.\n collected: %s\n destroyed: %s'.[@$locship.idcode, @$locship.knownname, $locship, $locnum_collected + $locnum_destroyedunits, $locnum_collected, $locnum_destroyedunits]" filter="savegame" chance="($locnum_collected gt 0) * 100"/>

    <remove_value name="$locnum_unavailableunits"/>
    <remove_value name="$locnum_deployedunits"/>
    <remove_value name="$locnum_reassignedunits"/>
    <remove_value name="$locnum_destroyedunits"/>
    <remove_value name="$loccommander"/>
    <remove_value name="$localldockedunits"/>
    <remove_value name="$locnum_collected"/>
    <remove_value name="$locsub"/>
    <remove_value name="$locship"/>
  </patch>
  <patch sinceversion="8" early="true">
    <!-- orig v3 -->
    <do_if value="not $dronetargets?">
      <create_group groupname="$dronetargets"/>
    </do_if>

    <set_value name="$defencedronemode" exact="this.assignedcontrolled.defencedronemode"/>
    <do_if value="not $group_launcheddefencedrones?">
      <create_group groupname="$group_launcheddefencedrones"/>
    </do_if>
    <debug_text text="'PATCH: initializing defencedronemode: %s'.[$defencedronemode]" filter="savegame" chance="0"/>

    <!-- orig v4 -->
    <set_value name="$transportdronemode" exact="this.assignedcontrolled.transportdronemode"/>
    <do_if value="not $group_launchedtransportdrones?">
      <create_group groupname="$group_launchedtransportdrones"/>
    </do_if>
    <set_value name="$miningdronemode" exact="this.assignedcontrolled.miningdronemode"/>
    <do_if value="not $group_launchedminingdrones?">
      <create_group groupname="$group_launchedminingdrones"/>
    </do_if>
    <debug_text text="'PATCH: initializing transportdronemode: %s and miningdronemode: %s'.[$transportdronemode, $miningdronemode]" filter="savegame" chance="0"/>

    <!-- orig v6 -->
    <do_if value="not $pilotgroup?">
      <create_group groupname="$pilotgroup"/>
    </do_if>
    <do_if value="this.assignedcontrolled.pilot.exists">
      <add_to_group groupname="$pilotgroup" object="this.assignedcontrolled.pilot"/>
      <debug_text text="'PATCH: recognizing pilot: %s %s'.[@this.assignedcontrolled.pilot.knownname, this.assignedcontrolled.pilot]" filter="savegame" chance="0"/>
    </do_if>
  </patch>
  <patch sinceversion="8">
    <!-- orig v3 -->
    <do_all exact="this.assignedcontrolled.allsubordinates.count" counter="$p">
      <set_value name="$locsub" exact="this.assignedcontrolled.allsubordinates.{$p}"/>
      <do_if value="$locsub.isoperational and $locsub.isunit and this.assignedcontrolled.hasunitdrone.{$locsub}">
        <do_if value="$locsub.unitcategory == unitcategory.defence">
          <add_to_group groupname="$group_launcheddefencedrones" object="$locsub"/>
          <do_if value="@$locsub.defaultorder.id != 'DockAndWait'">
            <create_order id="'DockAndWait'" object="$locsub" default="true">
              <param name="destination" value="this.assignedcontrolled"/>
              <param name="dockfollowers" value="true"/>
              <param name="debugchance" value="$debugchance"/>
            </create_order>
          </do_if>
          <debug_text text="'PATCH: adding %s %s %s to $group_launcheddefencedrones'.[@$locsub.idcode, $locsub.knownname, $locsub]" filter="savegame" chance="0"/>
        </do_if>
      </do_if>
    </do_all>
    <remove_value name="$locsub"/>

    <!-- orig v5 -->
    <do_if value="this.assignedcontrolled.dock">
      <stop_shooting object="this.assignedcontrolled"/>
      <stop_shooting object="this.assignedcontrolled" missiles="true"/>
    </do_if>
  </patch>
  <patch sinceversion="9">
    <do_if value="not $incomingmissiles?">
      <create_group groupname="$incomingmissiles"/>
    </do_if>
    <create_group groupname="$targets_capital"/>
    <create_group groupname="$targets_fighters"/>
    <do_all exact="$targets.count" counter="$_i">
      <do_if value="@$targets.{$_i}.iscapitalship or @$targets.{$_i}.isrealclass.station">
        <add_to_group groupname="$targets_capital" object="$targets.{$_i}"/>
      </do_if>
      <do_elseif value="$targets.{$_i}.isclass.ship">
        <add_to_group groupname="$targets_fighters" object="$targets.{$_i}"/>
      </do_elseif>
      <do_else>
        <do_if value="$targets.{$_i}.container">
          <do_if value="@$targets.{$_i}.container.iscapitalship or @$targets.{$_i}.container.isrealclass.station">
            <add_to_group groupname="$targets_capital" object="$targets.{$_i}"/>
          </do_if>
          <do_elseif value="$targets.{$_i}.container.isclass.ship">
            <add_to_group groupname="$targets_fighters" object="$targets.{$_i}"/>
          </do_elseif>
        </do_if>
      </do_else>
    </do_all>
  </patch>
  <patch sinceversion="10">
    <do_if value="this.attention lt attention.visible">
      <set_value name="$table_ammousage" exact="table[]"/>
      <do_for_each name="$turret" in="this.assignedcontrolled.turrets.operational.list">
        <set_value name="$locmacro" exact="$turret.ammo.macro"/>
        <do_if value="$locmacro and this.assignedcontrolled.ammostorage.{$locmacro}.count">
          <set_value name="$table_ammousage.{$locmacro}" exact="1" operation="add"/>
        </do_if>
      </do_for_each>
      <do_for_each name="$weapon" in="this.assignedcontrolled.weapons.operational.list">
        <set_value name="$locmacro" exact="$weapon.ammo.macro"/>
        <do_if value="$locmacro and this.assignedcontrolled.ammostorage.{$locmacro}.count">
          <set_value name="$table_ammousage.{$locmacro}" exact="1" operation="add"/>
        </do_if>
      </do_for_each>
      <remove_value name="$locmacro"/>
    </do_if>
  </patch>
  <patch sinceversion="11">
    <do_for_each name="$loctarget" in="$targets_fighters">
      <do_if value="not $targets.indexof.{$loctarget}">
        <remove_from_group group="$targets_fighters" object="$loctarget"/>
      </do_if>
    </do_for_each>
    <do_for_each name="$loctarget" in="$targets_capital">
      <do_if value="not $targets.indexof.{$loctarget}">
        <remove_from_group group="$targets_capital" object="$loctarget"/>
      </do_if>
    </do_for_each>
    <do_if value="@$preferredtarget.exists and not $targets.indexof.{$preferredtarget}">
      <set_value name="$preferredtarget" exact="null"/>
    </do_if>
    <do_if value="not $targets.count">
      <cease_fire object="this.assignedcontrolled"/>
    </do_if>
  </patch>
  <patch sinceversion="12">
    <do_if value="(this.assignedcontrolled.attention lt attention.visible) and @$targets.count">
      <create_group groupname="$targets_low"/>
      <do_for_each name="$loctarget" in="$targets">
        <do_if value="$loctarget.isoperational and not @$loctarget.dock">
          <!-- target not being defensible and having a container means it's a surface element. we cannot get the attackstrength of something that is not a defensible. so target the container. -->
          <do_while value="not $loctarget.isclass.defensible and $loctarget.container">
            <set_value name="$loctarget" exact="$loctarget.container"/>
          </do_while>
          <do_if value="not $targets_low.indexof.{$loctarget}">
            <add_to_group groupname="$targets_low" object="$loctarget"/>
          </do_if>
        </do_if>
      </do_for_each>
      <!-- reset the script -->
      <signal_objects object="this" param="'attack'" param2="null" param3="[null, null, null, null, null, null, true]"/>
    </do_if>
  </patch>
  <patch sinceversion="14">
    <do_if value="@$behaviortargetclasses.count and not $targets.count">
      <remove_value name="$behaviortargetclasses"/>
    </do_if>
  </patch>
  <patch sinceversion="15">
    <do_for_each name="$loctarget" in="$targets">
      <do_if value="$loctarget.isoperational and this.trueowner.relationto.{$loctarget.trueowner} gt -0.01">
        <debug_text text="'PATCH: %s %s %s was attacking %s %s %s which belongs to a non-hostile faction. resetting relations and re-evaluating.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$loctarget.idcode, @$loctarget.knownname, $loctarget]" filter="savegame"/>
        <reset_relation_boost object="this.assignedcontrolled" otherobject="$loctarget"/>
        <set_value name="$locreset"/>
      </do_if>
    </do_for_each>
    <do_if value="$locreset?">
      <signal_objects object="this" param="'attack'"/>
    </do_if>
    <remove_value name="$locreset"/>
  </patch>
  <attention min="visible">
    <actions>
      <label name="Start"/>

      <set_value name="$weapons_all" exact="this.ship.turrets.operational.list"/>
      <create_list name="$turretmodes"/>
      <do_all exact="$weapons_all.count" counter="$i">
        <do_if value="not $turretmodes.indexof.{$weapons_all.{$i}.mode}">
          <append_to_list name="$turretmodes" exact="$weapons_all.{$i}.mode"/>
        </do_if>
      </do_all>
      <remove_value name="$weapons_all"/>

      <!-- Go to find enemies if:
            - configuration attack is on
            - There are targets 
            - attackers
      -->
      <!--If not, go to wait -->
      <do_if value="$turretmodes.indexof.{weaponmode.attackenemies} or ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones) or ($turretmodes.indexof.{weaponmode.mining} and this.ship == player.occupiedship) or @$primarytarget.canbeattacked or @$targets.count">
        <resume label="FindEnemies" />
      </do_if>

      <!-- DEFENSIVE MODE -->
      <label name="Wait" />

      <!-- Stop fire -->
      <cease_fire object="this.ship" />
      <remove_value name="$behaviortargetclasses"/>
      <!-- Recall drones -->
      <signal_objects object="this" param="'recall_defencedrones'"/>
      <run_script name="'lib.recall.subordinates'" chance="0">
        <param name="timeout" value="-1s" comment="recall drones" />
      </run_script>
      <!-- wait for attack signal or updated configurations-->
      <!-- NB: if we are here, we are not firing. -->
      <wait>
        <interrupt>
          <conditions>
            <event_player_changed_target/>
            <check_value value="this.assignedcontrolled.isplayerowned"/>
            <check_any>
              <check_all>
                <check_value value="$turretmodes.indexof.{weaponmode.autoassist} or ($defencedronemode == dronemode.autoassist and this.assignedcontrolled.hasarmeddefencedrones)"/>
                <check_value value="(not event.param and not player.target) or @this.assignedcontrolled.mayattack.{event.param}"/>
                <set_value name="$locattack"/>
              </check_all>
              <check_all>
                <check_value value="$transportdronemode == dronemode.collectselected"/>
                <check_value value="event.param.exists and event.param.isclass.collectable and event.param.canbepickedup"/>
                <check_value value="this.assignedcontrolled.distanceto.{event.param} le this.assignedcontrolled.maxradarrange"/>
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <do_if value="event.param">
              <do_if value="$locattack?">
                <do_if value="this.assignedcontrolled.mayattack.{event.param}">
                  <set_value name="$evaltarget" exact="event.param"/>
                  <include_interrupt_actions ref="SelectTargets"/>
                  <do_if value="@$resulttargets.count">
                    <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                      <add_to_group groupname="$targets" group="$resulttargets"/>
                      <debug_text text="'setting autoassist turrets to fire upon %s targets.'.[$resulttargets.count]" chance="$debugchance"/>
                      <!-- NB: this target list will be ignored. target acquisition for autoassist turrets is handled in code. -->
                      <set_turret_targets object="this.assignedcontrolled" target="$resulttargets.list" weaponmode="weaponmode.autoassist"/>
                    </do_if>

                    <do_if value="$defencedronemode == dronemode.autoassist">
                      <clear_group group="$dronetargets"/>
                      <add_to_group groupname="$dronetargets" group="$resulttargets"/>

                      <!-- if any defence drones are already out, simply redirect them to the new target. otherwise, proceed to FindEnemies and launch new ones. -->
                      <do_if value="$group_launcheddefencedrones.count and this.assignedcontrolled.hasarmeddefencedrones">
                        <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                          <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
                          <create_order object="$group_launcheddefencedrones.{$i}" id="'Attack'">
                            <param name="primarytarget" value="$evaltarget"/>
                            <param name="secondarytargets" value="$resulttargets"/>
                            <param name="internalorder" value="true"/>
                            <param name="debugchance" value="$debugchance"/>
                          </create_order>
                        </do_all>
                        <set_value name="$donotlaunchdefencedrones"/>
                      </do_if>
                    </do_if>
                  </do_if>
                  <remove_value name="$resulttargets"/>
                  <remove_value name="$evaltarget"/>
                </do_if>
              </do_if>
              <do_else>
                <debug_text text="'player selected collectable %s %s and transport drones are set to collect selected crates.'.[@event.param.knownname, event.param]" chance="$debugchance"/>
                <set_value name="$pickuptargets_container" exact="[event.param]"/>
                <include_interrupt_actions ref="LaunchDrone_Transport"/>

                <resume label="Start"/>
              </do_else>
            </do_if>
            <do_elseif value="not player.target">
              <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                <debug_text text="'target deselected. autoassist turrets ceasing fire.'" chance="$debugchance"/>
                <!-- player just deselected a target and there is no target. autoassist turrets simply cease firing and we resume waiting. -->
                <cease_fire object="this.assignedcontrolled" weaponmode="weaponmode.autoassist"/>
              </do_if>

              <do_if value="$defencedronemode == dronemode.autoassist">
                <clear_group group="$dronetargets"/>
                <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                  <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
                </do_all>
              </do_if>

              <!-- transport drones keep collecting what they were sent out to collect. -->

              <remove_value name="$locattack"/>
              <resume label="Start"/>
            </do_elseif>
            <remove_value name="$locattack"/>
          </actions>
        </interrupt>
      </wait>

      <!-- Find and update Enemies and Targets -->
      <label name="FindEnemies" />

      <!-- time before which ship re-evaluates targets. refresh here in case pilot or crew gets better.
        scantime * dps also used to define how much damage we could do before we potentially change targets.
        Scan time
          100   0.5s
          80    12.5s
          60    24.5s
          40    36.5s
          20    48.5s
          10    54.5s -->
      <set_value name="$scantime" exact="500ms + ((1.0 - (@this.assignedcontrolled.combinedskill / 100.0)) * 60s)"/>

      <!-- Find (more) targets if no target or other targets are allowed -->
      <do_if value="@$allowothertargets or $turretmodes.indexof.{weaponmode.attackenemies} or ($defencedronemode == dronemode.attackenemies and this.assignedcontrolled.hasarmeddefencedrones)">
        <!-- Clear targets to update them -->
        <clear_group group="$targets"/>
        <clear_group group="$targets_capital"/>
        <clear_group group="$targets_fighters"/>
        <do_if value="$defencedronemode == dronemode.attackenemies">
          <clear_group group="$dronetargets"/>
        </do_if>

        <do_if value="this.sector">
          <find_gravidar_contact groupname="$evaltargets" object="this.ship" class="class.defensible" checkoperational="false" docked="false" maybeattackedby="this.ship" multiple="true">
            <match_context macro="this.sector.macro"/>
            <match_distance object="this.ship" max="this.ship.maxradarrange"/>
            <match class="[class.collectable, class.buildstorage]" negate="true"/>
            <match state="componentstate.wreck" negate="true"/>
          </find_gravidar_contact>
        </do_if>
        <do_all exact="@$evaltargets.count" counter="$i">
          <set_value name="$evaltarget" exact="$evaltargets.{$i}"/>
          <include_interrupt_actions ref="SelectTargets"/>
          <do_if value="@$resulttargets.count">
            <do_if value="@$allowothertargets or $turretmodes.indexof.{weaponmode.attackenemies}">
              <add_to_group groupname="$targets" group="$resulttargets"/>
              <!-- If $allowothertargets, then add these targets to defend mode turrets too -->
              <do_if value="@$allowothertargets">
                <add_to_group groupname="$attackers" group="$resulttargets"/>
              </do_if>
            </do_if>

            <do_if value="$defencedronemode == dronemode.attackenemies">
              <add_to_group groupname="$dronetargets" group="$resulttargets"/>
              <debug_text text="'target acquired. %s %s %s launching drones against %s %s %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $evaltarget.idcode, $evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
            </do_if>
          </do_if>
          <remove_value name="$resulttargets"/>
          <remove_value name="$evaltarget"/>
        </do_all>
        <remove_value name="$evaltargets"/>
      </do_if>
      <!-- If no new enemies, update the current ones -->
      <do_else>
        <do_all exact="@$targets.count" counter="$i" reverse="true">
          <!-- Relation, dock and distance check -->
          <do_if value="not this.ship.mayattack.{$targets.{$i}} or @$targets.{$i}.dock or this.ship.distanceto.{$targets.{$i}} gt this.ship.maxradarrange">
            <remove_from_group group="$targets" object="$targets.{$i}" />
          </do_if>
        </do_all>
        <do_all exact="@$dronetargets.count" counter="$i" reverse="true">
          <!-- Relation, dock and distance check -->
          <do_if value="not this.ship.mayattack.{$dronetargets.{$i}} or @$dronetargets.{$i}.dock or this.ship.distanceto.{$dronetargets.{$i}} gt this.ship.maxradarrange">
            <remove_from_group group="$dronetargets" object="$dronetargets.{$i}" />
          </do_if>
        </do_all>
      </do_else>

      <do_if value="$turretmodes.indexof.{weaponmode.mining} and this.ship == player.occupiedship" comment="turret handling for AI pilots is handled in the respective mining scripts">
        <!-- Clear targets to update them -->
        <clear_group group="$miningtargets"/>
        <find_asteroid_in_cluster name="$miningtargetlist" cluster="this.cluster" refobject="this.ship" canpickup="false" multiple="true" maxdistance="[this.ship.maxcombatrange.{weaponmode.mining}.turrets, 3km].max" viewangle="360deg"/>
        <add_to_group groupname="$miningtargets" list="$miningtargetlist"/>
        <remove_value name="$miningtargetlist"/>
        <debug_text text="'found %s asteroids within %sm. max range of turrets with mining weapon mode: %sm'.[$miningtargets.count, [this.ship.maxcombatrange.{weaponmode.mining}.turrets, 3km].max, this.ship.maxcombatrange.{weaponmode.mining}.turrets]" chance="$debugchance"/>
      </do_if>

      <!-- Update Main target (parameter in signal) -->
      <do_if value="@$primarytarget.canbeattacked">
        <!-- Relation, dock and distance check -->
        <do_if value="($checkrelation and not this.ship.mayattack.{$primarytarget}) or @$primarytarget.dock" >
          <remove_from_group group="$targets" object="$primarytarget" />
          <remove_from_group group="$attackers" object="$primarytarget" />
        </do_if>
        <do_else>
          <set_value name="$evaltarget" exact="$primarytarget"/>
          <include_interrupt_actions ref="SelectTargets"/>
          <do_if value="@$resulttargets.count">
            <add_to_group groupname="$targets" group="$resulttargets"/>
            <add_to_group groupname="$attackers" group="$resulttargets"/>
          </do_if>
          <remove_value name="$resulttargets"/>
          <remove_value name="$evaltarget"/>
        </do_else>
      </do_if>
      <!-- Update Secondary Targets -->
      <do_if value="@$secondarytargets.count">
        <do_all exact="$secondarytargets.count" counter="$i" reverse="true">
          <do_if value="$secondarytargets.{$i}.canbeattacked">
            <!-- Relation, dock and distance check -->
            <do_if value="($checkrelation and not this.ship.mayattack.{$secondarytargets.{$i}}) or @$secondarytargets.{$i}.dock">
              <remove_from_group group="$targets" object="$secondarytargets.{$i}" />
              <remove_from_group group="$attackers" object="$secondarytargets.{$i}" />
            </do_if>
            <do_else>
              <set_value name="$evaltarget" exact="$secondarytargets.{$i}"/>
              <include_interrupt_actions ref="SelectTargets"/>
              <do_if value="@$resulttargets.count">
                <add_to_group groupname="$targets" group="$resulttargets"/>
                <add_to_group groupname="$attackers" group="$resulttargets"/>
              </do_if>
              <remove_value name="$resulttargets"/>
              <remove_value name="$evaltarget"/>
            </do_else>
          </do_if>
        </do_all>
      </do_if>

      <label name="Attack" />

      <!-- ok, we have found targets, let's do something about them -->
      <do_if value="this.ship.pilot and (@$targets.count or $dronetargets.count or ($miningtargets.count and this.ship == player.occupiedship))">
        <!-- Simulate the attack -->
        <set_command_action commandaction="commandaction.attacking" />
        <!-- alert level -->
        <set_alert_level object="this.ship" level="red" />

        <do_all counter="$i" exact="@$targets.count">
          <debug_text text="'i: %1 target for %2 is: %3 of class: %4 size: %5'.[$i, this.ship.knownname, $targets.{$i}.knownname, $targets.{$i}.class, $targets.{$i}.size]" chance="$debugchance"/>
          <!-- carrier operational range has to be less than radar range because we lose track of targets once they leave radar range. we want to keep track of them. -->
          <do_if value="(this.ship.distanceto.{$targets.{$i}} gt $operationalrange) and $dronetargets.indexof.{$targets.{$i}}">
            <remove_from_group group="$dronetargets" object="$targets.{$i}"/>
          </do_if>

          <do_if value="$iscarrier and @$targets.{$i}.iscapitalship">
            <do_if value="not @$closestthreat.canbeattacked or (this.ship.distanceto.{$targets.{$i}} lt this.ship.distanceto.{$closestthreat})">
              <set_value name="$closestthreat" exact="$targets.{$i}"/>
            </do_if>
          </do_if>
        </do_all>

        <set_value name="$preferredtarget" exact="@$primarytarget"/>
        <!-- For the primary target -->
        <do_if value="@$primarytarget.canbeattacked">
          <!-- add primary target's subcomponents  -->
          <set_value name="$evaltarget" exact="if $primarytarget.container.exists then $primarytarget.container else $primarytarget"/>
          <!-- SelectTargets is in lib.target.selection.singletarget which results in a group of targets, composition of which depends on what evaltarget is. -->
          <include_interrupt_actions ref="SelectTargets"/>
          <do_if value="@$resulttargets.count">
            <add_to_group groupname="$targets" group="$resulttargets"/>
            <do_if value="$dronetargets.indexof.{$evaltarget}">
              <add_to_group groupname="$dronetargets" group="$targets"/>
            </do_if>
          </do_if>
          <do_if value="$evaltarget.isrealclass.station and ($evaltarget == $preferredtarget)">
            <set_value name="$preferredtarget" exact="$targets.random"/>
          </do_if>
          <debug_text text="'attacking %s %s %s %s.\n preferred target is now: %s.\n num targets: %s'.[$evaltarget.class, $evaltarget.idcode, $evaltarget.knownname, $evaltarget, $preferredtarget.knownname, $targets.count]" chance="$debugchance"/>
          <remove_value name="$resulttargets"/>
          <remove_value name="$evaltarget"/>

          <do_if value="$disabletargets.indexof.{$primarytarget} or ( $disabletargets.indexof.{$primarytarget.container} and (not @$behaviortargetclasses.count or not $primarytarget.isclass.{$behaviortargetclasses}) and ($primarytarget.container.hull lt (this.ship.dps.all * ([$scantime, 1s].max)hp) or ($primarytarget.container.hullpercentage + $primarytarget.shieldpercentage) lt $disablehullpercentagethreshold) )">
            <!-- if we have a target that we want to disable, do not shoot at that target, only at its surface elements. note that ships that do not have surface elements and have been designated for disabling will not be fired upon at all. -->
            <set_value name="$preferredtarget" exact="null"/>
          </do_if>
          <!-- if the player is not the pilot and the ship has primary and/or secondary weapons, set them. -->
          <do_elseif value="(this.assignedcontrolled != player.occupiedship) and not this.assignedcontrolled.dock">
            <!-- NB: $preferredtarget is either:
              a ship,
              a surface element,
              or a station module,
              or null.

              never a station because stations resolve to their origin position which could be empty. -->
            <set_value name="$largetarget" exact="@$preferredtarget.iscapitalship"/>
            <shoot_at object="this.assignedcontrolled" target="$preferredtarget" largetarget="$largetarget" additional_targets="if not $largetarget then $targets.list else []" tolerance="10.0deg" fixedtarget="true" />
            <shoot_at object="this.assignedcontrolled" target="$preferredtarget" missiles="true" largetarget="$largetarget" additional_targets="if not $largetarget then $targets.list else []" tolerance="360.0deg" fixedtarget="true" />
          </do_elseif>
        </do_if>

        <do_all exact="$disabletargets.count" counter="$i">
          <do_if value="@$disabletargets.{$i}.iscapitalship or $disabletargets.{$i}.isrealclass.station or $disabletargets.{$i}.container.exists">
            <!-- target having a container means either target is a surface element or is docked. -->
            <set_value name="$evaltarget" exact="if $disabletargets.{$i}.container.exists then $disabletargets.{$i}.container else $disabletargets.{$i}"/>
            <find_object_component name="$loctargets" object="$evaltarget" checkoperational="true" surfaceelement="true" multiple="true" append="true"/>
            <!-- if disabletarget hull is above threshold ... -->
            <do_if value="(@$behaviortargetclasses.count and $primarytarget.isclass.{$behaviortargetclasses}) or ($evaltarget.hull gt (this.ship.dps.turrets.all * ([$scantime, 1s].max)hp) and ($evaltarget.hullpercentage + $evaltarget.shieldpercentage) gt $disablehullpercentagethreshold)">
              <!-- ... and disabletarget has surface elements, only target those surface elements. -->
              <do_if value="$loctargets.count">
                <do_if value="$targets.indexof.{$evaltarget}">
                  <add_to_group groupname="$targets" list="$loctargets"/>
                  <remove_from_group group="$targets" object="$evaltarget"/>
                </do_if>
                <do_if value="$attackers.indexof.{$evaltarget}">
                  <add_to_group groupname="$attackers" list="$loctargets"/>
                  <remove_from_group group="$attackers" object="$evaltarget"/>
                </do_if>
                <do_if value="$dronetargets.indexof.{$evaltarget}">
                  <add_to_group groupname="$dronetargets" list="$loctargets"/>
                  <remove_from_group group="$dronetargets" object="$evaltarget"/>
                </do_if>
              </do_if>
              <!-- ... and disabletarget has no surface elements, fire upon the hull. -->
              <do_elseif value="not $targets.indexof.{$evaltarget}">
                <add_to_group groupname="$targets" object="$evaltarget"/>
              </do_elseif>
            </do_if>
            <!-- if disabletarget hull is below threshold, stop firing at it, -->
            <do_elseif value="$targets.indexof.{$evaltarget} or $attackers.indexof.{$evaltarget}">
              <debug_text text="'%s %s hull below threshold. holding fire on target.'.[$evaltarget.knownname, $evaltarget]" chance="$debugchance"/>
              <remove_from_group group="$targets" object="$evaltarget"/>
              <remove_from_group group="$attackers" object="$evaltarget"/>
              <!-- and at its previously acquired surface elements. -->
              <do_all exact="$loctargets.count" counter="$j">
                <do_if value="$targets.indexof.{$loctargets.{$j}}">
                  <remove_from_group group="$targets" object="$loctargets.{$j}"/>
                </do_if>
                <do_if value="$attackers.indexof.{$loctargets.{$j}}">
                  <remove_from_group group="$attackers" object="$loctargets.{$j}"/>
                </do_if>
                <do_if value="$dronetargets.indexof.{$loctargets.{$j}}">
                  <remove_from_group group="$dronetargets" object="$loctargets.{$j}"/>
                </do_if>
              </do_all>
            </do_elseif>
            <remove_value name="$loctargets"/>
            <remove_value name="$evaltarget"/>
          </do_if>
        </do_all>

        <clear_group group="$targets_capital"/>
        <clear_group group="$targets_fighters"/>
        <do_if value="not this.isplayerowned">
          <!-- non player-owned ships use only one weapon mode. throw all targets into one group and allow shoot controller to select targets per turret as appropriate. -->
          <do_if value="$incomingmissiles.count">
            <add_to_group groupname="$targets" group="$incomingmissiles"/>
          </do_if>
          <do_if value="$attackers.count">
            <add_to_group groupname="$targets" group="$attackers"/>
          </do_if>
          <do_if value="$targets.count">
            <set_turret_targets object="this.assignedcontrolled" target="$targets.list" weaponmode="weaponmode.any" preferredtarget="$preferredtarget"/>
          </do_if>
        </do_if>
        <do_else>
          <do_all exact="$targets.count" counter="$i">
            <do_if value="@$targets.{$i}.iscapitalship or @$targets.{$i}.isrealclass.station">
              <add_to_group groupname="$targets_capital" object="$targets.{$i}"/>
            </do_if>
            <do_elseif value="$targets.{$i}.isclass.ship">
              <add_to_group groupname="$targets_fighters" object="$targets.{$i}"/>
            </do_elseif>
            <do_elseif value="$targets.{$i}.container">
              <do_if value="@$targets.{$i}.container.iscapitalship or @$targets.{$i}.container.isrealclass.station">
                <add_to_group groupname="$targets_capital" object="$targets.{$i}"/>
              </do_if>
              <do_elseif value="$targets.{$i}.container.isclass.ship">
                <add_to_group groupname="$targets_fighters" object="$targets.{$i}"/>
              </do_elseif>
            </do_elseif>
          </do_all>

          <!-- set turret targets (weapon mode: attack enemies) -->
          <do_if value="$targets.count and $turretmodes.indexof.{weaponmode.attackenemies}">
            <set_turret_targets object="this.ship" target="$targets.list" weaponmode="weaponmode.attackenemies" preferredtarget="$preferredtarget"/>
          </do_if>
          <!-- weapon mode: attack capital ships -->
          <do_if value="$targets_capital.count and $turretmodes.indexof.{weaponmode.attackcapital}">
            <set_value name="$locpreferred" exact="$preferredtarget"/>
            <do_if value="$locpreferred and not $targets_capital.indexof.{$locpreferred}">
              <set_value name="$locpreferred" exact="$targets_capital.random"/>
            </do_if>
            <set_turret_targets object="this.ship" target="$targets_capital.list" weaponmode="weaponmode.attackcapital" preferredtarget="$locpreferred"/>
          </do_if>
          <!-- weapon mode: attack fighters -->
          <do_if value="$targets_fighters.count and $turretmodes.indexof.{weaponmode.attackfighters}">
            <set_value name="$locpreferred" exact="$preferredtarget"/>
            <do_if value="$locpreferred and not $targets_fighters.indexof.{$locpreferred}">
              <set_value name="$locpreferred" exact="$targets_fighters.random"/>
            </do_if>
            <set_turret_targets object="this.ship" target="$targets_fighters.list" weaponmode="weaponmode.attackfighters" preferredtarget="$locpreferred"/>
          </do_if>
          <!-- set turret targets (weapon mode: defend) -->
          <do_if value="$attackers.count and $turretmodes.indexof.{weaponmode.defend}" >
            <set_value name="$locpreferred" exact="$preferredtarget"/>
            <do_if value="$locpreferred and not $attackers.indexof.{$locpreferred}">
              <set_value name="$locpreferred" exact="$attackers.random"/>
            </do_if>
            <set_turret_targets object="this.ship" target="$attackers.list" weaponmode="weaponmode.defend" preferredtarget="$locpreferred"/>
          </do_if>
          <!-- set turret targets (weapon mode: missile defend) -->
          <do_if value="$incomingmissiles.count and $turretmodes.indexof.{weaponmode.missiledefence}">
            <set_value name="$locpreferred" exact="$preferredtarget"/>
            <do_if value="$locpreferred and not $incomingmissiles.indexof.{$locpreferred}">
              <set_value name="$locpreferred" exact="$incomingmissiles.random"/>
            </do_if>
            <set_turret_targets object="this.ship" target="$incomingmissiles.list" weaponmode="weaponmode.missiledefence" preferredtarget="$locpreferred"/>
          </do_if>
          <!-- set turret targets (weapon mode: mining) -->
          <do_if value="$miningtargets.count and $turretmodes.indexof.{weaponmode.mining} and this.ship == player.occupiedship">
            <debug_text text="'setting turrets to fire on %s asteroids'.[$miningtargets.count]" chance="$debugchance"/>
            <set_turret_targets object="this.ship" target="$miningtargets.list" weaponmode="weaponmode.mining"/>
          </do_if>
          <remove_value name="$locpreferred"/>
        </do_else>

        <include_interrupt_actions ref="CapitalLaunchFighters"/>
        <!-- adding a tiny wait to prevent carriers from sending the same ships against different targets. -->
        <wait min="11ms" max="17ms"/>

        <!-- Launch drones. Improves with NPC skill.
          we do not launch another group of drones until all members of this group have been launched.
          this.$launchedunitcount incremented and cleared in move.undock -->
        <do_if value="$dronetargets.count and not this.$launchedunitcount? and this.assignedcontrolled.units.{unitcategory.defence}.count and not this.assignedcontrolled.zone.isclass.highway and not this.assignedcontrolled.travel.active">
          <!-- Better crews, launch with less time delay
                100 combinedskill   2 wings every second,
                80 combinedskill    once every 12.5 seconds,
                60 combinedskill    once every 24.5 seconds,
                40 combinedskill    once every 36.5 seconds,
                20 combinedskill    once every 48.5 seconds,
                0 combinedskill     once every minute. -->
          <!-- NB: $donotlaunchdefencedrones only set if defencedronemode is dronemode.autoassist and we already have drones in the air. -->
          <do_if value="not $donotlaunchdefencedrones? and this.assignedcontrolled.hasarmeddefencedrones">
            <do_if value="player.age" min="$lastdronelaunch + 500ms + ((1.0 - (this.assignedcontrolled.combinedskill / 100.0)) * 60s)">
              <set_value name="$lastdronelaunch" exact="player.age"/>
              <!-- num of units launched per squad depends on pilot combat skill and availability of launch tubes.
                 assuming 10 launch tubes:
                  5 stars   3 units per squad,
                  4 stars   4 units per squad,
                  3 stars   6 units per squad,
                  2 stars   8 units per squad,
                  0-1 star  10 units per squad.

                effective time needed to launch 30 units:
                  100 combinedskill,  5 combat  5 seconds,
                  80 combinedskill,   4 combat  93.75 seconds,
                  60 combinedskill,   3 combat  122.5 seconds,
                  40 combinedskill,   2 combat  136.875 seconds,
                  20 combinedskill,   1 combat  145.5 seconds,
                  0 combinedskill,    0 combat  180 seconds. -->
              <!-- quickly launch several discrete wings.
                roughly inversely proportional to pilot skill -->
              <do_if value="not $num_launchtubes and $num_dronedocks">
                <set_value name="$maxnum_dronespersquad" exact="[[$num_dronedocks * [1.2 - (@this.ship.pilot.skill.piloting / 15.0), 1.0].min, 1].max, this.ship.availableunits.{unitcategory.defence}.count].min"/>
              </do_if>
              <do_else>
                <set_value name="$maxnum_dronespersquad" exact="[[$num_launchtubes * [1.2 - (@this.ship.pilot.skill.piloting / 15.0), 1.0].min, 1].max, this.ship.availableunits.{unitcategory.defence}.count].min"/>
              </do_else>
              <!-- dronetargets is a group because there is always a delay between when it is populated and when it is acted upon, but it has to be a list so that it can be shuffled. otherwise, consecutive groups of units will go after the same target. -->
              <set_value name="$list_dronetargets" exact="$dronetargets.list"/>
              <shuffle_list list="$list_dronetargets"/>
              <!-- only launch units if a valid target is actually within range. -->
              <do_all exact="$list_dronetargets.count" counter="$i">
                <!-- prioritize closer targets -->
                <do_if value="this.ship.distanceto.{$list_dronetargets.{$i}} lt this.ship.maxradarrange * 0.5">
                  <set_value name="$dronetarget" exact="$list_dronetargets.{$i}"/>
                  <break/>
                </do_if>
                <do_elseif value="this.ship.distanceto.{$list_dronetargets.{$i}} le this.ship.maxradarrange">
                  <do_if value="$dronetarget?">
                    <do_if value="this.ship.distanceto.{$list_dronetargets.{$i}} lt this.ship.distanceto.{$dronetarget}">
                      <set_value name="$dronetarget" exact="$list_dronetargets.{$i}"/>
                    </do_if>
                  </do_if>
                  <do_else>
                    <set_value name="$dronetarget" exact="$list_dronetargets.{$i}"/>
                  </do_else>
                </do_elseif>
              </do_all>
              <do_if value="@$dronetarget.canbeattacked">
                <set_value name="$locnumdrones" min="($maxnum_dronespersquad * 0.8)i" max="($maxnum_dronespersquad)i"/>
                <do_if value="not $num_launchtubes and $locnumdrones gt 1">
                  <!-- this.$launchedunitcount incremented in move.undock as each drone is launched, cleared in move.undock once this.$launchedunitcount.{1} == this.$launchedunitcount.{2} -->
                  <set_value name="this.$launchedunitcount" exact="[0, $locnumdrones]"/>
                </do_if>

                <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                  <do_if value="not @$group_launcheddefencedrones.{$i}.commander.isunit and (@$group_launcheddefencedrones.{$i}.order.id != 'Attack')">
                    <set_value name="$drone" exact="$group_launcheddefencedrones.{$i}"/>
                    <debug_text text="'%s %s %s redirecting %s %s %s to attack %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$drone.idcode, @$drone.knownname, $drone, @$dronetarget.idcode, @$dronetarget.knownname, $dronetarget]" chance="$debugchance"/>
                    <break/>
                  </do_if>
                </do_all>

                <do_if value="not @$drone and this.assignedcontrolled.availableunits.{unitcategory.defence}.count">
                  <launch_drone name="$drone" object="this.object" exact="$locnumdrones" category="unitcategory.defence"/>
                  <add_to_group groupname="$group_launcheddefencedrones" object="$drone"/>
                  <debug_text text="player.age + ': launching %s drones. next drones will be launched in at least %s seconds. skill: %s'.[$locnumdrones, ($lastdronelaunch + 500ms + ((1.0 - (this.assignedcontrolled.combinedskill / 100.0)) * 60s)) - player.age, @this.ship.pilot.skill.piloting]" chance="$debugchance"/>
                </do_if>

                <do_if value="@$drone">
                  <!-- Set them to our relation -->
                  <do_if value="not $drone.mayattack.{$dronetarget} and not this.object.isplayerowned">
                    <set_relation_boost object="$drone" otherobject="$dronetarget" value="this.object.relationto.{$dronetarget}" silent="true" />
                  </do_if>

                  <do_if value="not $num_launchtubes and $locnumdrones gt 1">
                    <!-- form on this.assignedcontrolled until all drones are launched. -->
                    <create_order object="$drone" id="'Escort'">
                      <param name="target" value="this.assignedcontrolled"/>
                      <!-- HACK -->
                      <param name="timeout" value="24h" comment="has to be a large positive number, otherwise order will immediately complete since other orders are queued."/>
                      <param name="releasesignal" value="['units_go']"/>
                      <param name="debugchance" value="$debugchance"/>
                    </create_order>
                  </do_if>

                  <!-- Attack order! -->
                  <create_order object="$drone" id="'Attack'">
                    <param name="primarytarget" value="$dronetarget" />
                    <param name="secondarytargets" value="$list_dronetargets" />
                    <param name="escort" value="this.object" />
                    <param name="pursuedistance" value="this.ship.maxradarrange" />
                    <param name="allowothertargets" value="true"/>
                    <param name="checkrelation" value="$checkrelation" />
                    <param name="disable" value="@$disabletargets.indexof.{$dronetarget} or ($dronetarget.container and $disabletargets.indexof.{$dronetarget.container})"/>
                    <param name="disablehullpercentagethreshold" value="@$disablehullpercentagethreshold"/>
                    <param name="behaviortargetclasses" value="if @$behaviortargetclasses.count then $behaviortargetclasses else []"/>
                    <param name="internalorder" value="true"/>
                    <param name="debugchance" value="$debugchance"/>
                  </create_order>

                  <do_if value="$defencedronemode != dronemode.escort">
                    <!-- Dock order for after finishing -->
                    <create_order object="$drone" id="'DockAndWait'" default="true">
                      <param name="destination" value="this.assignedcontrolled"/>
                      <param name="dockfollowers" value="true"/>
                      <param name="debugchance" value="$debugchance"/>
                    </create_order>
                  </do_if>
                  <do_else>
                    <create_order object="$drone" id="'Escort'" default="true"/>
                  </do_else>

                  <do_all exact="$drone.allsubordinates.count" counter="$i">
                    <set_value name="$locsub" exact="$drone.allsubordinates.{$i}"/>
                    <add_to_group groupname="$group_launcheddefencedrones" object="$locsub"/>
                    <do_if value="this.isplayerowned">
                      <set_relation_boost object="$dronetarget" otherobject="$locsub" value="this.assignedcontrolled.relationto.{$dronetarget}" silent="true"/>
                    </do_if>
                    <do_else>
                      <set_relation_boost object="$locsub" otherobject="$dronetarget" value="this.assignedcontrolled.relationto.{$dronetarget}" silent="true"/>
                    </do_else>

                    <do_if value="$defencedronemode != dronemode.escort">
                      <create_order object="$locsub" id="'DockAndWait'" default="true">
                        <param name="destination" value="this.assignedcontrolled"/>
                        <param name="dockfollowers" value="true"/>
                        <param name="debugchance" value="$debugchance"/>
                      </create_order>
                    </do_if>
                    <do_else>
                      <!-- default order in case $drone is killed is to escort the ship that launched them. -->
                      <create_order object="$locsub" id="'Escort'" default="true">
                        <param name="target" value="this.assignedcontrolled"/>
                      </create_order>
                    </do_else>

                    <!-- non-default order at the bottom of this ship's order queue to escort $drone. -->
                    <create_order object="$locsub" id="'Escort'"/>
                  </do_all>
                  <remove_value name="$locsub"/>

                  <remove_value name="$drone" />
                </do_if>
                <do_else>
                  <debug_text text="'no drones were launched.'" chance="$debugchance"/>
                </do_else>
                <remove_value name="$locnumdrones"/>
                <remove_value name="$dronetarget" />
              </do_if>
              <do_else>
                <debug_text text="'no drone targets are within radar range.'" chance="$debugchance"/>
              </do_else>
              <remove_value name="$list_dronetargets"/>
            </do_if>
          </do_if>
          <do_else>
            <remove_value name="$donotlaunchdefencedrones"/>
          </do_else>
        </do_if>
        <!-- Clear drone targets, it will be repopulated in the next iteration (if there are any) -->
        <clear_group group="$dronetargets"/>
      </do_if>
      <do_else>
        <cease_fire object="this.ship" />
        <!-- Simulate the stand by -->
        <set_command_action commandaction="commandaction.standingby"/>
        <do_all exact="$group_launcheddefencedrones.count" counter="$i">
          <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
        </do_all>
        <clear_group group="$dronetargets"/>
        <clear_group group="$targets"/>
        <clear_group group="$targets_capital"/>
        <clear_group group="$targets_fighters"/>
        <clear_group group="$miningtargets"/>
        <clear_group group="$attackers"/>
        <remove_value name="$closestthreat"/>
      </do_else>

      <!-- NB: if we are here, we are firing. -->
      <wait exact="$scantime" comment="To avoid performance problems">
        <interrupt>
          <conditions>
            <check_any>
              <!-- Enemy found (exclude xs) -->
              <check_all>
                <event_object_enemy_found object="this.ship" comment="this checks may be attacked by"/>
                <check_value value="not event.param.isclass.ship_xs or event.param.macro.ismacro.{param.boarding.boardingpodmacro} or (this.ship == player.controlled)"/>
              </check_all>
              <!-- Auto-assist check -->
              <check_all>
                <event_player_changed_target/>
                <check_value value="this.assignedcontrolled.isplayerowned"/>
                <check_any>
                  <check_all>
                    <check_value value="$turretmodes.indexof.{weaponmode.autoassist} or ($defencedronemode == dronemode.autoassist and this.assignedcontrolled.hasarmeddefencedrones)"/>
                    <check_value value="(not event.param and not player.target) or @this.assignedcontrolled.mayattack.{event.param}"/>
                    <set_value name="$locattack"/>
                  </check_all>
                  <check_all>
                    <check_value value="$transportdronemode == dronemode.collectselected"/>
                    <check_value value="event.param.exists and event.param.isclass.collectable and event.param.canbepickedup"/>
                    <check_value value="this.assignedcontrolled.distanceto.{event.param} le this.assignedcontrolled.maxradarrange"/>
                  </check_all>
                </check_any>
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'event %1 %1 (%2, %3)'.[event.name, @event.param.name, event.param]" chance="$debugchance" />
            <do_if value="event.name == 'event_player_changed_target'">
              <do_if value="event.param">
                <do_if value="$locattack?">
                  <do_if value="this.assignedcontrolled.mayattack.{event.param}">
                    <set_value name="$evaltarget" exact="event.param"/>
                    <include_interrupt_actions ref="SelectTargets"/>
                    <do_if value="@$resulttargets.count">
                      <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                        <add_to_group groupname="$targets" group="$resulttargets"/>
                        <debug_text text="'setting autoassist turrets to fire upon %s targets.'.[$resulttargets.count]" chance="$debugchance"/>
                        <!-- NB: this target list will be ignored. target acquisition for autoassist turrets is handled in code. -->
                        <set_turret_targets object="this.assignedcontrolled" target="$resulttargets.list" weaponmode="weaponmode.autoassist"/>
                      </do_if>

                      <do_if value="$defencedronemode == dronemode.autoassist and this.assignedcontrolled.hasarmeddefencedrones">
                        <clear_group group="$dronetargets"/>
                        <add_to_group groupname="$dronetargets" group="$resulttargets"/>

                        <!-- if any defence drones are already out, simply redirect them to the new target. otherwise, proceed to FindEnemies and launch new ones. -->
                        <do_if value="$group_launcheddefencedrones.count">
                          <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                            <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
                            <create_order object="$group_launcheddefencedrones.{$i}" id="'Attack'">
                              <param name="primarytarget" value="$evaltarget"/>
                              <param name="secondarytargets" value="$resulttargets"/>
                              <param name="internalorder" value="true"/>
                              <param name="debugchance" value="$debugchance"/>
                            </create_order>
                          </do_all>
                          <set_value name="$donotlaunchdefencedrones"/>
                        </do_if>
                      </do_if>
                    </do_if>
                    <remove_value name="$resulttargets"/>
                    <remove_value name="$evaltarget"/>
                    <remove_value name="$locattack"/>
                    <resume label="FindEnemies" />
                  </do_if>
                </do_if>
                <do_else>
                  <debug_text text="'player selected collectable %s %s and transport drones are set to collect selected crates.'.[@event.param.knownname, event.param]" chance="$debugchance"/>
                  <set_value name="$pickuptargets_container" exact="[event.param]"/>
                  <include_interrupt_actions ref="LaunchDrone_Transport"/>
                </do_else>
              </do_if>
              <do_elseif value="not player.target">
                <do_if value="$turretmodes.indexof.{weaponmode.autoassist}">
                  <debug_text text="'target deselected. autoassist turrets ceasing fire.'" chance="$debugchance"/>
                  <!-- player just deselected a target and there is no target. autoassist turrets simply cease firing and we resume waiting. -->
                  <cease_fire object="this.assignedcontrolled" weaponmode="weaponmode.autoassist"/>
                </do_if>

                <do_if value="$defencedronemode == dronemode.autoassist">
                  <clear_group group="$dronetargets"/>
                  <do_all exact="$group_launcheddefencedrones.count" counter="$i">
                    <cancel_all_orders object="$group_launcheddefencedrones.{$i}"/>
                  </do_all>
                </do_if>

                <!-- transport drones keep collecting what they were sent out to collect. -->

              </do_elseif>
            </do_if>
            <remove_value name="$locattack"/>
          </actions>
        </interrupt>
      </wait>

      <resume label="Start" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <label name="Start"/>

      <set_value name="$weapons_all" exact="this.ship.turrets.operational.list"/>
      <create_list name="$turretmodes"/>
      <do_all exact="$weapons_all.count" counter="$i">
        <do_if value="not $turretmodes.indexof.{$weapons_all.{$i}.mode}">
          <append_to_list name="$turretmodes" exact="$weapons_all.{$i}.mode"/>
        </do_if>
      </do_all>
      <remove_value name="$weapons_all"/>

      <!-- Go to find enemies if:
            - configuration attack is on
            - Operational target
            - Hold Fire mode is off -->
      <!--If not, go to wait -->
      <do_if value="$turretmodes.indexof.{weaponmode.attackenemies} or ($defencedronemode == dronemode.attackenemies) or @$primarytarget.canbeattacked or @$targets.count">
        <resume label="FindEnemies" />
      </do_if>

      <!-- DEFENSIVE MODE -->
      <label name="Wait" />
      <!-- Stop fire -->
      <cease_fire object="this.ship" />
      <!-- Recall drones -->
      <signal_objects object="this" param="'recall_defencedrones'"/>
      <run_script name="'lib.recall.subordinates'" chance="0">
        <param name="timeout" value="-1s" comment="recall drones" />
      </run_script>
      <!-- wait for attack signal or updated configurations-->
      <wait/>

      <!-- Find and update Enemies and Targets -->
      <label name="FindEnemies" />

      <!-- Find (more) targets if no target or other targets are allowed -->
      <do_if value="@$allowothertargets or $turretmodes.indexof.{weaponmode.attackenemies} or ($defencedronemode == dronemode.attackenemies)">
        <!-- Clear targets to update them -->
        <clear_group group="$targets"/>
        <clear_group group="$targets_capital"/>
        <clear_group group="$targets_fighters"/>
        <do_if value="$defencedronemode == dronemode.attackenemies">
          <clear_group group="$dronetargets"/>
        </do_if>
        <do_if value="this.sector">
          <find_gravidar_contact groupname="$evaltargets" object="this.ship" class="class.defensible" checkoperational="false" docked="false" maybeattackedby="this.ship" multiple="true">
            <match_context macro="this.sector.macro"/>
            <match_distance object="this.ship" max="this.ship.maxradarrange"/>
            <match class="[class.collectable, class.buildstorage]" negate="true"/>
            <match state="componentstate.wreck" negate="true"/>
          </find_gravidar_contact>
        </do_if>
        <do_all exact="@$evaltargets.count" counter="$i">
          <set_value name="$evaltarget" exact="$evaltargets.{$i}"/>
          <include_interrupt_actions ref="SelectTargets"/>
          <do_if value="@$resulttargets.count">
            <do_if value="@$allowothertargets or $turretmodes.indexof.{weaponmode.attackenemies}">
              <add_to_group groupname="$targets" group="$resulttargets"/>
              <!-- If $allowothertargets, then add these targets to defend mode turrets too -->
              <do_if value="@$allowothertargets">
                <add_to_group groupname="$attackers" group="$resulttargets"/>
              </do_if>
            </do_if>

            <do_if value="$defencedronemode == dronemode.attackenemies">
              <add_to_group groupname="$dronetargets" group="$resulttargets"/>
            </do_if>
          </do_if>
          <remove_value name="$resulttargets"/>
          <remove_value name="$evaltarget"/>
        </do_all>
        <remove_value name="$evaltargets"/>
      </do_if>
      <!-- If no new enemies, update the current ones -->
      <do_else>
        <do_all exact="@$targets.count" counter="$i" reverse="true">
          <!-- Relation, dock and distance check -->
          <do_if value="not this.ship.mayattack.{$targets.{$i}} or @$targets.{$i}.dock or this.ship.distanceto.{$targets.{$i}} gt this.ship.maxradarrange">
            <remove_from_group group="$targets" object="$targets.{$i}" />
          </do_if>
        </do_all>
      </do_else>

      <!-- Update Main target (parameter in signal) -->
      <do_if value="@$primarytarget.canbeattacked">
        <debug_text text="'%s %s %s evaluating primarytarget %s %s %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$primarytarget.idcode, @$primarytarget.knownname, $primarytarget]" chance="$debugchance"/>
        <!-- Relation, dock and distance check -->
        <do_if value="($checkrelation and not this.ship.mayattack.{$primarytarget}) or @$primarytarget.dock" >
          <debug_text text="'no valid target. too friendly or target is docked.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$primarytarget.idcode, @$primarytarget.knownname, $primarytarget]" chance="$debugchance"/>
          <remove_from_group group="$targets" object="$primarytarget" />
          <remove_from_group group="$attackers" object="$primarytarget" />
        </do_if>
        <do_else>
          <set_value name="$evaltarget" exact="$primarytarget"/>
          <include_interrupt_actions ref="SelectTargets"/>
          <do_if value="@$resulttargets.count">
            <add_to_group groupname="$targets" group="$resulttargets"/>
            <add_to_group groupname="$attackers" group="$resulttargets"/>
            <debug_text text="'attacking %s subtargets'.[$resulttargets.count]" chance="$debugchance"/>
          </do_if>
          <remove_value name="$resulttargets"/>
          <remove_value name="$evaltarget"/>
        </do_else>
      </do_if>
      <!-- Update Secondary Targets -->
      <do_if value="@$secondarytargets.count">
        <do_all exact="$secondarytargets.count" counter="$i" reverse="true">
          <do_if value="$secondarytargets.{$i}.canbeattacked">
            <!-- Relation, dock and distance check -->
            <do_if value="($checkrelation and not this.ship.mayattack.{$secondarytargets.{$i}}) or @$secondarytargets.{$i}.dock">
              <remove_from_group group="$targets" object="$secondarytargets.{$i}" />
              <remove_from_group group="$attackers" object="$secondarytargets.{$i}" />
            </do_if>
            <do_else>
              <set_value name="$evaltarget" exact="$secondarytargets.{$i}"/>
              <include_interrupt_actions ref="SelectTargets"/>
              <do_if value="@$resulttargets.count">
                <add_to_group groupname="$targets" group="$resulttargets"/>
                <add_to_group groupname="$attackers" group="$resulttargets"/>
              </do_if>
              <remove_value name="$resulttargets"/>
              <remove_value name="$evaltarget"/>
            </do_else>
          </do_if>
        </do_all>
      </do_if>

      <label name="Attack" />

      <!-- Fight Simulation -->
      <do_if value="@$targets.count" min="1">
        <!-- Simulate the attack -->
        <set_command_action commandaction="commandaction.attacking" />
        <set_turret_targets object="this.ship" />
      </do_if>
      <do_else>
        <!-- Simulate the stand by -->
        <set_command_action commandaction="commandaction.standingby" />
        <cease_fire object="this.ship"/>
        <clear_group group="$targets"/>
        <clear_group group="$targets_capital"/>
        <clear_group group="$targets_fighters"/>
      </do_else>

      <set_value name="$attacktime" min="player.age + 30s" max="player.age + 40s" />
      <set_value name="$waittime" exact="1s" />
      <set_value name="$table_ammousage" exact="table[]"/>
      <do_for_each name="$turret" in="this.assignedcontrolled.turrets.operational.list">
        <set_value name="$locmacro" exact="$turret.ammo.macro"/>
        <do_if value="$locmacro and this.assignedcontrolled.ammostorage.{$locmacro}.count">
          <set_value name="$table_ammousage.{$locmacro}" exact="1" operation="add"/>
        </do_if>
      </do_for_each>
      <do_for_each name="$weapon" in="this.assignedcontrolled.weapons.operational.list">
        <set_value name="$locmacro" exact="$weapon.ammo.macro"/>
        <do_if value="$locmacro and this.assignedcontrolled.ammostorage.{$locmacro}.count">
          <set_value name="$table_ammousage.{$locmacro}" exact="1" operation="add"/>
        </do_if>
      </do_for_each>
      <remove_value name="$locmacro"/>
      <set_value name="$numammotypes" exact="$table_ammousage.keys.count" chance="$debugchance"/>

      <do_for_each name="$loctarget" in="$targets">
        <do_if value="$loctarget.canbeattacked and (this.assignedcontrolled.bboxdistanceto.{$loctarget} le $FiringRange) and not @$loctarget.dock">
          <!-- target not being defensible and having a container means it's a surface element. we cannot get the attackstrength of something that is not a defensible. so target the container. -->
          <do_while value="not $loctarget.isclass.defensible and $loctarget.container">
            <set_value name="$loctarget" exact="$loctarget.container"/>
          </do_while>
          <do_if value="not @$targets_low.indexof.{$loctarget}">
            <add_to_group groupname="$targets_low" object="$loctarget"/>
          </do_if>
        </do_if>
      </do_for_each>

      <debug_text text="'unknown. fight. targets: ' + @$targets_low " chance="0" />
      <!-- For each enemy, apply strength-->
      <do_while value="this.ship.pilot and @$targets_low.count">
        <shuffle_group group="$targets_low"/>
        <do_all exact="$targets_low.count" counter="$i" reverse="true">
          <do_if value="not @$maxtargets">
            <!-- Search/Attacking waiting time -->
            <set_value name="$waittime" min="1s" max="4s" profile="increasing" />
            <wait exact="$waittime"/>
            <!-- NB: $maxtargets limits the number of targets engaged in one frame. -->
            <!--The maximum amount of targets to be hit in this volley, based on the number of operational turrets-->
            <set_value name="$maxtargets" exact="[this.ship.turrets.operational.count, $targets_low.count, [this.assignedcontrolled.combinedskill / 5, 3].max].min"/>
            <set_value name="$maxtargets" min="1" max="$maxtargets" profile="increasing"/>
          </do_if>

          <do_if value="this.ship.pilot and @$targets_low.{$i}.canbeattacked and not @$targets_low.{$i}.dock and this.assignedcontrolled.mayattack.{$targets_low.{$i}}">
            <set_value name="$target" exact="$targets_low.{$i}"/>

            <!-- Get and apply strengths-->
            <do_if value="$target.canbeattacked" chance="[this.assignedcontrolled.combinedskill, 90].max" comment="chance of success">
              <!-- do not attack objects that are too far away, gravidar range can be 50km+ !! -->
              <do_if value="this.assignedcontrolled.bboxdistanceto.{$target} le $FiringRange">
                <!-- Get the strength in 'result'-->
                <get_attackstrength object="this.assignedcontrolled" target="$target" usedrones="$target.isclass.[class.ship_xs, class.ship_s, class.ship_m]">
                  <result hullshield="$result_hullshield" hullonly="$result_hullonly" shieldonly="$result_shieldonly" hullnoshield="$result_hullnoshield"/>
                </get_attackstrength>
                <debug_text text="'%s %s %s attacking %s %s %s. target hull: %s. attack strength:\nhullshield: %s\nhullonly: %s\nshieldonly: %s\nhullnoshield: %s\ndps all: %s\ndps main: %s\ndps turrets: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$target.idcode, @$target.knownname, $target, $target.hull, $result_hullshield, $result_hullonly, $result_shieldonly, $result_hullnoshield, this.assignedcontrolled.dps.all, (this.assignedcontrolled.dps.primary + this.assignedcontrolled.dps.secondary), this.assignedcontrolled.dps.turrets.all]" chance="0"/>

                <do_if value="not @$module.canbeattacked">
                  <find_object_component name="$module" class="class.module" object="$target" checkoperational="false">
                    <match state="componentstate.wreck" negate="true"/>
                  </find_object_component>
                </do_if>

                <!-- Apply the strength to target -->
                <set_value name="$result_hullshield" exact="$result_hullshield * ($waittime)f"/>
                <set_value name="$result_hullonly" exact="$result_hullonly * ($waittime)f"/>
                <set_value name="$result_shieldonly" exact="$result_shieldonly * ($waittime)f"/>
                <set_value name="$result_hullnoshield" exact="$result_hullnoshield * ($waittime)f"/>
                <apply_attackstrength object="$target" attacker="this.assignedcontrolled" hullshield="$result_hullshield" hullonly="$result_hullonly" shieldonly="$result_shieldonly" hullnoshield="$result_hullnoshield" module="@$module">
                  <result killed="$isdead" module="$module"/>
                </apply_attackstrength>
                <do_if value="false">
                  <is_in_quadrant result="$q_front" object="this.assignedcontrolled" target="$target" front="true"/>
                  <is_in_quadrant result="$q_right" object="this.assignedcontrolled" target="$target" right="true"/>
                  <is_in_quadrant result="$q_left" object="this.assignedcontrolled" target="$target" left="true"/>
                  <is_in_quadrant result="$q_back" object="this.assignedcontrolled" target="$target" back="true"/>
                  <is_in_quadrant result="$q_up" object="this.assignedcontrolled" target="$target" up="true"/>
                  <is_in_quadrant result="$q_down" object="this.assignedcontrolled" target="$target" down="true"/>
                  <debug_text text="'%s %s %s attacking %s %s %s. target is destroyed: %s applied attack strength:\nhullshield: %s\nhullonly: %s\nshieldonly: %s\nhullnoshield: %s\ntotal dps: %s, weapon dps: %s, turret dps: %s\nwaittime: %ss\nquadrant: front: %s, right: %s, left: %s, back: %s, up: %s, down: %s\nquadrant dps: front: %s, right: %s, left: %s, back: %s, up: %s, down: %s\ntarget hull: %s. module hull: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$target.idcode, @$target.knownname, $target, $isdead, $result_hullshield, $result_hullonly, $result_shieldonly, $result_hullnoshield, this.assignedcontrolled.dps.all, this.assignedcontrolled.dps.lasers.all, this.assignedcontrolled.dps.turrets.all, $waittime, $q_front, $q_right, $q_left, $q_back, $q_up, $q_down, this.assignedcontrolled.dps.lasers.all + this.assignedcontrolled.dps.missiles.all + this.assignedcontrolled.dps.turrets.{quadrant.front}, this.assignedcontrolled.dps.turrets.{quadrant.right}, this.assignedcontrolled.dps.turrets.{quadrant.left}, this.assignedcontrolled.dps.turrets.{quadrant.back}, this.assignedcontrolled.dps.turrets.{quadrant.up}, this.assignedcontrolled.dps.turrets.{quadrant.down}, $target.hull, @$module.hull]"/>
                  <remove_value name="$q_down"/>
                  <remove_value name="$q_up"/>
                  <remove_value name="$q_back"/>
                  <remove_value name="$q_left"/>
                  <remove_value name="$q_right"/>
                  <remove_value name="$q_front"/>
                </do_if>
                <set_value name="$numammo" exact="this.assignedcontrolled.ammostorage.missile.count" chance="$debugchance"/>
                <do_for_each name="$missile" valuename="$amount" in="$table_ammousage">
                  <do_if value="this.assignedcontrolled.ammostorage.{$missile}.count" chance="50">
                    <set_value name="$locamount" min="1" max="$amount"/>
                    <remove_ammo object="this.assignedcontrolled" macro="$missile" amount="$locamount"/>
                    <remove_value name="$locamount"/>
                  </do_if>
                </do_for_each>
                <debug_text text="'ammo reduced, \nnum reduced: %s\nnum ammo: %s\nnum ammo types: %s'.[@$numammo - this.assignedcontrolled.ammostorage.missile.count, this.assignedcontrolled.ammostorage.missile.count, @$numammotypes]" chance="($numammo? and ($numammo - this.assignedcontrolled.ammostorage.missile.count) gt 0) * $debugchance"/>
                <debug_text text="'%s %s %s attacking %s %s %s. target is destroyed: %s applied attack strength:\nhullshield: %s\nhullonly: %s\nshieldonly: %s\nhullnoshield: %s\ntarget hull: %s. module hull: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$target.idcode, @$target.knownname, $target, $isdead, $result_hullshield, $result_hullonly, $result_shieldonly, $result_hullnoshield, $target.hull, @$module.hull]" chance="$debugchance"/>
                <debug_text text="'%1 OOS. Apply strength of %2 against %3 is: %4(%5|%6). Is killed: %7'.[player.age,this.ship.knownname,$target.knownname,$result_hullshield + $result_hullonly + $result_shieldonly + $result_hullnoshield,$target.hull,$target.shield,$isdead]" chance="0" />
                <!--Wait so that attack/killed events are processed-->
                <wait exact="1ms" />
              </do_if>
              <do_else>
                <debug_text text="'%1 OOS. Out of range of %2 against %3. Distance %4, fire range %5'.[player.age,this.ship.knownname,$target.knownname,this.ship.bboxdistanceto.{$target},$FiringRange]" chance="$debugchance" />
                <do_if value="this.assignedcontrolled.distanceto.{$target} lt this.assignedcontrolled.maxradarrange">
                  <remove_from_group group="$targets_low" object="$target"/>
                </do_if>
              </do_else>
            </do_if>
            <do_else>
              <debug_text text="'%1 OOS. Attack fail of %2 against %3'.[player.age,this.ship.knownname,$target.knownname]" chance="$debugchance" />
            </do_else>
            <remove_value name="$target" />
          </do_if>

          <do_if value="$maxtargets gt 0">
            <set_value name="$maxtargets" operation="subtract"/>
          </do_if>
        </do_all>
        <include_interrupt_actions ref="CapitalLaunchFighters"/>

        <!-- Avoid an infite loop-->
        <do_if value="player.age" min="$attacktime">
          <break/>
        </do_if>
      </do_while>
      <remove_value name="$targets_low"/>
      <remove_value name="$table_ammousage"/>
      <remove_value name="$numammo"/>
      <remove_value name="$numammotypes"/>
      <remove_value name="$attacktime" />
      <remove_value name="$waittime" />
      <remove_value name="$maxtargets" />

      <!-- Scan time -->
      <wait min="5s" max="10s" comment="To avoid performance problems" />

      <resume label="Start" />

    </actions>
  </attention>
  <on_abort>
    <!-- Stop shooting targets if interrupted (change the npc)-->
    <cease_fire object="this.ship" />
  </on_abort>
</aiscript>