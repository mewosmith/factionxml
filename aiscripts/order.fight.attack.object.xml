<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="order.fight.attack.object" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="12">
  <!--

  Script to decide which fight.attack.object.foo script is suitable to be called

  Depending on the class:
  - Drone:
    - fight.attack.object.drone.leader
  - xs, s, m: 
	  -fight.attack.object.fighter
    -fight.attack.object.fighter.bigtarget
  - l, xl:
		- signal 'attack target' (defense officer)
		- move.attack.object.capital (pilot)
  
  -->
  <order id="Attack" name="{1041, 431}" description="{1041, 432}" category="combat">
    <params>
      <param name="primarytarget" required="true" type="object" text="{1041, 10126}" comment="Target. The object to fight with"/>
      <param name="secondarytargets" default="null" type="list" text="{1041, 10149}" advanced="true" comment="Secondary targets. The secondary targets to fight after $target (Optional)">
        <input_param name="type" value="'object'"/>
      </param>
      <param name="escort" default="null" type="object" text="{1041, 10038}" advanced="true" comment="Object to escort - stay at 'pursuedistance' and shoot enemies attacking this" />
      <param name="pursuedistance" default="[this.ship.maxradarrange, 1km].max" type="internal" text="{1041, 10090}" comment="Pursue distance. Distance to pursue/escort (if pursuetargets true or 'escort' provided). Default: max radar range">
        <input_param name="min" value="1km"/>
        <input_param name="max" value="[this.ship.maxradarrange, 1km].max"/>
        <input_param name="step" value="1km"/>
      </param>
      <param name="pursuetargets" default="if this.ship.isplayerowned then true else false" type="bool" advanced="true" text="{1041, 10091}" comment="Pursue targets. Pursue the target no matter what. Default: false" />
      <param name="allowothertargets" default="if this.ship.isplayerowned then false else true" type="bool" text="{1041, 10010}" comment="Attack all enemies. Whether the script shall keep running when all primary targets have been destroyed. Default: true for non-player-owned ships" />
      <param name="checkrelation" default="if this.ship.isplayerowned then @this.ship.mayattack.{$primarytarget} else true" type="bool" text="{1041, 10081}" advanced="true" comment="Only engage hostiles. Check may attack (faction enemy relation). Default: true for non-player-owned ships" />
      <param name="disable" default="false" type="bool" text="{1041, 10114}" comment="Shoot to disable. Instructs this ship to only try to disable the target or targets without destroying it."/>
      <param name="disablehullpercentagethreshold" default="20" type="number" text="{1041, 10152}" advanced="true" comment="Disable hull threshold. If disable is set, this ship will stop firing if the hull of the target is at or below this percentage.">
        <input_param name="startvalue" value="20"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="100"/>
        <input_param name="step" value="1"/>
      </param>
      <param name="disabletargets" default="[]" type="internal" text="{1041, 10029}" comment="Targets to disable. If defined and $disable is true, only these targets will be disabled. If not defined and $disable is true, $primarytarget and $secondarytargets will be marked for disabling."/>
      <param name="minrange" default="this.ship.maxcombatrange.all * 0.6" type="number" text="{1041, 10072}" advanced="true" comment="Minimum range. Minimum distance we should try to maintain relative to the target.">
        <input_param name="startvalue" value="this.ship.maxcombatrange.all * 0.6"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="this.ship.maxcombatrange.all"/>
        <input_param name="step" value="this.ship.maxcombatrange.all / 10"/>
      </param>
      <param name="maxrange" default="this.ship.maxcombatrange.all * 0.9" type="number" text="{1041, 10062}" advanced="true" comment="Maximum range. Maximum distance we should try to maintain relative to the target.">
        <input_param name="startvalue" value="this.ship.maxcombatrange.all * 0.9"/>
        <input_param name="min" value="0"/>
        <input_param name="max" value="this.ship.maxcombatrange.all"/>
        <input_param name="step" value="this.ship.maxcombatrange.all / 10"/>
      </param>
      <param name="maintaindistance" default="true" type="internal" text="{1041, 10023}" comment="Carrier range. If a carrier, use radar range instead of weapon range to determine range thresholds."/>
      <param name="squad_attack" default="false" type="bool" text="{1041, 10118}" advanced="true" comment="Squad attack. Command the whole squadron to attack, Default: false"/>
      <param name="boardingbehavior" default="null" type="internal" comment="Boarding behavior. If not null, the behavior assigned to this ship while boarding primarytarget."/>
      <param name="behaviortargetclasses" default="[]" type="internal" comment="Behavior target classes. Target classes associated with boardingbehavior. disablehullpercentagethreshold will be ignored if current target is a behavior target. (Otherwise, we could have a situation where the hull threshold is reached but the boarding phase threshold has not been reached thus stalling the boarding operation.)"/>
      <param name="uncover" default="true" type="internal" text="{1041, 10097}" comment="Remove cover. Remove cover ownership upon attack. Default: true" />
      <param name="targetclasses" default="[]" type="internal" comment="Target classes. List of classes considered valid for attack.">
        <patch value="[]" sinceversion="9"/>
      </param>

      <param name="radius" default="null" type="internal" comment="disengage if target goes beyond this distance relative to radiusanchorpos in radiusanchorspace"/>
      <param name="radiusanchorpos" default="null" type="internal"/>
      <param name="radiusanchorspace" default="null" type="internal"/>

      <param name="allowboost" default="true" type="bool" text="{1041, 10161}" comment="Allow boost. Passed on to combat movement scripts to allow boost while in combat."/>
      <param name="forceprimarytarget" default="false" type="internal" comment="Force the ship to attack primarytarget even if it is not a defensible. $primarytarget.canbeattacked still has to be true. not compatible with $allowothertargets and $secondarytargets.">
        <patch value="false" sinceversion="10"/>
      </param>
      <param name="internalorder" type="bool" default="false" advanced="true" text="{1041, 10159}" comment="Order results from an automated behavior."/>
      <param name="debugchance" type="bool" default="0" advanced="true" text="{1041, 10086}" comment="Print debug output">
        <input_param name="truevalue" value="100"/>
      </param>
    </params>
    <requires>
      <match shiptype="shiptype.lasertower" negate="true"/>
    </requires>
    <location condition="$primarytarget.canbeattacked" object="$primarytarget"/>
    <!--<location condition="$primarytarget.isoperational" object="$primarytarget" additionalobjects="$secondarytargets"/>-->
  </order>
  <interrupts>
    <handler ref="SectorChangeHandler"/>
    <handler ref="TargetInvalidHandler" />
    <handler>
      <conditions>
        <event_object_changed_attention object="this.ship"/>
        <check_value value="this.ship.isunit"/>
        <check_value value="(event.param2 ge attention.visible) and (event.param lt attention.visible)"/>
        <check_value value="this.ship.commander and not this.ship.commander.isunit"/>
      </conditions>
      <actions>
        <debug_text text="'changed attention to %s. drone aborting attack.'.[this.attention]" chance="$debugchance"/>
        <debug_text text="'param: %s, param2: %s'.[event.param, event.param2]" chance="$debugchance"/>
        <abort_called_scripts resume="finish"/>
      </actions>
    </handler>
    <!--<handler ref="AttackHandler"/>-->
    <handler ref="MissileLockHandler" />
    <handler>
      <conditions>
        <event_object_attacked object="this.ship"/>
        <check_value value="$allowothertargets"/>
        <check_value value="event.param.isoperational"/>
        <check_value value="event.param != @$primarytarget"/>
        <check_value value="event.param != @$target"/>
        <check_value value="event.param != @$primarytarget.container"/>
        <check_value value="event.param != @$target.container"/>
        <check_value value="this.ship.mayattack.{event.param}"/>
        <check_value value="not this.assignedcontrolled.iscapitalship or @event.param.iscapitalship or event.param.isclass.station"/>
        <check_any>
          <check_value value="not @$target.canbeattacked"/>
          <check_value value="(event.param.dps.all / ([this.ship.distanceto.{event.param}, 1].max)hp) gt (@$target.dps.all / ([this.ship.distanceto.{$target}, 1].max)hp)"/>
        </check_any>
      </conditions>
      <actions>
        <debug_text text="'%1 (%2) was attacked by %3 (%4) while already moving to attack.'.[this.ship.knownname, this.ship, event.param.knownname, event.param]" chance="$debugchance"/>

        <do_if value="@$target == event.param">
          <debug_text text="'ERROR: attack handler: new attacker is the same as present target.'" chance="$debugchance"/>
        </do_if>

        <do_if value="not @$target.canbeattacked">
          <debug_text text="'no target set yet. responding to attack.'" chance="$debugchance"/>
        </do_if>
        <do_else>
          <debug_text text="'new attacker is either a greater threat than present target or is much closer. evaluating response.'" chance="$debugchance"/>
        </do_else>
        <!-- script will reinitialize at the next blocking action. -->
        <set_value name="$primarytarget" exact="event.param"/>
        <do_if value="@this.assignedcontrolled.order.id == 'Attack'">
          <set_value name="$keepmoving"/>
          <edit_order_param order="this.assignedcontrolled.order" param="'primarytarget'" value="event.param"/>
        </do_if>
        <abort_called_scripts resume="selecttarget"/>
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_order_ready object="this.assignedcontrolled.commander" check="false"/>
        <check_value value="$internalorder"/>
        <check_value value="this.assignedcontrolled.assignment == assignment.attack"/>
        <check_value value="event.param == event.object.order"/>
        <check_any>
          <check_value value="event.param.id != 'Attack'"/>
          <check_value value="event.param.$primarytarget != $primarytarget"/>
        </check_any>
      </conditions>
      <actions>
        <do_if value="(event.param.id == 'Attack') and event.param.$primarytarget.canbeattacked">
          <debug_text text="'commander switched targets. shifting focus.'" chance="$debugchance"/>
          <set_value name="$keepmoving"/>
          <edit_order_param order="this.assignedcontrolled.order" param="'primarytarget'" value="event.param.$primarytarget"/>
          <abort_called_scripts resume="selecttarget"/>
        </do_if>
        <do_else>
          <debug_text text="'commander stopped attacking. standing down.'" chance="$debugchance"/>
          <abort_called_scripts resume="finish"/>
        </do_else>
      </actions>
    </handler>
    <handler ref="ScannedHandler" />
  </interrupts>
  <init>
    <do_if value="this.isplayerowned and not this.isclass.computer ">
      <set_command command="command.attackenemies"/>

      <set_value name="$speak" exact="true" comment="Boolean Speak NPC voice. Default is true"/>
    </do_if>

    <do_if value="@$secondarytargets.count">
      <do_if value="typeof $secondarytargets == datatype.group">
        <add_to_group groupname="$secondarytargetgroup" group="$secondarytargets"/>
      </do_if>
      <do_elseif value="typeof $secondarytargets == datatype.list">
        <add_to_group groupname="$secondarytargetgroup" list="$secondarytargets" check="false"/>
      </do_elseif>
    </do_if>

    <do_if value="$boardingbehavior">
      <!-- TODO: when available, get these behaviors from code. -->
      <!-- boardingbehaviour.maintaindistance implemented in order.fight.board -->
      <set_value name="$behaviors" exact="[boardingbehaviour.attackescorts, boardingbehaviour.targetengines, boardingbehaviour.targetturrets, boardingbehaviour.disabletarget]"/>
      <set_value name="$boardingtarget" exact="$primarytarget"/>
    </do_if>

    <do_if value="this.$squadorderupdated?">
      <!-- set in order.fight.escort when old commander is killed while squadron is attacking target to prevent multiple subordinates relaying multiple instances of the same order. -->
      <remove_value name="this.$squadorderupdated"/>
    </do_if>

    <!--<do_if value="this.object.isunit">
      <do_if value="not this.$designatedtargets?">
        <create_group groupname="this.$designatedtargets"/>
      </do_if>
      <do_if value="$primarytarget.exists">
        <add_to_group groupname="this.$designatedtargets" object="$primarytarget"/>
      </do_if>
      <add_to_group groupname="this.$designatedtargets" list="$secondarytargets"/>
      <do_if value="not this.$time_launched?">
        <set_value name="this.$time_launched" exact="player.age"/>
      </do_if>
      <debug_text text="'Combat drone %s %s (%s),\nsubordinate of %s %s (%s),\nattacking %s %s (%s). %s total targets.'.[this.object.idcode, this.object.knownname, this.object, this.ship.commander.idcode, this.ship.commander.knownname, this.ship.commander, $primarytarget.idcode, $primarytarget.knownname, $primarytarget, this.$designatedtargets.count]" chance="$debugchance"/>
    </do_if>-->
  </init>
  <patch sinceversion="2">
    <do_if value="not @$radius">
      <set_value name="$radius" exact="null"/>
      <set_value name="$radiusanchorpos" exact="null"/>
      <set_value name="$radiusanchorspace" exact="null"/>
    </do_if>
  </patch>
  <patch sinceversion="3">
    <do_if value="not this.isplayerowned and not this.assignedcontrolled.dps.all">
      <reset_weapongroups object="this.assignedcontrolled"/>
      <debug_text text="'PATCH: reset weapon groups of %s %s %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled]" filter="savegame"/>
    </do_if>
  </patch>
  <patch sinceversion="4">
    <!-- patched to true since that is safer. if no path is possible, order should be called again with the proper flag set. -->
    <set_value name="$internalorder" exact="this.isplayerowned"/>
  </patch>
  <patch sinceversion="5">
    <do_if value="@$target.exists and not this.assignedcontrolled.mayattack.{$target}">
      <debug_text text="'PATCH: %s %s %s attacking friendly target: %s %s %s. breaking off and standing down.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$target.idcode, @$target.knownname, $target]" filter="savegame"/>
      <set_value name="$target" exact="null"/>
    </do_if>

    <set_value name="$newtarget" exact="$primarytarget"/>
    <do_if value="@$primarytarget.exists and not this.assignedcontrolled.mayattack.{$primarytarget}">
      <debug_text text="'PATCH: %s %s %s attacking friendly primarytarget: %s %s %s. breaking off and standing down.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$primarytarget.idcode, @$primarytarget.knownname, $primarytarget]" filter="savegame"/>
      <set_value name="$newtarget" exact="null"/>
    </do_if>
    <do_if value="@this.assignedcontrolled.order.id == 'Attack'">
      <edit_order_param order="this.assignedcontrolled.order" param="'primarytarget'" value="$newtarget"/>
    </do_if>
  </patch>
  <patch sinceversion="6">
    <do_if value="@$target.exists and not $pursuetargets and (this.assignedcontrolled.bboxdistanceto.{$target} gt $pursuedistance)">
      <debug_text text="'PATCH: %s %s %s attacking target out of range: %s %s %s. breaking off and standing down.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$target.idcode, @$target.knownname, $target]" filter="savegame"/>
      <set_value name="$target" exact="null"/>
    </do_if>

    <set_value name="$newtarget" exact="$primarytarget"/>
    <do_if value="@$primarytarget.exists and not $pursuetargets and (this.assignedcontrolled.bboxdistanceto.{$primarytarget} gt $pursuedistance)">
      <debug_text text="'PATCH: %s %s %s attacking primarytarget out of range: %s %s %s. breaking off and standing down.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$primarytarget.idcode, @$primarytarget.knownname, $primarytarget]" filter="savegame"/>
      <set_value name="$newtarget" exact="null"/>
    </do_if>
    <do_if value="@this.assignedcontrolled.order.id == 'Attack'">
      <edit_order_param order="this.assignedcontrolled.order" param="'primarytarget'" value="$newtarget"/>
    </do_if>
  </patch>
  <patch sinceversion="7">
    <set_value name="$allowboost" exact="true"/>
  </patch>
  <patch sinceversion="8">
    <do_if value="@$target.isownerless">
      <reset_relation_boost object="this.assignedcontrolled" otherobject="$target"/>
      <edit_order_param order="this.assignedcontrolled.order" param="'primarytarget'" value="$primarytarget"/>
      <debug_text text="'PATCH: %s %s %s was attacking ownerless object. resetting relations and reinitializing. mayattack: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, this.assignedcontrolled.mayattack.{$target}]" filter="savegame"/>
    </do_if>
  </patch>
  <patch sinceversion="12">
    <do_if value="$primarytarget.exists and this.trueowner.relationto.{$primarytarget.trueowner} gt -0.01">
      <reset_relation_boost object="this.assignedcontrolled" otherobject="$primarytarget"/>
      <debug_text text="'PATCH: %s %s %s was attacking %s %s %s which belongs to a non-hostile faction. resetting relations and re-evaluating.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$primarytarget.idcode, @$primarytarget.knownname, $primarytarget]" filter="savegame"/>
      <set_value name="$target" exact="null"/>
      <edit_order_param order="this.assignedcontrolled.order" param="'primarytarget'" value="null"/>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>

      <label name="start"/>

      <label name="selecttarget"/>

      <wait exact="[((100 - this.assignedcontrolled.combinedskill) / 400)s, 1ms].max" sinceversion="1" comment="1-2.5 milliseconds. simulate delay associated with target selection and prevents lock-up in case of loop-back."/>

      <set_value name="$locprimarytarget" exact="@$primarytarget"/>
      <set_value name="$locsecondarytargets" exact="@$secondarytargetgroup.list"/>
      <set_value name="$locignorelist" exact="[]"/>

      <debug_text text="'$boardingtarget?: %s, $boardingbehavior: %s, $primarytarget.isoperational: %s, $boardingtarget == $primarytarget: %s'.[$boardingtarget?, $boardingbehavior, $primarytarget.isoperational, @$boardingtarget == $primarytarget]" chance="$debugchance"/>
      <do_if value="$boardingtarget? and $boardingbehavior and $primarytarget.isoperational and $boardingtarget == $primarytarget">
        <debug_text text="'evaluating boarding behavior.'" chance="$debugchance"/>
        <set_value name="$behaviorindex" exact="$behaviors.indexof.{$boardingbehavior}"/>
        <set_value name="$validbehavior" exact="false"/>

        <!-- check if behavior is valid. if not, we temporarily move down to the next behavior. attacktargets->targetengines->targetturrets->disabletarget. -->
        <do_while value="not $validbehavior">
          <do_if value="$behaviorindex lt 5">
            <do_if value="$behaviorindex == 1">
              <set_value name="$locsecondarytargets" exact="$primarytarget.allsubordinates"/>
            </do_if>
            <do_elseif value="$behaviorindex == 2">
              <find_object_component name="$locsecondarytargets" object="$primarytarget" class="class.engine" checkoperational="true" indestructible="false" invulnerable="false" integrated="false" multiple="true"/>
            </do_elseif>
            <do_elseif value="$behaviorindex == 3">
              <find_object_component name="$locsecondarytargets" object="$primarytarget" class="[class.turret, class.weapon]" checkoperational="true" indestructible="false" invulnerable="false" integrated="false" multiple="true"/>
            </do_elseif>
            <do_elseif value="$behaviorindex == 4">
              <find_object_component name="$locsecondarytargets" object="$primarytarget" surfaceelement="true" checkoperational="true" indestructible="false" invulnerable="false" integrated="false" multiple="true"/>
            </do_elseif>
            <set_value name="$validbehavior" exact="@$locsecondarytargets.count gt 0"/>
            <do_if value="not $validbehavior">
              <set_value name="$behaviorindex" exact="$behaviorindex + 1"/>
            </do_if>
          </do_if>
          <do_else>
            <set_value name="$validbehavior" exact="true"/>
          </do_else>
        </do_while>

        <do_if value="$behaviorindex == 1">
          <!-- allow lib.target.selection to choose between secondarytargets. -->
          <set_value name="$locprimarytarget" exact="null"/>
          <do_if value="$behaviorindex == 1">
            <append_to_list name="$locignorelist" exact="$locprimarytarget"/>
          </do_if>
        </do_if>
        <do_elseif value="$behaviorindex lt 5">
          <set_value name="$target" exact="$locsecondarytargets.random"/>
          <set_value name="$skiptargetselection"/>
        </do_elseif>
        <do_else>
          <!-- fallback in case target currently has no surface elements left: default attack behavior with boarding target set as primarytarget allowing target selection but set to disable. -->
          <set_value name="$target" exact="$primarytarget"/>
        </do_else>

        <do_if value="$behaviorindex != $behaviors.indexof.{$boardingbehavior}">
          <debug_text text="'all behavior targets destroyed. temporarily switching to behavior %s'.[@$behaviors.{$behaviorindex}]" chance="$debugchance"/>
        </do_if>
      </do_if>

      <do_if value="$forceprimarytarget and $primarytarget.canbeattacked">
        <set_value name="$target" exact="$primarytarget"/>
        <set_value name="$skiptargetselection"/>
      </do_if>

      <do_if value="not $skiptargetselection?">
        <debug_text text="'selecting target. primary target: %s %s, num secondary targets: %s'.[@$locprimarytarget.knownname, $locprimarytarget, @$locsecondarytargets.count]" chance="$debugchance"/>
        <!-- Select the best target -->
        <run_script name="'lib.target.selection'">
          <param name="primarytarget" value="$locprimarytarget"/>
          <param name="secondarytargets" value="$locsecondarytargets"/>
          <param name="escort" value="$escort"/>
          <param name="pursuedistance" value="$pursuedistance"/>
          <param name="pursuetargets" value="$pursuetargets"/>
          <param name="list_objectstoignore" value="$locignorelist"/>
          <param name="allowothertargets" value="$allowothertargets"/>
          <param name="targetclasses" value="$targetclasses"/>
          <param name="checkrelation" value="$checkrelation"/>
          <param name="radius" value="$radius"/>
          <param name="radiusanchorpos" value="$radiusanchorpos"/>
          <param name="radiusanchorspace" value="$radiusanchorspace"/>
          <param name="debugchance" value="$debugchance"/>
          <!-- The selected target as return value -->
          <save_retval name="target" variable="$target"/>
        </run_script>
        <debug_text text="'target found? %s. target: %s %s %s isoperational: %s'.[$target, @$target.idcode, @$target.knownname, $target, @$target.isoperational]" chance="$debugchance"/>
      </do_if>
      <remove_value name="$skiptargetselection"/>
      <remove_value name="$locignorelist"/>
      <remove_value name="$locprimarytarget"/>
      <remove_value name="$locsecondarytarget"/>

      <do_if value="not $target">
        <debug_text text="'no valid target'" chance="$debugchance"/>
        <resume label="finish"/>
      </do_if>
      <do_elseif value="not @$target.canbeattacked">
        <debug_text text="'target cannot be attacked.'" chance="$debugchance"/>
        <resume label="finish"/>
      </do_elseif>
      <do_else>
        <!-- Target selected -->
        <set_command command="command.attackobject" param="if $target.container then $target.container else $target"/>
        <debug_text text="'Found target: %1(%2)'.[$target.knownname, $target]" chance="$debugchance" />
      </do_else>

      <do_if value="$boardingtarget? and $boardingtarget == @$primarytarget">
        <debug_text text="'%s %s boarding %s %s.\n target acquired: %s %s\n boarding behavior: %s\n current practical behavior: %s'.[this.assignedcontrolled.knownname, this.assignedcontrolled, @$primarytarget.knownname, @$primarytarget, $target.knownname, $target, $boardingbehavior, @$behaviors.{$behaviorindex}]" chance="$debugchance"/>
      </do_if>

      <label name="fight"/>

      <do_if value="this.defensible.exists">

        <do_if value="@$target.canbeattacked">
          <do_if value="@$target.dock">
            <debug_text text="'%s (%s) disengaging. %s (%s) is docked.'.[this.ship.knownname, this.ship, $target.knownname, $target]" chance="$debugchance"/>
            <resume label="acquirenewtarget"/>
          </do_if>
          <do_elseif value="$target.zone.isclass.highway">
            <debug_text text="' %s (%s) disengaging. %s (%s) is in a highway.'.[this.ship.knownname, this.ship, $target.knownname, $target]" chance="$debugchance"/>
            <resume label="acquirenewtarget"/>
          </do_elseif>

          <!-- HACK: force relation boost from this to player, if check relation is false -->
          <do_if value="not $checkrelation">
            <do_if value="$target.isplayerowned and not this.mayattack.{$target}">
              <add_relation_boost object="this" otherobject="$target" value="this.owner.relation.kill.max" decay="1" delay="10min" silent="true" />
            </do_if>
          </do_if>
          <do_elseif value="not this.mayattack.{$target}">
            <debug_text text="'%s (%s) is not authorized to attack %s (%s). disengaging.'.[this.ship.knownname, this.ship, $target.knownname, $target]" chance="$debugchance"/>
            <resume label="acquirenewtarget"/>
          </do_elseif>
        </do_if>
        <do_else>
          <debug_text text="'%s (%s) does not have an operational target.'.[this.ship.knownname, this.ship]" chance="$debugchance"/>
          <resume label="acquirenewtarget"/>
        </do_else>

        <set_value name="$Defensible" exact="this.defensible"/>

        <!-- Ships -->
        <do_if value="$Defensible.isclass.ship">
          <do_if value="$target.zone.isclass.highway">
            <debug_text text="'Target is in a highway. Breaking off attack.'" chance="$debugchance"/>
            <resume label="acquirenewtarget"/>
          </do_if>

          <do_if value="$escort.exists">
            <set_value name="$refobject" exact="$escort"/>
          </do_if>
          <do_else>
            <set_value name="$refobject" exact="this.ship"/>
          </do_else>

          <!-- If the target is out of range, -->
          <do_if value="this.assignedcontrolled.bboxdistanceto.{$target} gt $pursuedistance">
            <!-- ... and i am allowed to pursue, -->
            <do_if value="$pursuetargets or ($refobject.bboxdistanceto.{$target} le $pursuedistance)">
              <debug_text text="'target out of range and we are allowed to pursue. distance to target: %skm pursuing.'.[$refobject.bboxdistanceto.{$target} / 1000]" chance="$debugchance"/>
              <!-- pursue. -->
              <do_if value="this.zone != $target.zone">
                <!-- NB: move.generic tracks movement between zones, but is not responsive to movement within a zone so as long as we are in the same zone, we will have to rely on combat movement. -->
                <run_script name="'move.generic'" result="$movesuccess">
                  <param name="destination" value="$target"/>
                  <param name="endintargetzone" value="true"/>
                  <param name="activepatrol" value="not $boardingbehavior"/>
                  <param name="recallsubordinates" value="false"/>
                  <param name="radius" value="$radius"/>
                  <param name="radiusanchorpos" value="$radiusanchorpos"/>
                  <param name="radiusanchorspace" value="$radiusanchorspace"/>
                  <param name="strictblacklist" value="$internalorder"/>
                  <param name="debugchance" value="$debugchance"/>
                </run_script>
                <!-- Target can be destroyed while flying to it -->
                <do_if value="not $target.exists or $target.iswreck">
                  <debug_text text="'target was destroyed while we were in pursuit. breaking off attack.'" chance="$debugchance"/>
                  <resume label="acquirenewtarget"/>
                </do_if>
                <do_elseif value="not $movesuccess">
                  <debug_text text="'Unable to move to target possibly due to blacklist. breaking off attack.'" chance="$debugchance"/>
                  <resume label="acquirenewtarget"/>
                </do_elseif>
                <resume label="fight"/>
              </do_if>
            </do_if>
            <!-- ... if i am not allowed to pursue, -->
            <do_else>
              <!-- break off attack. -->
              <debug_text text="'target is either not in the same sector or not within my operational range and i am not authorized to pursue. breaking off attack.\n  my sector: %s\n target sector: %s\n distance to target: %s\n max distance in 10 minutes: %s\n pursue distance: %s'.[this.sector, $target.sector, $refobject.distanceto.{$target}, this.ship.maxspeed*600, $pursuedistance]" chance="$debugchance"/>
              <set_value name="$target" exact="null"/>
              <resume label="acquirenewtarget"/>
            </do_else>
          </do_if>

          <do_if value="this.assignedcontrolled.subordinates.count and this.$escortgroup?">
            <do_if value="$squad_attack">
              <set_value name="$subordinates" exact="this.ship.subordinates"/>
              <do_if value="$allowothertargets">
                <find_ship name="$bigtargets" space="$target.sector" class="[class.ship_xl, class.ship_l]" owner="$target.owner" multiple="true">
                  <match_distance object="this.ship" max="this.ship.maxradarrange"/>
                </find_ship>
                <find_ship name="$smalltargets" space="$target.sector" class="[class.ship_m, class.ship_s]" owner="$target.owner" multiple="true">
                  <match_distance object="this.ship" max="this.ship.maxradarrange"/>
                </find_ship>
                <do_all exact="$subordinates.count" counter="$i">
                  <do_if value="this.$escortgroup.indexof.{$subordinates.{$i}}">
                    <do_if value="$subordinates.{$i}.isclass.[class.ship_xl, class.ship_l, class.ship_m, class.ship_s]">
                      <do_if value="$subordinates.{$i}.isclass.[class.ship_xl, class.ship_l] and $bigtargets.count gt 0">
                        <set_value name="$subtarget" exact="$bigtargets.random"/>
                      </do_if>
                      <do_elseif value="$subordinates.{$i}.isclass.[class.ship_m, class.ship_s] and $smalltargets.count gt 0">
                        <set_value name="$subtarget" exact="$smalltargets.random"/>
                      </do_elseif>

                      <do_if value="not $subtarget?">
                        <set_value name="$subtarget" exact="$target"/>
                      </do_if>
                      <debug_text text="'%1 (%2) sending %3 (%4) to attack %5 (%6). Multiple targets.'.[this.ship.knownname, this.ship, $subordinates.{$i}.knownname, $subordinates.{$i}, $subtarget.knownname, $subtarget]" chance="$debugchance"/>
                      <create_order object="$subordinates.{$i}" id="'Attack'">
                        <param name="primarytarget" value="$subtarget"/>
                        <param name="secondarytargets" value="@$secondarytargetgroup.list"/>
                        <param name="checkrelation" value="$checkrelation"/>
                        <param name="escort" value="$escort"/>
                        <param name="pursuedistance" value="this.ship.maxradarrange"/>
                        <param name="pursuetargets" value="$pursuetargets"/>
                        <param name="disable" value="$disable"/>
                        <param name="disablehullpercentagethreshold" value="$disablehullpercentagethreshold"/>
                        <param name="disabletargets" value="$disabletargets"/>
                        <param name="allowothertargets" value="$allowothertargets"/>
                        <param name="squad_attack" value="$squad_attack"/>
                        <param name="debugchance" value="$debugchance"/>
                      </create_order>
                    </do_if>
                    <remove_value name="$subtarget"/>
                  </do_if>
                </do_all>
              </do_if>
              <do_else>
                <do_all exact="$subordinates.count" counter="$i">
                  <do_if value="this.$escortgroup.indexof.{$subordinates.{$i}}">
                    <debug_text text="'%1 (%2) ordering %3 (%4) to attack %5 (%6). Focus fire.'.[this.ship.knownname, this.ship, $subordinates.{$i}.knownname, $subordinates.{$i}, $target.knownname, $target]" chance="$debugchance"/>
                    <create_order object="$subordinates.{$i}" id="'Attack'">
                      <param name="primarytarget" value="$target"/>
                      <param name="secondarytargets" value="@$secondarytargetgroup.list"/>
                      <param name="checkrelation" value="$checkrelation"/>
                      <param name="escort" value="$escort"/>
                      <param name="pursuedistance" value="this.ship.maxradarrange"/>
                      <param name="pursuetargets" value="$pursuetargets"/>
                      <param name="disable" value="$disable"/>
                      <param name="disablehullpercentagethreshold" value="$disablehullpercentagethreshold"/>
                      <param name="disabletargets" value="$disabletargets"/>
                      <param name="allowothertargets" value="$allowothertargets"/>
                      <param name="squad_attack" value="$squad_attack"/>
                      <param name="internalorder" value="true"/>
                      <param name="debugchance" value="$debugchance"/>
                    </create_order>
                  </do_if>
                </do_all>
              </do_else>
            </do_if>
            <do_else>
              <set_value name="$loctarget" exact="$target"/>
              <do_if value="$loctarget.defensible">
                <set_value name="$loctarget" exact="$loctarget.defensible"/>
              </do_if>
              <do_for_each name="$locsub" in="this.$escortgroup">
                <do_if value="($locsub.assignment == assignment.attack) and not $locsub.subordinategroupdockoverride">
                  <debug_text text="'%s %s %s ordering attack subordinate %s %s %s to attack %s %s %s.'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$locsub.idcode, @$locsub.knownname, $locsub, @$loctarget.idcode, @$loctarget.knownname, $loctarget]" chance="$debugchance"/>
                  <create_order object="$locsub" id="'Attack'">
                    <param name="primarytarget" value="$loctarget"/>
                    <param name="secondarytargets" value="@$secondarytargetgroup.list"/>
                    <param name="checkrelation" value="$checkrelation"/>
                    <param name="escort" value="$escort"/>
                    <param name="pursuedistance" value="this.assignedcontrolled.maxradarrange"/>
                    <param name="pursuetargets" value="$pursuetargets"/>
                    <param name="disable" value="$disable"/>
                    <param name="disablehullpercentagethreshold" value="$disablehullpercentagethreshold"/>
                    <param name="disabletargets" value="$disabletargets"/>
                    <param name="allowothertargets" value="false"/>
                    <param name="squad_attack" value="$squad_attack"/>
                    <param name="internalorder" value="true"/>
                    <param name="debugchance" value="$debugchance"/>
                  </create_order>
                </do_if>
              </do_for_each>
              <remove_value name="$loctarget"/>
            </do_else>
          </do_if>

          <do_if value="this == $Defensible.pilot">
            <!-- by default, all ships using cover remove cover ownership when attacking. -->
            <do_if value="$uncover and this.ship.coverowner">
              <signal_objects object="this.defensible" param="'LoseCover'" param2="false"/>
            </do_if>

            <!-- Small ships -->
            <do_if value="$Defensible.isclass.[class.ship_xs, class.ship_s, class.ship_m]">
              <!-- Against big target (target or container is L,XL or Station) -->
              <do_if value="@$target.iscapitalship or $target.isrealclass.station or (@$target.container.exists and (@$target.container.iscapitalship or $target.container.isrealclass.station))">
                <!-- check for station/ship components -->
                <set_value name="$DefensibleScript" exact="'fight.attack.object.bigtarget'" />
              </do_if>
              <do_else>
                <!-- Against small target -->
                <set_value name="$DefensibleScript" exact="'fight.attack.object.fighter'" />
              </do_else>

              <do_if value="@this.$escortgroup.count">
                <!-- tell to subordinates -->
                <set_value name="$temp_bigtarget" exact="$target"/>
                <do_if value="$target.container">
                  <set_value name="$temp_bigtarget" exact="$target.container"/>
                </do_if>

                <debug_text text="'%s %s %s signalling squadron to stay in formation and open fire on %s %s %s'.[this.ship.idcode, this.ship.knownname, this.ship, @$temp_bigtarget.idcode, @$temp_bigtarget.knownname, @$temp_bigtarget]" chance="$debugchance"/>
                <signal_objects group="this.$escortgroup" param="$temp_bigtarget" param2="'leader_attack'"/>
                <remove_value name="$temp_bigtarget"/>
              </do_if>
            </do_if>
            <!-- Capital ships -->
            <do_elseif value="$Defensible.isclass.[class.ship_l, class.ship_xl]">
              <!-- Movement in pilot (also calls the Defence NPC to attack, and tells to the subordinates defence NPCs) -->
              <set_value name="$DefensibleScript" exact="'move.attack.object.capital'" />
            </do_elseif>

            <do_if value="$disable">
              <do_if value="not $disabletargets.count">
                <append_to_list name="$disabletargets" exact="$target"/>
                <do_all exact="@$secondarytargetgroup.count" counter="$i">
                  <append_to_list name="$disabletargets" exact="$secondarytargetgroup.{$i}"/>
                </do_all>
              </do_if>
              <do_if value="$disabletargets.indexof.{$target} or ($target.container and $disabletargets.indexof.{$target.container})">
                <set_value name="$dodisable"/>
              </do_if>
            </do_if>

            <debug_text text="player.age + ': Start script %1 on defensible %2 against %3 (%4)'.[$DefensibleScript, $Defensible, $target.knownname, $target]" chance="$debugchance" />
            <!-- Signal the defence officer to attack -->
            <do_if value="this.ship.defencenpc.exists">
              <do_if value="$disabletargets.count" chance="$debugchance">
                <debug_text text="'$disablehullpercentagethreshold: ' + $disablehullpercentagethreshold + ' disabletargets:'"/>
                <do_all exact="$disabletargets.count" counter="$i">
                  <debug_text text="$disabletargets.{$i}.knownname + ' ' + $disabletargets.{$i}"/>
                </do_all>
              </do_if>

              <!-- NB: $target can be a part of a bigger target, BUT we might have been ordered to attack just that part.
                $primarytarget is what we were ordered to attack.
                If the defence computer is passed a part of a bigger target, it will only target that part.
                If the defence computer is passed the container, it will target all parts of that container.

                SO:
                  if target is part of a bigger target and is not our primary target, pass in the bigger target. -->
              <set_value name="$turrettarget" exact="$target"/>
              <do_if value="$target.container and $target != $primarytarget">
                <set_value name="$turrettarget" exact="$target.container"/>
              </do_if>
              <signal_objects object="this.ship.defencenpc" param="'attack'" param2="$turrettarget" param3="[@$secondarytargetgroup.list, $allowothertargets, $checkrelation, $disabletargets, $disablehullpercentagethreshold, $behaviortargetclasses]"/>
            </do_if>

            <!-- XP Gain: overall battle difficulty, taking potential allies and enemies in the area into account, determine factor.
                targethull / mydps would give you the nominal best time it would take to destroy a target.
                compare with player.age (after run_script) - $pretime.
                use to determine factor.
              targetdps / mydps would give you a rough difficulty.
                use to determine XP gain category.
              is target still operational?
                use to decide between ship_kill_* categories, ship_disabled_* categories, and ship_repel_* categories.

              so:
                a very small fighter destroying a very large destroyer while part of a very large fleet will have a small chance to get a large amount of XP.
                a very large destroyer destroying a very small fighter alone gets a big chance to get a small amount of XP.
                and multiple ships jointly taking down the same target:
                  get the same chance to get XP,
                  but the amount of XP each ship's crew earns depends on the individual relative strengths.

              limitation: ship crews do not gain experience for kills unless explicitly attacking a target. -->
            <set_value name="$myhull" exact="this.assignedcontrolled.hull"/>
            <set_value name="$mydps" exact="this.assignedcontrolled.dps.all"/>
            <set_value name="$targethull" exact="$target.hull"/>
            <set_value name="$targetdps" exact="@$target.dps.all" comment="null if target is something like a surface element or a station module (not a defensible)."/>
            <set_value name="$friendlyhull" exact="0"/>
            <set_value name="$friendlydps" exact="0"/>
            <set_value name="$hostilehull" exact="0"/>
            <set_value name="$hostiledps" exact="0"/>

            <!-- $friendlies includes my ship. Using sortlimit to cap the number of friendlies to the top10 biggest friendly objects and avoid performance spikes in the hull/dps calculation. -->
            <find_object name="$friendlies" space="$target.zone" class="[class.ship, class.station]" checkoperational="true" multiple="true" unit="false" sortbyvalue="loop.element.size" sortdescending="true" sortlimit="10">
              <match mayattack="this.assignedcontrolled" negate="true"/>
            </find_object>
            <do_if value="not $friendlies.indexof.{this.assignedcontrolled}">
              <append_to_list name="$friendlies" exact="this.assignedcontrolled"/>
            </do_if>

            <!-- $hostiles should include my current target. however, target is sometimes not yet considered hostile at this point. Using sortlimit to cap the number of hostiles to the top10 biggest enemies and avoid performance spikes in the hull/dps calculation. -->
            <find_object name="$hostiles" space="$target.zone" class="[class.ship, class.station]" mayattack="this.assignedcontrolled" checkoperational="true" multiple="true" unit="false" sortbyvalue="loop.element.size" sortdescending="true" sortlimit="10"/>
            <do_if value="not $hostiles.count">
              <find_object name="$hostiles" space="$target.zone" class="[class.ship, class.station]" owner="$target.owner" checkoperational="true" multiple="true" unit="false" sortbyvalue="loop.element.size" sortdescending="true" sortlimit="10"/>
            </do_if>
            <do_elseif value="not $hostiles.indexof.{$target}">
              <append_to_list name="$hostiles" exact="$target"/>
            </do_elseif>

            <do_for_each name="$friendlyobject" in ="$friendlies">
              <set_value name="$friendlyhull" exact="$friendlyhull + $friendlyobject.hull"/>
              <!-- don't count repair dps -->
              <set_value name="$friendlyobjectdps" exact="$friendlyobject.dps.all"/>
              <do_if value="$friendlyobjectdps gt 0">
                <set_value name="$friendlydps" exact="$friendlydps + $friendlyobjectdps"/>
              </do_if>
            </do_for_each>
            <remove_value name="$friendlyobjectdps"/>

            <do_for_each name="$hostileobject" in ="$hostiles">
              <set_value name="$hostilehull" exact="$hostilehull + $hostileobject.hull"/>
              <!-- $hostiles can contain surface elements if $target is a surface element. -->
              <set_value name="$hostileobjectdps" exact="@$hostileobject.dps.all"/>
              <do_if value="$hostileobjectdps gt 0">
                <set_value name="$hostiledps" exact="$hostiledps + $hostileobjectdps"/>
              </do_if>
            </do_for_each>
            <remove_value name="$hostileobjectdps"/>

            <do_if value="not $friendlyhull or not $friendlydps or not $hostilehull">
              <!-- changed to simple debug output. dps for a side being 0 is valid. -->
              <debug_text text="'incomplete data. target: %s %s %s, isoperational: %s, target zone: %s %s, friendlyhull: %s, friendlydps: %s, numfriendlies: %s, hostilehull: %s, hostiledps: %s, numhostiles: %s'.[@$target.idcode, $target.knownname, $target, $target.isoperational, $target.zone.knownname, $target.zone, $friendlyhull, $friendlydps, $friendlies.count, $hostilehull, $hostiledps, $hostiles.count]" chance="$debugchance"/>
            </do_if>

            <set_value name="$difficulty_individual" exact="($targetdps / [$mydps, 1].max) + ($targethull / [$myhull, 1].max * 0.5)"/>
            <set_value name="$difficulty_battle" exact="($hostiledps / [$friendlydps, 1].max) + ($hostilehull / [$friendlyhull, 1].max * 0.5)"/>
            <debug_text text="'difficulty_individual: %s\n difficulty_battle: %s\n friendlyhull: %s, friendlydps: %s, numfriendlies: %s\n hostilehull: %s, hostiledps: %s, numhostiles: %s'.[$difficulty_individual, $difficulty_battle, @$friendlyhull, @$friendlydps, $friendlies.count, @$hostilehull, @$hostiledps, $hostiles.count]" chance="$debugchance"/>

            <do_if value="$target.isrealclass.ship">
              <!-- possible outcomes: ship_kill, ship_disable, ship_repel, we're dead.
                difficulty_individual: even dps + even hull == 2 -->
              <do_if value="$difficulty_individual gt 2">
                <set_value name="$XP_categorysuffix" exact="'_hard'"/>
              </do_if>
              <do_else>
                <set_value name="$XP_categorysuffix" exact="'_easy'"/>
              </do_else>
            </do_if>
            <do_elseif value="$target.isrealclass.station">
              <!-- verify that the target was actually destroyed -->
              <set_value name="$XP_category" exact="'ship_kill_station'"/>
              <set_value name="$XP_categorysuffix" exact="null"/>
            </do_elseif>
            <do_elseif value="$target.isrealclass.module">
              <!-- verify that the target was actually destroyed -->
              <set_value name="$XP_category" exact="'ship_kill_stationmodule'"/>
              <set_value name="$XP_categorysuffix" exact="null"/>
            </do_elseif>
            <do_else>
              <!-- verify that the target was actually destroyed -->
              <set_value name="$XP_category" exact="'ship_kill_surfaceelement'"/>
              <set_value name="$XP_categorysuffix" exact="null"/>
            </do_else>

            <set_value name="$pretime" exact="player.age"/>

            <!-- do not reset for player-owned ships since the player might have defined a special weapon group setup. -->
            <do_if value="not this.isplayerowned and not this.assignedcontrolled.dps.all">
              <reset_weapongroups object="this.assignedcontrolled"/>
            </do_if>

            <debug_text text="'%s %s %s attacking %s %s %s. assignment: %s'.[@this.assignedcontrolled.idcode, @this.assignedcontrolled.knownname, this.assignedcontrolled, @$target.idcode, @$target.knownname, $target, @this.assignedcontrolled.assignment]" chance="$debugchance"/>

            <!-- Start the proper script: fighter vs small fighter, fighter vs big target or capital ship vs target -->
            <run_script name="$DefensibleScript">
              <param name="target" value="$target"/>
              <param name="escort" value="$escort"/>
              <param name="pursuedistance" value="$pursuedistance" />
              <param name="pursuetargets" value="$pursuetargets" />
              <param name="allowothertargets" value="$allowothertargets" />
              <param name="checkrelation" value="$checkrelation"/>
              <param name="disable" value="$dodisable?"/>
              <param name="disablehullpercentagethreshold" value="$disablehullpercentagethreshold"/>
              <param name="maintaindistance" value="$maintaindistance"/>
              <param name="boardingbehavior" value="$boardingbehavior"/>
              <param name="behaviortargetclasses" value="$behaviortargetclasses"/>
              <param name="allowboost" value="$allowboost"/>
              <param name="debugchance" value="$debugchance" />
            </run_script>

            <do_if value="not @$target.canbeattacked">
              <set_value name="$XP_categoryprefix" exact="'ship_kill'"/>
            </do_if>
            <do_else>
              <do_if value="$dodisable? and this.assignedcontrolled.distanceto.{$target} le this.assignedcontrolled.maxradarrange">
                <set_value name="$XP_categoryprefix" exact="'ship_disable'"/>
              </do_if>
              <do_else>
                <set_value name="$XP_categoryprefix" exact="'ship_repel'"/>
              </do_else>
            </do_else>
            <remove_value name="$dodisable"/>

            <do_if value="@$XP_category or (@$XP_categoryprefix and @$XP_categorysuffix)">
              <!-- we want a more tangible skill progression up to three stars. set factor to 1 for easy, calculate factor for hard but stack with easy. -->
              <set_value name="$XP_factor" exact="1.0"/>
              <do_if value="not $XP_categorysuffix or ($XP_categorysuffix == '_hard')">
                <set_value name="$XP_factor" exact="[(($hostilehull / [$friendlydps, 1].max)s / [(player.age - $pretime), 1s].max)f, 1.0].min"/>
                <do_if value="$XP_categorysuffix == '_hard'">
                  <set_value name="$XP_stack"/>
                </do_if>
              </do_if>

              <do_if value="not @$XP_category">
                <!-- there are cases where XP_category is set with neither prefix nor suffix. -->
                <set_value name="$XP_category" exact="$XP_categoryprefix + $XP_categorysuffix"/>
              </do_if>

              <set_value name="$XP_preskill" exact="this.assignedcontrolled.combinedskill" chance="$debugchance"/>
              <apply_experience entity="this" experience="$XP_category" factor="$XP_factor"/>
              <apply_experience object="this.assignedcontrolled" role="entityrole.service" experience="$XP_category" factor="$XP_factor"/>
              <do_if value="$XP_stack?">
                <apply_experience entity="this" experience="$XP_categoryprefix + '_easy'" factor="1.0"/>
                <apply_experience object="this.assignedcontrolled" role="entityrole.service" experience="$XP_categoryprefix + '_easy'" factor="1.0"/>
              </do_if>
              <debug_text text="'battle experience earned.\n XP category: %s\n XP factor: %s\n stacked? %s\n this ship: %s %s %s\n target: %s %s %s\n old combinedskill: %s\n new combinedskill: %s'.[$XP_category, $XP_factor, $XP_stack?, this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, @$target.idcode, @$target.knownname, @$target, @$XP_preskill, this.assignedcontrolled.combinedskill]" chance="$debugchance"/>
            </do_if>
            <do_else>
              <debug_text text="'unhandled case. battle finished but no XP category set.\nthis ship: %s %s %s\ntarget: %s %s %s'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, @$target.idcode, @$target.knownname, @$target]" filter="error"/>
            </do_else>

            <remove_value name="$difficulty_battle"/>
            <remove_value name="$difficulty_individual"/>
            <remove_value name="$hostiles"/>
            <remove_value name="$hostilehull"/>
            <remove_value name="$hostiledps"/>
            <remove_value name="$friendlies"/>
            <remove_value name="$friendlyhull"/>
            <remove_value name="$friendlydps"/>
            <remove_value name="$targethull"/>
            <remove_value name="$targetdps"/>
            <remove_value name="$myhull"/>
            <remove_value name="$mydps"/>
            <remove_value name="$XP_factor"/>
            <remove_value name="$XP_category"/>
            <remove_value name="$XP_categoryprefix"/>
            <remove_value name="$XP_categorysuffix"/>
            <remove_value name="$XP_stack"/>
            <remove_value name="$XP_preskill"/>

            <do_if value="$debugchance">
              <debug_text text="'%1 (%2), \n piloted by %3 (%4), \n left %5 after %6s. \n Target: %7 (%8)\n Target still alive? %9'.[this.ship.knownname, this.ship, this.knownname, this, $DefensibleScript, player.age - $pretime, @$target.knownname, $target, $target.isoperational]"/>
              <assert value="player.age - $pretime gt 0" text="'%1 (%2), \n piloted by %3 (%4), \n left %5 after %6s. \nTarget: %7 (%8)\n Target still alive? %9'.[this.ship.knownname, this.ship, this.knownname, this, $DefensibleScript, player.age - $pretime, $target.knownname, $target, $target.isoperational]" break="always"/>
            </do_if>
            <remove_value name="$pretime"/>

            <do_if value="@$primarytarget.canbeattacked and not $primarytarget.isclass.defensible and not $primarytarget.container and not $primarytarget.isrealclass.station">
              <debug_text text="'primary target %s %s is not a defensible and does not have a container. clearing primary target and checking for new targets.'.[$primarytarget.knownname, $primarytarget]" chance="$debugchance"/>
              <set_value name="$primarytarget" exact="null"/>
              <do_if value="this.assignedcontrolled.order.id == 'Attack'">
                <edit_order_param order="this.assignedcontrolled.order" param="'primarytarget'" value="null"/>
                <resume label="selecttarget"/>
              </do_if>
            </do_if>

            <do_if value="$target.canbeattacked and $pursuetargets">
              <resume label="fight"/>
            </do_if>

            <!-- Signal the defence officer to stop the attack -->
            <do_if value="this.ship.defencenpc.exists">
              <signal_objects object="this.ship.defencenpc" param="'attack'" comment="param2 is target = null means stop attack"/>
            </do_if>
          </do_if>
          <do_else>
            <debug_text text="'Error: Attempting to call order.fight.attack.object on an entity which is not the pilot of the ship'" filter="error"/>
            <resume label="finish"/>
          </do_else>
        </do_if>

        <!-- Stations: Do not start script on station defence npc, use signals -->
        <do_elseif value="$Defensible.isrealclass.station">
          <debug_text text="'Error: Attempting to call order.fight.attack.object on an entity which is the Defence NPC of the station'"/>
          <resume label="finish"/>
        </do_elseif>

        <do_else>
          <debug_text text="'Error: Defensible is not of a class which has a suitable script'" filter="error"/>
          <resume label="finish"/>
        </do_else>
      </do_if>
      <do_else>
        <debug_text text="'Error: order.fight.attack.object was called on an entity without a \'defensible\' class parent'" filter="error" />
        <resume label="finish"/>
      </do_else>

      <label name="acquirenewtarget"/>

      <do_if value="$boardingtarget? and $boardingtarget.isoperational and ($primarytarget != $boardingtarget) and ($boardingtarget.owner != this.owner)">
        <!-- script will reinitialize at the next blocking action. would be more efficient to add a wait after edit_order_param, but there's another instance in an interrupt where we cannot have blocking actions, and probably best keep the resulting flow consistent. -->
        <set_value name="$primarytarget" exact="$boardingtarget"/>
        <do_if value="@this.assignedcontrolled.order.id == 'Attack'">
          <edit_order_param order="this.assignedcontrolled.order" param="'primarytarget'" value="$boardingtarget"/>
        </do_if>
        <set_value name="$target" exact="null"/>
        <resume label="selecttarget"/>
      </do_if>

      <do_if value="not $primarytarget.iswreck and ($primarytarget != $target) and (@$primarytarget.iscapitalship or $primarytarget.isrealclass.station)">
        <!-- NB: if attacking something big, $target is often a subcomponent of primarytarget and destruction of primarytarget is the goal of this order. -->
        <debug_text text="'%s %s %s attacking %s %s %s. target is still intact. acquiring new subtarget.'.[this.assignedcontrolled.idcode, this.assignedcontrolled.knownname, this.assignedcontrolled, $primarytarget.idcode, $primarytarget.knownname, $primarytarget]" chance="$debugchance"/>
        <set_value name="$target" exact="null"/>
        <resume label="selecttarget"/>
      </do_if>
      <do_elseif value="$allowothertargets">
        <!-- if we got here and primarytarget or target are still operational, they are no longer considered valid by this ship's combat movement script for whatever reason. discard and search fresh. -->
        <!-- above assumption is now wrong. primarytarget is not necessarily the same as target, and $DefensibleScript returns when $target is no longer a valid attack target. -->
        <set_value name="$target" exact="null"/>
        <resume label="selecttarget"/>
      </do_elseif>

      <label name="finish"/>

      <stop_moving object="this.assignedcontrolled"/>
      <set_to_default_flight_control_model object="this.assignedcontrolled"/>

      <set_value name="$defaultorder" exact="this.assignedcontrolled.defaultorder"/>
      <do_if value="@$speak and not this.assignedcontrolled.nextorder and (@$defaultorder.id != 'Patrol') and (@$defaultorder.id != 'ProtectPosition') and (@$defaultorder.id != 'ProtectShip') and (@$defaultorder.id != 'ProtectStation') and (@$defaultorder.id != 'Plunder') and (@$defaultorder.id != 'Police') and (not this.assignedcontrolled.commander or (this.assignedcontrolled.commander == player.occupiedship)) and notification.npc_await_orders.active">
        <set_value name="$speakline" exact="10304" comment="Awaiting orders."/>
        <run_script name="'player.interaction'">
          <param name="Line" value="$speakline"/>
          <param name="MaxQueueDelay" value="10s"/>
          <param name="caption" value="'%s (%s)'.[this.assignedcontrolled.knownname, this.assignedcontrolled.idcode]"/>
          <param name="interactive" value="false"/>
          <param name="debugchance" value="$debugchance"/>
        </run_script>
      </do_if>
    </actions>
  </attention>
  <on_abort>
    <do_if value="not $keepmoving?">
      <stop_moving object="this.object"/>
    </do_if>
    <set_to_default_flight_control_model object="this.object"/>
    <!-- Send the stop attack order to the Defence NPC -->
    <do_if value="this.ship.defencenpc.exists">
      <signal_objects object="this.ship.defencenpc" param="'attack'" comment="param2 is target = null means stop attack"/>
    </do_if>
  </on_abort>
</aiscript>