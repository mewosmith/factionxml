<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.undock" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="5">
  <!--

this script handles undocking from the current dock
Initial Author: Owen

Important: 
  Undock script will redirect to 'move.unpark' if necessary
  Do NOT use 'move.unpark' directly, instead use 'move.undock'

-->
  <order id="Undock" name="{1041, 531}" description="{1041, 532}" category="internal">
    <params>
      <param name="uselaunchtubes" type="bool" default="false" text="{1041, 10140}" advanced="true" comment="Use launch tubes. Ships in internal storage that undock from a ship with launch tubes are launched from launch tubes. Will be set to false below if container has no launch tubes or ship does not, in fact, launch from a launch tube. Note that this does not assure that ships use launch tubes, but will request their use and involves handling in the script for ships that are launched from launch tubes."/>
      <param name="releasesignal" type="internal" default="null" comment="Release signal. List: [param, param2]. Wait will be cancelled if a signal with $releasesignal.{1} as event.param and $releasesignal.{2} as event.param2 is sent to this.object. While event.param MUST be non-null, event.param2 may be null."/>
      <param name="skipwait" type="internal" default="false" text="{1041, 10116}" comment="Skip wait. Do not wait for the player"/>
      <param name="debugchance" type="bool" default="0" advanced="true" text="{1041, 10086}" comment="Print debug output">
        <input_param name="truevalue" value="100"/>
      </param>
    </params>
  </order>
  <interrupts>
    <handler ref="TargetInvalidHandler"/>
  </interrupts>
  <init>
    <set_command_action commandaction="commandaction.undocking" />

    <set_value name="$thisship" exact="this.assignedcontrolled"/>
    <do_if value="this == player.computer" comment="this is sometimes Betty but Betty is not assigned to control this.ship">
      <set_value name="$thisship" exact="this.ship"/>
    </do_if>

    <do_if value="$thisship.dock and $uselaunchtubes">
      <do_if value="not $thisship.iscapitalship">
        <find_dockingbay name="$docks" object="$thisship.container" checkoperational="1" multiple="1">
          <match_dock size="$thisship.docksize" storage="false"/>
        </find_dockingbay>
        <do_all exact="$docks.count" counter="$i">
          <do_if value="$docks.{$i}.external and not $docks.{$i}.isdockingallowed">
            <set_value name="$found"/>
            <break/>
          </do_if>
        </do_all>
      </do_if>
      <do_if value="not $found?">
        <set_value name="$uselaunchtubes" exact="false"/>
      </do_if>
      <remove_value name="$found"/>
      <remove_value name="$docks"/>
    </do_if>

    <!-- orders that either require no movement or that require thinking before movement. -->
    <set_value name="$blockingorders" exact="['Wait', 'Escort', 'TradeRoutine', 'Middleman', 'MiningRoutine', 'MiningRoutine_Basic', 'MiningRoutine_Advanced', 'MiningRoutine_Expert']"/>
  </init>
  <patch sinceversion="1">
    <do_if value="@$releasesignal.{1} and not player.occupiedship and $thisship.isplayerowned and $thisship.dock and not $thisship.isunit and not $thisship.iscapitalship and not $thisship.islasertower and not $thisship.dock.isventureronly">
      <do_if value="@$thisship.commander.exists and ($thisship.commander == @player.entity.$PlayerTaxi)">
        <signal_objects object="$thisship" param="$releasesignal.{1}" delay="1s"/>
      </do_if>
    </do_if>
  </patch>
  <patch sinceversion="2">
    <set_value name="$dockmodule" exact="null"/>
    <do_if value="$thisship.dock and @$thisship.dock.walkablemodule.isoperational">
      <set_value name="$dockmodule" exact="$thisship.dock.walkablemodule"/>
    </do_if>
  </patch>
  <patch sinceversion="3">
    <!-- NB: possible that $dockmodule has not been initialized yet, in which case, flightbehaviour.undock is consistent with pre-patch behaviour. -->
    <do_if value="@$dockmodule.haswaypointpath.{$thisship.assigneddock.grouptag}.[tag.dockpath, tag.start]">
      <set_value name="$flightbehaviour" exact="flightbehaviour.undockpath"/>
    </do_if>
    <do_else>
      <set_value name="$flightbehaviour" exact="flightbehaviour.undock"/>
    </do_else>
  </patch>
  <patch sinceversion="5">
    <set_value name="$blockingorders" exact="['Wait', 'Escort', 'TradeRoutine', 'Middleman', 'MiningRoutine', 'MiningRoutine_Basic', 'MiningRoutine_Advanced', 'MiningRoutine_Expert']"/>
  </patch>
  <attention min="unknown">
    <actions>

      <!-- redirect to unparking script -->
      <do_if value="$thisship.parkedat">
        <run_script name="'move.unpark'" />
        <return />
      </do_if>

      <label name="start" />

      <do_if value="$thisship.isunit and @$thisship.order.id == 'Undock'">
        <!-- once a unit starts undocking, it must finish, otherwise it could get stuck in a state where it won't be recovered. -->
        <set_order_state order="$thisship.order" state="orderstate.critical"/>
      </do_if>

      <do_if value="@$releasesignal.{1} and not player.occupiedship and $thisship.isplayerowned and $thisship.dock and not $thisship.isunit and not $thisship.iscapitalship and not $thisship.islasertower and not $thisship.dock.isventureronly">
        <set_value name="$playertoplvlcontainer" exact="player.entity.container"/>

        <do_while value="$playertoplvlcontainer.container">
          <set_value name="$playertoplvlcontainer" exact="$playertoplvlcontainer.container"/>
        </do_while>
        <debug_text text="'playertoplvlcontainer is %s %s.'.[$playertoplvlcontainer.knownname, $playertoplvlcontainer]" chance="$debugchance"/>

        <do_if value="$playertoplvlcontainer == $thisship.container">

          <debug_text text="'$thisship == @player.entity.$PlayerTaxi: ' + ($thisship == @player.entity.$PlayerTaxi) + ', not @player.entity.$PlayerTaxi.isoperational: ' + (not @player.entity.$PlayerTaxi.isoperational) + ', not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer}: ' + (not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer})" chance="$debugchance"/>
          <do_if value="($thisship != player.container) and not $skipwait and (not $thisship.commander) and (($thisship == @player.entity.$PlayerTaxi) or not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer})">
            <debug_text text="'waiting for the player.\n ($thisship != player.container): %s\n not $skipwait: %s\n (not $thisship.commander or ($thisship.commander == @player.entity.$PlayerTaxi)): %s\n (($thisship == @player.entity.$PlayerTaxi) or not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer}): %s'.[($thisship != player.container), not $skipwait, (not $thisship.commander or ($thisship.commander == @player.entity.$PlayerTaxi)), (($thisship == @player.entity.$PlayerTaxi) or not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer})]" chance="0"/>
            <debug_text text="'player taxi docked on %s %s and the player is not on board. waiting. time started: %s'.[$playertoplvlcontainer.knownname, $playertoplvlcontainer, player.age]" chance="$debugchance"/>
            <run_script name="'player.interaction'">
              <param name="Line" value="10802" comment="(Informing player ship will not undock before they return)I'll wait for you to tell me to take off."/>
              <param name="MaxQueueDelay" value="10s"/>
              <param name="caption" value="'%s (%s)'.[$thisship.knownname, $thisship.idcode]"/>
              <param name="interactive" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </run_script>
            <wait>
              <interrupt>
                <conditions>
                  <check_any>
                    <event_object_signalled object="$thisship" param="$releasesignal.{1}"/>
                    <check_all>
                      <event_player_teleport_successful/>
                      <check_value value="not player.entity.hascontext.{$playertoplvlcontainer}"/>
                    </check_all>
                    <check_all>
                      <event_object_undocked_from container="$playertoplvlcontainer"/>
                      <check_value value="player.entity.hascontext.{event.param}"/>
                    </check_all>
                    <check_all>
                      <!-- proceed when the player issues a new order. -->
                      <event_object_order_ready object="this.assignedcontrolled"/>
                      <check_value value="@$releasesignal.{1} == 'playerownedship_proceed'"/>
                      <check_value value="(event.param != this.assignedcontrolled.order) and (event.param != this.assignedcontrolled.defaultorder)"/>
                      <debug_text text="'Undock proceed: new order: ' + @event.param.id" debugchance="$debugchance"/>
                    </check_all>
                  </check_any>
                </conditions>
                <actions>
                  <debug_text text="'player ship %s %s wait interrupted by %s. undocking.'.[$thisship.knownname, $thisship, event.name]" chance="$debugchance"/>
                  <set_value name="$skipwait"/>
                </actions>
              </interrupt>
            </wait>
            <remove_value name="$currentorders"/>
          </do_if>
          <do_else>
            <debug_text text="'%s %s %s skipped wait.\n ($thisship != player.container): %s\n not $skipwait: %s\n (not $thisship.commander or ($thisship.commander == @player.entity.$PlayerTaxi)): %s\n (($thisship == @player.entity.$PlayerTaxi) or not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer}): %s'.[$thisship.idcode, $thisship.knownname, $thisship, ($thisship != player.container), not $skipwait, (not $thisship.commander or ($thisship.commander == @player.entity.$PlayerTaxi)), (($thisship == @player.entity.$PlayerTaxi) or not @player.entity.$PlayerTaxi.isoperational or not @player.entity.$PlayerTaxi.hascontext.{$playertoplvlcontainer})]" chance="0"/>
          </do_else>

          <do_if value="not $skipwait and $thisship == @player.ship">
            <!-- if it's otherwise ok to undock, but player is on board, wait a few seconds to allow the player to leave or stay as they would like. -->
            <debug_text text="'player is on board. waiting 30 seconds.'" chance="$debugchance"/>
            <run_script name="'player.interaction'">
              <param name="Line" value="10801" comment="(Informing player ship will soon undock)The ship will be undocking soon."/>
              <param name="MaxQueueDelay" value="10s"/>
              <param name="caption" value="'%s (%s)'.[$thisship.knownname, $thisship.idcode]"/>
              <param name="interactive" value="false"/>
              <param name="debugchance" value="$debugchance"/>
            </run_script>
            <wait exact="30s">
              <interrupt>
                <conditions>
                  <check_any>
                    <event_object_signalled object="$thisship" param="$releasesignal.{1}"/>
                    <check_all>
                      <event_object_changed_room object="player.entity"/>
                      <check_value value="event.param2.container == $thisship"/>
                      <check_value value="not $skipwait"/>
                    </check_all>
                  </check_any>
                </conditions>
                <actions>
                  <do_if value="event.name == 'event_object_changed_room'">
                    <resume label="start"/>
                  </do_if>
                </actions>
              </interrupt>
            </wait>
          </do_if>
        </do_if>
        <remove_value name="$playertoplvlcontainer"/>
      </do_if>

      <debug_text text="'undock start ' + $thisship.knownname + ' (%1) in %2'.[$thisship, this.zone.knownname]" chance="$debugchance"/>
      <do_if value="this.attention ge attention.visible">
        <set_value name="$Objects" exact="table[{'$UndockingObject'} = $thisship]" />
        <signal_objects object="player.entity" param="'npc_management'" param2="table[{'$Usecase'} = 'undocking', {'$Priority'} = 50, {'$Objects'} = $Objects]" />
      </do_if>

      <!-- check if we are currently docked -->
      <do_if value="$thisship.dock">
        <do_if value="this.zone.isclass.highway">
          <debug_text text="'undocking. container is in a highway.'" chance="$debugchance"/>
        </do_if>
        <debug_text text="$thisship.knownname + ' is docked, so undock'" chance="$debugchance" />

        <disable_collisions_between object="$thisship" target="$thisship.container"/>

        <set_command_action commandaction="commandaction.undocking" />

        <do_if value="not this.assignedcontrolled and (this != player.computer)" comment="this is sometimes Betty undocking">
          <debug_text text="'this trying to undock this ship but this.assignedcontrolled is null.\n this: %s %s %s. this.ship.pilot: %s %s. this ship: %s %s %s'.[this.class, this.knownname, this, @this.ship.pilot.knownname, this.ship.pilot, this.ship.class, this.ship.knownname, this.ship]"/>
        </do_if>

        <do_if value="$thisship.iscapitalship">
          <do_if value="$thisship.dock.isbuildingallowed">
            <set_value name="$docktype" exact="'build'" comment="drydock cage. undock forward."/>
          </do_if>
          <do_elseif value="$thisship.dock.container.isclass.station">
            <set_value name="$docktype" exact="'trade'" comment="pier. undock backward."/>
          </do_elseif>

          <detach_from_masstraffic object="$thisship" wait="true" >
            <interrupt_after_time time="5min" />
          </detach_from_masstraffic>
        </do_if>

        <!--$thisship.dock at this point could be the internal storage dockingbay. Avoid using it for movement actions-->
        <do_if value="$uselaunchtubes">
          <request_undocking ship="$thisship" queuedresult="$queuedresult" grantedresult="$grantedresult" highpriority="true"/>
        </do_if>
        <do_else>
          <request_undocking ship="$thisship" queuedresult="$queuedresult" grantedresult="$grantedresult" highpriority="false"/>
        </do_else>
        <set_value name="$time_startdocking" exact="player.age"/>
        <do_if value="$grantedresult">
          <debug_text text="'allowed to undock immediately'" chance="$debugchance"/>
          <do_if value="$thisship.dock.isstorage">
            <debug_text text="'%1 (%2) was allowed to immediately undock from internal storage. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" filter="error" chance="$debugchance"/>
          </do_if>
          <resume label="undock" />
        </do_if>
      </do_if>

      <label name="wait" />

      <do_if value="$time_startdocking?">
        <do_if value="$queuedresult">
          <debug_text text="'waiting for free dock'" chance="$debugchance" />
          <!-- we WILL be allowed to undock and, if in internal storage, we cannot do anything unless given a free dock anyway. -->
          <wait exact="if $thisship.dock.container.isclass.ship then 30s else 10min">
            <interrupt>
              <conditions>
                <event_object_undocking_cleared object="$thisship" />
              </conditions>
            </interrupt>
          </wait>
          <do_if value="not $thisship.assigneddock">
            <do_if value="(player.age - $time_startdocking) ge 5min">
              <debug_text text="'after waiting %7min in queue, %1 (%2) does not have an assigned dock. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6\n => restart'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id, (player.age - $time_startdocking)/1min]" filter="error"/>
              <resume label="start"/>
            </do_if>
            <resume label="wait"/>
          </do_if>
          <do_elseif value="@$thisship.assigneddock.isstorage">
            <do_if value="(player.age - $time_startdocking) ge 5min">
              <debug_text text="'after waiting %7min in queue, %1 (%2) was assigned an internal storage dock. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6\n => restart'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id, (player.age - $time_startdocking)/1min]" filter="error"/>
              <resume label="start"/>
            </do_if>
            <resume label="wait"/>
          </do_elseif>
        </do_if>
        <do_else>
          <assert value="false" text="'request_undocking did not return a queued or granted result, which should only be possible if the ship is not docked! [Matthias]'" />
          <!--if this is just a missed case the script will simply retry undocking periodically and eventually continue-->
        </do_else>
      </do_if>

      <label name="undock" />

      <do_if value="$thisship.dock">
        <!--set the undocking state so that the game known not to put this ship into storage to make way for another ship that wants to dock or undock-->
        <set_ship_undocking ship="$thisship" />
        <!--wait a random amount of time to break up the synchronization of many ships undocking simultaneously-->
        <wait min="0.4s" max="0.5s" />
        <!--perform another undock request to catch state changes like the container having entered a highway since having been granted undocking clearance-->
        <do_if value="$uselaunchtubes">
          <request_undocking ship="$thisship" queuedresult="$queuedresult" grantedresult="$grantedresult" highpriority="true"/>
        </do_if>
        <do_else>
          <request_undocking ship="$thisship" queuedresult="$queuedresult" grantedresult="$grantedresult" highpriority="false"/>
        </do_else>
        <do_if value="not $grantedresult">
          <debug_text text="'not granted docking clearance. waiting.'" chance="$debugchance"/>
          <resume label="wait" />
        </do_if>

        <debug_text text="'%1 (%2) waited for %3 seconds to undock'.[$thisship.knownname, $thisship, player.age - $time_startdocking]" chance="$debugchance"/>
        <remove_value name="$time_startdocking"/>
        <do_if value="not @$olddock">
          <set_value name="$olddock" exact="$thisship.dock" />
          <do_if value="$olddock.walkablemodule.isoperational">
            <set_value name="$dockmodule" exact="$olddock.walkablemodule" />
          </do_if>
        </do_if>
        <set_value name="$isship" exact="$olddock.container.isclass.ship" />

        <do_if value="$olddock.isstorage and (not $thisship.assigneddock or $thisship.assigneddock.isstorage)">
          <debug_text text="player.age + ': %1 (%2) tried to undock directly from internal storage. waiting. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" filter="error" chance="$debugchance"/>
          <wait>
            <interrupt>
              <conditions>
                <event_object_dock_assigned object="$thisship"/>
                <check_value value="$thisship.assigneddock and not $thisship.assigneddock.isstorage"/>
                <!--<check_value value="not $thisship.dock.isstorage or ($thisship.assigneddock and not $thisship.assigneddock.isstorage)"/>-->
              </conditions>
              <actions>
                <debug_text text="player.age + ': Recovery: %1 (%2) was assigned a non-storage docking bay. undocking. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6 \n'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" chance="$debugchance"/>
              </actions>
            </interrupt>
          </wait>
          <set_value name="$olddock" exact="$thisship.assigneddock"/>
          <do_if value="not $thisship.assigneddock">
            <debug_text text="'After recovery, %1 (%2) was not assigned a dock. \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6 \n'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" filter="error"/>
          </do_if>
          <do_elseif value="$thisship.dock.isstorage">
            <debug_text text="'After recovery, %1 (%2) is STILL in storage. wait longer? \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6 \n'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $thisship.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id]" filter="error"/>
          </do_elseif>
          <resume label="undock"/>
        </do_if>

        <!-- things like mining drones do not have orders. -->
        <do_if value="$thisship.order and ($thisship.order.state != orderstate.critical)">
          <!-- if the player is controlling this ship, they could decide to undock bypassing the need for any undock order, suppress error output as this is a valid scenario which is handled by md\Orders.xml, cue DockAndWait_PlayerUndocked -->
          <do_if value="$thisship != player.controlled">
            <do_if value="$thisship.order.id == 'Undock'">
              <set_order_state order="$thisship.order" state="orderstate.critical"/>
            </do_if>

            <do_if value="$thisship.order == $thisship.defaultorder">
              <debug_text text="'move.undock called via run_script from default order: %1'.[$thisship.order.id]" filter="error"/>
            </do_if>
          </do_if>
        </do_if>

        <do_if value="$uselaunchtubes and (not $thisship.dock or not $thisship.dock.external or $thisship.dock.isdockingallowed)">
          <set_value name="$uselaunchtubes" exact="false"/>
        </do_if>

        <undock ship="$thisship" />

        <do_if value="$thisship.isunit and $olddock.container.defencenpc.$launchedunitcount?">
          <set_value name="$olddock.container.defencenpc.$launchedunitcount.{1}" exact="$olddock.container.defencenpc.$launchedunitcount.{1} + 1"/>
          <debug_text text="'incrementing unit count. present count: ' + $olddock.container.defencenpc.$launchedunitcount.{1}" chance="$debugchance"/>
          <do_if value="$olddock.container.defencenpc.$launchedunitcount.{1} ge $olddock.container.defencenpc.$launchedunitcount.{2}">
            <debug_text text="'all units out. cleaning up counter and sending release signal.'" chance="$debugchance"/>
            <remove_value name="$olddock.container.defencenpc.$launchedunitcount"/>
            <signal_objects object="$olddock.container" param="'units_go'"/>
          </do_if>
        </do_if>

        <do_if value="$uselaunchtubes and not @$thisship.dock">
          <!-- NB: ships launched from launch tubes are immediately "in the air" so can deactivate landing gears immediately. -->
          <deactivate_landinggears object="$thisship"/>
          <set_value name="$landinggears_up"/>
        </do_if>

        <wait min="1s" max="3s" />

        <do_if value="@$thisship.dock">
          <debug_text text="player.age + ': undocking is delayed, wait for event'" chance="$debugchance"/>
          <wait>
            <interrupt>
              <conditions>
                <event_object_undocked object="$thisship" />
              </conditions>
            </interrupt>
          </wait>
        </do_if>
        <debug_text text="player.age + ': ship has undocked'" chance="$debugchance"/>

        <do_if value="not $landinggears_up?">
          <deactivate_landinggears object="$thisship"/>
          <set_value name="$landinggears_up"/>
        </do_if>

        <!-- consider enforcing this for general use. at the moment, only urgent for drones since the player can tell undocking drones to immediately dock while undocking and, if the ship is moving, the drones fly over the cockpit after undocking. -->
        <do_if value="$thisship.isunit">
          <debug_text text="'not docked: %s, container is ship: %s, not capship: %s, not in highway: %s'.[not $thisship.dock, $olddock.container.isclass.ship, not $thisship.iscapitalship, not this.zone.isclass.highway]" chance="$debugchance"/>
          <do_if value="not $thisship.dock and $olddock.container.isclass.ship and not $thisship.iscapitalship and not this.zone.isclass.highway">
            <debug_text text="'%s %s %s just undocked. keeping station with %s %s %s'.[@$thisship.idcode, @$thisship.knownname, $thisship, @$olddock.container.idcode, @$olddock.container.knownname, $olddock.container]" chance="$debugchance"/>
            <!-- very short movement to stabilize the drone until whiskers can go up. -->
            <move_to destination="$olddock.container" object="$thisship" relativemovement="true" sinceversion="4">
              <position z="1m" object="$thisship"/>
              <interrupt_after_time time="1s"/>
            </move_to>
          </do_if>
        </do_if>

        <do_if value="$thisship.isdeployable or $thisship.isclass.ship_xs">
          <!-- NB: deployables and XS ships should be pushed clear of their old dock upon launch. -->
          <set_value name="$alreadyclear"/>
        </do_if>

        <!-- For the player do the same move_docking, but interrupt it earlier. Movement to 'launchpos' -->
        <do_if value="not $alreadyclear? and $olddock.isoperational and not this.zone.isclass.highway">
          <!-- TODO: problem: if the ship we are docking with is docking or undocking, setting their flight control model to spline will break things.
                ideally, we would set_avoid_collisions smallobjects="false" on the ship we're docking with.
                problem is if that ship is itself docking or undocking and has non-normal collision settings. -->
          <!-- workaroundy - forcing fcm here to spline because spline does not try to maintain separation with small ships found via gravidar. -->
          <!--<do_if value="$olddock.container.isclass.ship_m">
            <set_flight_control_model object="$olddock.container" flightcontrolmodel="flightcontrolmodel.spline"/>
          </do_if>-->

          <do_if value="$thisship != player.occupiedship or $uselaunchtubes">
            <do_if value="$olddock.external and not $olddock.isdockingallowed">
              <debug_text text="player.age + ': starting move_undocking, to be interrupted after 1 second'" chance="$debugchance" />
              <move_undocking object="$thisship" dock="$olddock" finishonapproach="false" forceposition="false" forcerotation="false" forcesteering="$isship" flightbehaviour="flightbehaviour.undock" commandaction="false">
                <interrupt>
                  <conditions>
                    <check_any>
                      <event_object_destroyed object="$olddock.container"/>
                      <event_object_changed_cluster object="$olddock.container"/>
                      <check_all>
                        <event_object_changed_zone object="$olddock.container"/>
                        <check_any>
                          <check_value value="$olddock.zone.isclass.highway"/>
                          <check_value value="$olddock.zone != this.zone and this.distanceto.{$olddock.container} gt $thisship.size"/>
                        </check_any>
                      </check_all>
                    </check_any>
                  </conditions>
                </interrupt>
                <interrupt_after_time time="1s"/>
              </move_undocking>
              <set_value name="$alreadyclear" comment="will skip all further undocking movement"/>
            </do_if>
            <do_else>
              <debug_text text="player.age + ': starting move_undocking'" chance="$debugchance" />
              <set_value name="$forcesteering" exact="$isship" />
              <do_if value="@$dockmodule.haswaypointpath.{$olddock.grouptag}.[tag.dockpath, tag.start]">
                <set_value name="$flightbehaviour" exact="flightbehaviour.undockpath" />
                <set_value name="$forcesteering" exact="true" />
              </do_if>
              <do_else>
                <set_value name="$flightbehaviour" exact="flightbehaviour.undock" />
              </do_else>
              <stop_moving object="$thisship"/>
              <move_undocking object="$thisship" dock="$olddock" finishonapproach="false" forceposition="false" forcerotation="false" forcesteering="$forcesteering" flightbehaviour="$flightbehaviour" commandaction="false">
                <interrupt>
                  <conditions>
                    <check_any>
                      <event_object_destroyed object="$olddock.container"/>
                      <event_object_changed_cluster object="$olddock.container"/>
                      <check_all>
                        <event_object_changed_zone object="$olddock.container"/>
                        <check_any>
                          <check_value value="$olddock.zone.isclass.highway"/>
                          <check_value value="$olddock.zone != this.zone and this.distanceto.{$olddock.container} gt $thisship.size"/>
                        </check_any>
                      </check_all>
                    </check_any>
                  </conditions>
                  <actions>
                    <set_value name="$alreadyclear"/>
                  </actions>
                </interrupt>
              </move_undocking>
            </do_else>
          </do_if>
        </do_if>

        <do_if value="@$thisship.dock">
          <debug_text text="'%1 (%2) was moved to a dock AFTER undocking. external? %7 storage? %8 \n attention: %3 \n undocking from: %4 \n present dock: %5 \n assigned dock: %6'.[$thisship.knownname, $thisship.idcode, $thisship.attention, $olddock.container.macro.id, $thisship.dock.macro.id, @$thisship.assigneddock.macro.id, $thisship.dock.external, $thisship.dock.isstorage]" filter="error" chance="$debugchance"/>
          <resume label="start"/>
        </do_if>

        <debug_text text="player.age + ': undock!'" chance="$debugchance" />
        <do_if value="$olddock.exists and $olddock.container.isoperational">
          <remove_docking_request ship="$thisship" container="$olddock.container"/>
          <enable_collisions_between object="$thisship" target="$olddock.container"/>
          <do_if value="$olddock.container.isclass.ship_m">
            <set_to_default_flight_control_model object="$olddock.container"/>
          </do_if>
        </do_if>

        <do_if value="$thisship == player.occupiedship">
          <debug_text text="player.age + ': stopping auto pilot!'" chance="$debugchance" />
          <stop_player_autopilot />
          <!-- don't do anything else, the player takes over from now on -->
          <return />
        </do_if>
        <do_elseif value="not $alreadyclear?">
          <!-- move to exit paths/positions, unless we're already clear of the object -->
          <do_if value="@$dockmodule.isoperational and not this.zone.isclass.highway and $olddock.container.exists and $olddock.container.bboxdistanceto.{$thisship} lt $thisship.size">
            <!-- Check if there is a valid dock area exit path, prefer it over an exit position -->
            <do_if value="$dockmodule.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start]">
              <debug_text text="'moving along exit path'" chance="$debugchance" />
              <move_waypoints object="$thisship" destination="$dockmodule" tags="tag.exitpath" starttags="tag.start" finishonapproach="true" relativemovement="$isship" flightbehaviour="flightbehaviour.undock" forcesteering="$isship" commandaction="false" abortpath="false">
                <interrupt_after_time time="0s"/>
              </move_waypoints>
            </do_if>
            <!-- Now check if there is a valid exit position -->
            <do_elseif value="$dockmodule.hasexitpos">
              <debug_text text="'moving to exit position'" chance="$debugchance" />
              <move_to object="$thisship" destination="$dockmodule" finishonapproach="true" relativemovement="$isship" flightbehaviour="flightbehaviour.undock" forcesteering="$isship" forceposition="false" forcerotation="false" commandaction="false" abortpath="false">
                <position value="$dockmodule.exitpos" />
                <interrupt_after_time time="0s"/>
              </move_to>
            </do_elseif>

            <!-- Check if there is a valid object exit path -->
            <do_if value="@$olddock.container.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start]">
              <debug_text text="'moving along exit path'" chance="$debugchance" />
              <move_waypoints object="$thisship" destination="$olddock.container" tags="tag.exitpath" starttags="tag.start" finishonapproach="true" relativemovement="$isship" flightbehaviour="flightbehaviour.undock" forcesteering="$isship" commandaction="false" abortpath="false">
                <interrupt_after_time time="0s"/>
              </move_waypoints>
            </do_if>
            <!-- Dock area does not define exit path or position, we can only assume it's trivial to fly out of the dock -->
          </do_if>
        </do_elseif>

        <do_if value="this.zone.isclass.highway">
          <set_value name="$zone" exact="this.zone.destination"/>
        </do_if>
        <do_else>
          <set_value name="$zone" exact="this.zone"/>
        </do_else>

        <!-- clear the dockingbay/dockmodule -->
        <do_if value="not $alreadyclear?">
          <do_if value="$thisship.iscapitalship and $docktype?">
            <set_value name="$locquadrant" exact="quadrant.back"/>
            <do_if value="$docktype == 'build'">
              <set_value name="$locquadrant" exact="quadrant.front"/>
            </do_if>
            <!-- at this point, already at launchpos -->
            <!-- this case assumes that we are undocking from a station which cannot be in a highway so that this.zone is $zone. if not, value="$thisship.position" would have to be looked at. -->
            <debug_text text="'WARNING: safepos assumes that we are not in a highway, but we are. re-evaluate usage of $thisship.position.\n current zone: %s %s\n $zone: %s %s'.[@this.zone.knownname, this.zone, @$zone.knownname, $zone]" chance="(this.zone != $zone) * 100"/>
            <get_safe_pos result="$safepos" zone="$zone" radius="$thisship.size / 2.0" value="$thisship.position" directionobject="$thisship" direction="$locquadrant" allowyaxis="false"/>
            <remove_value name="$locquadrant"/>
          </do_if>
          <do_else>
            <do_if value="$olddock.exists and $olddock.container.exists and $olddock.container.zone and $olddock.container.zone == $zone">
              <get_safe_pos result="$safepos" zone="$zone" object="$olddock" radius="$thisship.size / 2.0" min="$olddock.size / 2.0 + $thisship.size / 2.0" max="$olddock.size + $thisship.size" allowyaxis="true" directionobject="$thisship" direction="quadrant.front" angle="45deg"/>
              <!--<get_safe_pos result="$safepos" zone="$zone" object="$olddock.container" radius="$thisship.size / 2.0" min="$olddock.container.size / 2.0 + $thisship.size / 2.0" max="$olddock.container.size + $thisship.size" allowyaxis="true"/>-->
            </do_if>
            <do_elseif value="this.zone == $zone">
              <get_safe_pos result="$safepos" zone="$zone" object="$thisship" radius="$thisship.size / 2.0" min="$thisship.size / 2.0" max="$thisship.size" allowyaxis="true" directionobject="$thisship" direction="quadrant.front" angle="45deg"/>
            </do_elseif>
            <do_else>
              <get_safe_pos result="$safepos" zone="$zone" radius="$thisship.size / 2.0" min="$thisship.size / 2.0" max="$thisship.size" allowyaxis="true"/>
            </do_else>
          </do_else>
          <debug_text text="'distance to clear area: %s. this ship size: %s. already clear? %s'.[$thisship.distanceto.{$safepos}, $thisship.size, $thisship.distanceto.{$safepos} le $thisship.size/2.0]" chance="$debugchance"/>

          <!-- will not necessarily move forward. will go to move_to with reverse false. -->
          <set_value name="$direction" exact="null"/>
          <do_if value="$thisship.iscapitalship and (@$docktype != 'build')">
            <create_position name="$locolddockpos" space="$thisship" object="$olddock"/>
            <create_position name="$locsafepos" space="$thisship" value="$safepos" object="$zone"/>
            <set_value name="$locevalpos" exact="position.[$locsafepos.x - $locolddockpos.x, $locsafepos.y - $locolddockpos.y, $locsafepos.z - $locolddockpos.z]"/>
            <debug_text text="'evaluating direction. all positions relative to me.\nevalpos: %s\nsafepos: %s\ndockpos: %s'.[$locevalpos, $locsafepos, $locolddockpos]" chance="$debugchance"/>
            <remove_value name="$locsafepos"/>
            <remove_value name="$locolddockpos"/>

            <!-- if dock is behind us and we have to move forward to undock, use default. -->
            <do_if value="($locevalpos.z lt $locevalpos.x) and ($locevalpos.z lt -$locevalpos.x)">
              <debug_text text="'we have to move backwards to undock.'" chance="$debugchance"/>
              <!-- dock is ahead of us -->
              <set_value name="$direction" exact="'reverse'"/>
            </do_if>
            <do_else>
              <debug_text text="'we have to move sideways to undock.'" chance="$debugchance"/>
              <!-- dock is to the side -->
              <set_value name="$direction" exact="'side'"/>
            </do_else>
            <remove_value name="$locevalpos"/>
          </do_if>

          <!-- If is not near the safe position -->
          <debug_text text="'should do undocking movement. distance to safepos: %sm'.[$thisship.distanceto.{$safepos}]" chance="$debugchance"/>
          <do_if value="$thisship.distanceto.{$safepos} gt ($thisship.size / 2.0) and not this.zone.isclass.highway">
            <debug_text text="'passed check 1. dockmodule has waypointpath: %s, container has waypointpath: %s'.[@$dockmodule.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start], @$olddock.container.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start]]" chance="$debugchance"/>
            <do_if value="@$dockmodule.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start] or @$olddock.container.haswaypointpath.{$olddock.grouptag}.[tag.exitpath, tag.start] or ($thisship.nextorder and $blockingorders.indexof.{$thisship.nextorder.id}) or (not $thisship.nextorder and $thisship.defaultorder and $blockingorders.indexof.{$thisship.defaultorder.id})">
              <set_value name="$locundockstarttime" exact="player.age"/>
              <do_if value="$direction == 'side'">
                <set_value name="$rot" exact="$thisship.rotation"/>
                <debug_text text="'big ship undocking from a pier. strafing to launchpos.'" chance="$debugchance"/>
                <move_strafe object="$thisship" destination="$zone" forcerotation="true" abortpath="false">
                  <position value="$safepos"/>
                  <rotation value="$rot"/>
                  <interrupt>
                    <conditions>
                      <check_any>
                        <event_object_destroyed object="$olddock.container"/>
                        <event_object_changed_cluster object="$olddock.container"/>
                        <check_all>
                          <event_object_changed_zone object="$olddock.container"/>
                          <check_any>
                            <check_value value="$olddock.zone.isclass.highway"/>
                            <check_value value="$olddock.zone != this.zone and this.distanceto.{$olddock.container} gt $thisship.size"/>
                          </check_any>
                        </check_all>
                      </check_any>
                    </conditions>
                  </interrupt>
                </move_strafe>
              </do_if>
              <do_else>
                <debug_text text="'moving out of dock area.'" chance="$debugchance"/>
                <do_if value="$direction == 'reverse'">
                  <!-- a ship on spline trying to avoid collisions with a station uses octree navigation which we do not want in this case because we simply want to move backwards and the way is unobstructed due to exclusion zones. -->
                  <set_avoid_collisions object="$thisship" bigobjects="false" smallobjects="false"/>
                </do_if>
                <move_to object="$thisship" destination="$zone" reverse="(@$direction == 'reverse')"  forceposition="false" forcerotation="false" abortpath="false">
                  <position value="$safepos" />
                  <interrupt>
                    <conditions>
                      <check_any>
                        <event_object_destroyed object="$olddock.container"/>
                        <event_object_changed_cluster object="$olddock.container"/>
                        <check_all>
                          <event_object_changed_zone object="$olddock.container"/>
                          <check_any>
                            <check_value value="$olddock.zone.isclass.highway"/>
                            <check_value value="$olddock.zone != this.zone and this.distanceto.{$olddock.container} gt $thisship.size"/>
                          </check_any>
                        </check_all>
                      </check_any>
                    </conditions>
                  </interrupt>
                </move_to>
                <reset_avoid_collisions object="$thisship"/>
              </do_else>
              <debug_text text="'undock movement done after %ss'.[player.age - $locundockstarttime]" chance="$debugchance"/>
              <remove_value name="$locundockstarttime"/>
            </do_if>
            <do_else>
              <move_to object="$thisship" destination="$zone" forceposition="false" forcerotation="false" abortpath="false">
                <position value="$safepos" />
                <interrupt_after_time time="0s" />
              </move_to>
            </do_else>
          </do_if>
        </do_if>
      </do_if>
      <do_elseif value="$thisship.assigneddock">
        <!--Ship may have been interrupted from docking and so has a docking connection but is not docked-->
        <remove_docking_request ship="$thisship" container="$thisship.assigneddock.container" immediate="true" />
      </do_elseif>

    </actions>
  </attention>
  <on_abort>
    <debug_text text="'object %1 running move.undock.on_abort'.[$thisship]" chance="$debugchance" />
    <do_if value="$thisship.assigneddock or @$queuedresult">
      <remove_undocking_request ship="$thisship"/>
    </do_if>
    <do_if value="@$olddock.exists and $olddock.container.isoperational">
      <remove_docking_request ship="$thisship" container="$olddock.container"/>
      <enable_collisions_between object="$thisship" target="$olddock.container"/>
      <do_if value="$olddock.container.isclass.ship_m">
        <set_to_default_flight_control_model object="$olddock.container"/>
      </do_if>
    </do_if>
    <do_if value="$thisship == player.occupiedship and $thisship.dock">
      <undock ship="$thisship"/>
      <deactivate_landinggears object="$thisship"/>
    </do_if>
  </on_abort>
</aiscript>
